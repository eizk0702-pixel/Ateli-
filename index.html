<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>Tabletop Luxury - P2P (Fog + Inspector + Camadas + Biblioteca + Saves)</title>

  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>

  <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Inter:wght@300;400;600&display=swap" rel="stylesheet">

  <style>
    :root{
      --gold:#c5a059;
      --dark-bg:#0f0f0f;
      --panel-bg:rgba(20,20,20,.9);
      --glass:rgba(255,255,255,.03);
      --status-online:#4ade80;
      --status-offline:#ef4444;
      --fog: rgba(0,0,0,0.82);
    }
    body{margin:0;overflow:hidden;background:var(--dark-bg);font-family:'Inter',sans-serif;color:#e0e0e0;}

    #viewport{width:100vw;height:100vh;overflow:hidden;position:relative;background:radial-gradient(circle,#1a1a1a 0%,#0a0a0a 100%);z-index:1;}
    #canvas-container{width:10000px;height:10000px;position:absolute;top:0;left:0;transform-origin:0 0;cursor:grab;z-index:2;}

    /* MAPA = camada 0 */
    #map-container{
      position:absolute;top:0;left:0;
      z-index:5;
      pointer-events:auto; /* palp√°vel */
      transform: translate(0px,0px);
      transform-origin: 0 0;
    }
    #map-container.locked{pointer-events:none;}
    #map-container img{
      display:block;max-width:none;
      user-select:none;
      -webkit-user-drag:none;
      cursor: grab;
      filter: drop-shadow(0 0 25px rgba(0,0,0,.45));
    }
    #map-container.dragging img{cursor: grabbing;}

    .grid-layer{
      position:absolute;top:0;left:0;width:100%;height:100%;
      pointer-events:none;
      background-image:
        linear-gradient(to right, rgba(197,160,89,.05) 1px, transparent 1px),
        linear-gradient(to bottom, rgba(197,160,89,.05) 1px, transparent 1px);
      background-size:50px 50px;
      z-index:6;
    }

    /* Fog overlay (apenas player) */
    #fog-layer{
      position:absolute;top:0;left:0;
      width:10000px;height:10000px;
      pointer-events:none;
      z-index:95; /* acima do mapa e grid, abaixo de menus fixos */
      display:none;
    }

    /* TOKENS = camadas >= 1 */
    .token{
      position:absolute;
      cursor:move;
      user-select:none;
      display:flex;align-items:center;justify-content:center;
      background:transparent;
      overflow:visible;
      transition:filter .2s ease, outline .2s ease, opacity .15s ease;
    }
    .token.locked{cursor:default!important;pointer-events:none;}

    .token-blocker{position:absolute;top:0;left:0;width:100%;height:100%;z-index:50;background:rgba(255,255,255,.001);}
    .token-content-wrapper{width:100%;height:100%;overflow:hidden;display:flex;align-items:center;justify-content:center;pointer-events:none;}

    .token img, .token iframe{
      width:100%;height:100%;border:none;background:transparent;pointer-events:none;
      object-fit:contain;
      transition:transform .2s ease-out;
    }

    .token.selected:not(.locked){
      filter:drop-shadow(0 0 15px var(--gold));
      outline:2px dashed rgba(197,160,89,.6);
      outline-offset:4px;
    }

    .resize-handle{
      position:absolute;width:16px;height:16px;background:var(--gold);
      border:2px solid #fff;border-radius:4px;display:none;z-index:110;
      cursor:nwse-resize;bottom:-8px;right:-8px;
    }
    .token.selected:not(.locked) .resize-handle{display:block;}

    .hud-element{transition:opacity .4s ease, transform .4s ease;}
    .hud-hidden .hud-element{opacity:0!important;pointer-events:none!important;transform:translateY(10px);}

    .sidebar{
      width:300px;background:var(--panel-bg);backdrop-filter:blur(15px);
      height:100vh;position:fixed;left:0;top:0;z-index:1000;
      border-right:1px solid rgba(197,160,89,.2);
      transform:translateX(-100%);
      transition:transform .4s cubic-bezier(.16,1,.3,1);
    }
    .sidebar.open{transform:translateX(0);}
    .toggle-sidebar-btn{
      position:absolute;right:-35px;top:20px;background:var(--panel-bg);
      border:1px solid rgba(197,160,89,.2);border-left:none;
      padding:10px 8px;border-radius:0 8px 8px 0;cursor:pointer;color:var(--gold);
    }

    .controls-top{
      position:fixed;top:20px;left:50%;transform:translateX(-50%);
      display:flex;gap:10px;z-index:1000;background:var(--panel-bg);
      padding:8px;border-radius:40px;border:1px solid rgba(197,160,89,.2);
      backdrop-filter:blur(10px);box-shadow:0 5px 25px rgba(0,0,0,.4);
    }

    .btn-luxury{
      padding:8px 16px;border-radius:20px;font-size:12px;font-weight:600;
      text-transform:uppercase;letter-spacing:1px;transition:all .3s;
      border:1px solid transparent;color:#ccc;background:transparent;
    }
    .btn-luxury:hover,.btn-luxury.active{
      color:var(--gold);background:var(--glass);border-color:rgba(197,160,89,.4);
    }

    .dice-log{
      position:fixed;bottom:25px;right:25px;width:240px;max-height:200px;
      background:var(--panel-bg);border-radius:12px;border:1px solid rgba(197,160,89,.15);
      padding:15px;overflow-y:auto;font-size:13px;z-index:1000;
      box-shadow:0 4px 15px rgba(0,0,0,.3);
    }

    .btn-toggle-hud{
      position:fixed;bottom:25px;left:25px;z-index:2000;background:var(--panel-bg);
      width:45px;height:45px;border-radius:50%;
      display:flex;align-items:center;justify-content:center;
      border:1px solid rgba(197,160,89,.3);cursor:pointer;color:var(--gold);
      box-shadow:0 4px 10px rgba(0,0,0,.4);
    }

    .url-field{
      background:rgba(0,0,0,.3);border:1px solid rgba(197,160,89,.2);color:#fff;
      width:100%;font-size:12px;padding:8px;margin-bottom:10px;outline:none;border-radius:6px;
    }
    .url-field:focus{border-color:var(--gold);background:rgba(0,0,0,.5);}

    h2,h3{font-family:'Cinzel',serif;letter-spacing:1px;color:var(--gold);}

    .network-status{
      position:fixed;top:80px;right:20px;display:flex;align-items:center;gap:10px;
      background:var(--panel-bg);padding:8px 16px;border-radius:20px;
      border:1px solid rgba(197,160,89,.2);font-size:11px;z-index:1000;
      backdrop-filter:blur(10px);
      opacity:0;pointer-events:none;transform:translateY(-10px);transition:all .3s;
    }
    .network-status.show{opacity:1;pointer-events:auto;transform:translateY(0);}

    .status-dot{width:8px;height:8px;border-radius:50%;background:var(--status-offline);box-shadow:0 0 5px currentColor;}
    .status-dot.online{background:var(--status-online);}

    .lock-manager{
      position:fixed;top:20px;right:20px;z-index:1000;display:flex;flex-direction:column;gap:10px;
    }

    #notification{
      position:fixed;top:50%;left:50%;transform:translate(-50%,-50%) scale(.9);
      background:rgba(0,0,0,.9);border:1px solid var(--gold);
      padding:20px 40px;border-radius:10px;z-index:9999;color:var(--gold);
      font-family:'Cinzel',serif;opacity:0;pointer-events:none;transition:all .3s;
    }
    #notification.active{opacity:1;transform:translate(-50%,-50%) scale(1);}

    #role-badge{
      position:fixed;top:140px;right:20px;z-index:1100;background:var(--panel-bg);
      border:1px solid rgba(197,160,89,.2);border-radius:999px;padding:6px 12px;
      font-size:11px;backdrop-filter:blur(10px);opacity:.95;
    }
    #role-badge b{color:var(--gold);}

    /* BIBLIOTECA */
    .library-panel{
      position:fixed;top:170px;right:20px;z-index:1200;width:380px;max-height:560px;
      background:var(--panel-bg);border:1px solid rgba(197,160,89,.2);
      border-radius:16px;padding:12px;backdrop-filter:blur(10px);
      box-shadow:0 10px 30px rgba(0,0,0,.45);overflow:hidden;display:none;
    }
    .library-panel.show{display:block;}
    .library-tabs{display:flex;gap:8px;margin-bottom:10px;}
    .library-tab{
      flex:1;padding:8px 10px;border-radius:12px;border:1px solid rgba(197,160,89,.25);
      background:rgba(255,255,255,.03);font-size:11px;text-transform:uppercase;letter-spacing:.6px;
      cursor:pointer;color:#ccc;text-align:center;
    }
    .library-tab.active{color:var(--gold);border-color:rgba(197,160,89,.55);background:rgba(255,255,255,.05);}
    .library-search{
      width:100%;margin-bottom:10px;padding:8px 10px;border-radius:10px;
      border:1px solid rgba(197,160,89,.2);background:rgba(0,0,0,.35);color:#fff;font-size:12px;outline:none;
    }
    .library-grid{
      overflow:auto;max-height:390px;padding-right:6px;
      display:grid;grid-template-columns:repeat(3,1fr);gap:10px;
    }
    .asset-card{
      border:1px solid rgba(197,160,89,.18);background:rgba(255,255,255,.03);
      border-radius:14px;padding:8px;display:flex;flex-direction:column;gap:8px;
    }
    .asset-thumb{
      width:100%;aspect-ratio:1/1;border-radius:12px;overflow:hidden;border:1px solid rgba(255,255,255,.06);
      background:rgba(0,0,0,.35);display:flex;align-items:center;justify-content:center;
    }
    .asset-thumb img{width:100%;height:100%;object-fit:cover;}
    .asset-actions{display:flex;gap:6px;}
    .asset-actions button{
      flex:1;padding:6px 8px;border-radius:10px;border:1px solid rgba(197,160,89,.25);
      background:rgba(255,255,255,.03);color:#ddd;font-size:10px;cursor:pointer;
    }
    .asset-actions button:hover{color:var(--gold);border-color:rgba(197,160,89,.55);background:rgba(255,255,255,.05);}

    /* CAMADAS */
    .layers-panel{
      position:fixed;top:230px;left:50%;transform:translateX(-50%);
      z-index:1200;min-width:360px;max-width:520px;
      background:var(--panel-bg);border:1px solid rgba(197,160,89,.2);
      border-radius:16px;padding:12px;backdrop-filter:blur(10px);
      box-shadow:0 10px 30px rgba(0,0,0,.45);
      display:none;
    }
    .layers-panel.show{display:block;}
    .layer-row{display:flex;align-items:center;justify-content:space-between;gap:10px;padding:8px 10px;border-radius:12px;background:rgba(255,255,255,.03);border:1px solid rgba(197,160,89,.12);margin-bottom:8px;}
    .layer-row b{color:var(--gold);}
    .layer-actions{display:flex;gap:8px;align-items:center;}
    .pill{
      font-size:10px;padding:5px 10px;border-radius:999px;border:1px solid rgba(197,160,89,.25);cursor:pointer;
      background:rgba(255,255,255,.03);color:#ddd;
    }
    .pill.active{color:var(--gold);border-color:rgba(197,160,89,.55);background:rgba(255,255,255,.05);}

    /* INSPECTOR (grande) */
    .inspector{
      position:fixed;
      right:20px;
      bottom:25px;
      z-index:1500;
      width:420px;
      background:var(--panel-bg);
      border:1px solid rgba(197,160,89,.22);
      border-radius:18px;
      backdrop-filter:blur(12px);
      box-shadow:0 12px 40px rgba(0,0,0,.55);
      padding:14px;
      display:none;
    }
    .inspector.show{display:block;}
    .inspector h4{
      font-family:'Cinzel',serif;
      color:var(--gold);
      font-size:14px;
      letter-spacing:1px;
      margin:0 0 10px 0;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .ins-row{
      display:flex;
      gap:10px;
      align-items:center;
      margin-bottom:10px;
    }
    .ins-row label{
      width:105px;
      font-size:11px;
      opacity:.85;
    }
    .ins-row input[type="number"], .ins-row select{
      flex:1;
      background:rgba(0,0,0,.35);
      border:1px solid rgba(197,160,89,.18);
      color:#fff;
      border-radius:12px;
      padding:8px 10px;
      font-size:12px;
      outline:none;
    }
    .ins-row input[type="range"]{
      flex:1;
    }
    .ins-actions{
      display:grid;
      grid-template-columns:repeat(3,1fr);
      gap:8px;
      margin-top:10px;
    }
    .ins-actions button{
      padding:10px 10px;
      border-radius:14px;
      border:1px solid rgba(197,160,89,.22);
      background:rgba(255,255,255,.03);
      color:#ddd;
      font-size:12px;
      cursor:pointer;
    }
    .ins-actions button:hover{
      color:var(--gold);
      border-color:rgba(197,160,89,.55);
      background:rgba(255,255,255,.05);
    }
    .ins-actions button.danger{
      border-color:rgba(239,68,68,.28);
      color:#ffb4b4;
    }
    .ins-actions button.danger:hover{
      color:#fff;
      border-color:rgba(239,68,68,.6);
      background:rgba(239,68,68,.12);
    }
    .muted{opacity:.75;font-size:10px;line-height:1.3;}
  </style>
</head>

<body>
  <div id="notification">OK</div>
  <div id="role-badge">Modo: <b id="role-text">...</b></div>

  <div class="btn-toggle-hud" onclick="toggleHUD()" title="Esconder/Mostrar Interface">üëÅÔ∏è</div>

  <div id="hud-root">
    <div class="controls-top hud-element">
      <button class="btn-luxury" id="btn-d20" onclick="rollDice(20)">D20</button>
      <button class="btn-luxury" id="btn-d6" onclick="rollDice(6)">D6</button>
      <button class="btn-luxury" onclick="toggleGrid()">Grelha</button>
      <button class="btn-luxury" id="btn-lock-all" onclick="unlockEverything()">üîì Destrancar</button>
      <button class="btn-luxury" id="btn-save-scene" onclick="openScenePanel()">üíæ Cena</button>
      <button class="btn-luxury" id="btn-library" onclick="toggleLibrary()">üì¶ Biblioteca</button>
      <button class="btn-luxury" id="btn-layers" onclick="toggleLayersPanel()">üß± Camadas</button>
      <button class="btn-luxury" onclick="toggleNetworkPanel()">üåê Rede</button>
    </div>

    <div class="lock-manager hud-element">
      <button class="btn-luxury bg-black/40 border-gold/20" id="btn-lock-map" onclick="toggleMapLock()">üîì Mapa M√≥vel</button>
    </div>

    <div class="network-status" id="network-panel">
      <div id="status-dot" class="status-dot"></div>
      <span id="status-text">Offline</span>
      <div class="h-4 w-px bg-white/20 mx-2"></div>
      <button class="btn-luxury py-0 px-2 text-[10px]" onclick="copyInviteLink()" id="btn-invite">üîó Copiar Convite</button>
    </div>

    <!-- Painel de Cenas -->
    <div class="network-status" id="scene-panel" style="top: 120px;">
      <span style="color: var(--gold); font-weight:700;">Cenas</span>
      <div class="h-4 w-px bg-white/20 mx-2"></div>

      <label class="btn-luxury py-0 px-2 text-[10px] cursor-pointer" style="display:flex;align-items:center;gap:6px;">
        <input type="checkbox" id="embed-remote" checked> Embutir URLs
      </label>

      <label class="btn-luxury py-0 px-2 text-[10px] cursor-pointer" style="display:flex;align-items:center;gap:6px;">
        <input type="checkbox" id="compress-images" checked> Comprimir
      </label>

      <select id="max-dim" class="url-field" style="margin:0; padding:6px; width:95px;">
        <option value="1024">1024px</option>
        <option value="1536">1536px</option>
        <option value="2048" selected>2048px</option>
        <option value="3072">3072px</option>
        <option value="4096">4096px</option>
      </select>

      <input id="quality" type="range" min="0.4" max="0.95" step="0.05" value="0.75" style="width:90px;">
      <span id="quality-label" style="font-size:10px;opacity:.8;">Q 0.75</span>

      <span id="scene-size" style="font-size:10px;opacity:.8; margin-left:6px;">~ -</span>

      <div class="h-4 w-px bg-white/20 mx-2"></div>

      <button class="btn-luxury py-0 px-2 text-[10px]" onclick="saveSceneToFile()">Salvar .JSON</button>
      <label class="btn-luxury py-0 px-2 text-[10px] cursor-pointer">
        Carregar .JSON
        <input type="file" id="scene-file" accept="application/json" style="display:none" onchange="loadSceneFromFile(event)">
      </label>
    </div>

    <!-- Biblioteca / Perfil -->
    <div class="library-panel" id="library-panel">
      <div style="display:flex; align-items:center; justify-content:space-between; gap:10px; margin-bottom:10px;">
        <div style="color: var(--gold); font-weight:700; font-family:'Cinzel',serif;">Biblioteca</div>
        <div style="display:flex; gap:8px;">
          <button class="btn-luxury py-0 px-2 text-[10px]" onclick="saveProfileToFile()">Salvar Perfil</button>
          <label class="btn-luxury py-0 px-2 text-[10px] cursor-pointer">
            Carregar Perfil
            <input type="file" id="profile-file" accept="application/json" style="display:none" onchange="loadProfileFromFile(event)">
          </label>
        </div>
      </div>

      <div class="library-tabs">
        <div class="library-tab active" id="tab-maps" onclick="setLibraryTab('maps')">Mapas</div>
        <div class="library-tab" id="tab-players" onclick="setLibraryTab('players')">Players</div>
        <div class="library-tab" id="tab-assets" onclick="setLibraryTab('assets')">Assets</div>
      </div>

      <input class="library-search" id="library-search" placeholder="Buscar..." oninput="renderLibrary()">
      <div class="library-grid" id="library-grid"></div>

      <div style="display:flex; justify-content:space-between; align-items:center; margin-top:10px; font-size:10px; opacity:.8;">
        <span id="library-count">0 itens</span>
        <button class="btn-luxury py-0 px-2 text-[10px]" onclick="clearLibrary()">Limpar Biblioteca</button>
      </div>
    </div>

    <!-- Camadas -->
    <div class="layers-panel" id="layers-panel">
      <div style="display:flex;align-items:center;justify-content:space-between;gap:10px;margin-bottom:10px;">
        <div style="color: var(--gold); font-weight:700; font-family:'Cinzel',serif;">Camadas (Layer 0 = Mapa)</div>
        <button class="btn-luxury py-0 px-2 text-[10px]" onclick="rebuildLayersPanel()">Atualizar</button>
      </div>
      <div id="layers-list"></div>
      <div style="font-size:10px;opacity:.75; margin-top:10px;">
        Dica: tokens t√™m ‚Äúlayer‚Äù e ‚Äúkind‚Äù (player/asset). Player s√≥ move o que est√° destravado e em camada vis√≠vel.
      </div>
    </div>

    <!-- INSPECTOR -->
    <div class="inspector" id="inspector">
      <h4>
        <span>Inspector</span>
        <button class="btn-luxury py-0 px-2 text-[10px]" onclick="closeInspector()">‚úï</button>
      </h4>

      <div class="muted" id="inspector-sub"></div>

      <div class="ins-row">
        <label>Layer</label>
        <input type="number" id="ins-layer" min="1" max="50">
      </div>

      <div class="ins-row">
        <label>Posi√ß√£o X</label>
        <input type="number" id="ins-x">
      </div>
      <div class="ins-row">
        <label>Posi√ß√£o Y</label>
        <input type="number" id="ins-y">
      </div>

      <div class="ins-row">
        <label>Largura</label>
        <input type="number" id="ins-w" min="40" max="2500">
      </div>
      <div class="ins-row">
        <label>Altura</label>
        <input type="number" id="ins-h" min="40" max="2500">
      </div>

      <div class="ins-row">
        <label>Rota√ß√£o</label>
        <input type="number" id="ins-rot" min="0" max="359">
      </div>

      <div class="ins-row">
        <label>Zoom Interno</label>
        <input type="range" id="ins-zoom" min="0.2" max="5" step="0.05">
      </div>

      <div class="ins-row">
        <label>Fit</label>
        <select id="ins-fit">
          <option value="contain">Contain</option>
          <option value="cover">Cover</option>
        </select>
      </div>

      <div style="height:1px;background:rgba(197,160,89,.18);margin:10px 0;"></div>

      <div class="ins-row">
        <label>Fog: Vis√£o</label>
        <select id="ins-vision">
          <option value="off">OFF</option>
          <option value="on">ON</option>
        </select>
      </div>

      <div class="ins-row">
        <label>Raio Fog</label>
        <input type="number" id="ins-fog" min="0" max="5000" step="10">
      </div>

      <div class="muted">
        Player ver√° tokens (exceto mapa) apenas dentro do(s) c√≠rculo(s) de vis√£o.  
        Se nenhum token estiver com Vis√£o=ON e Raio>0, o player ver√° s√≥ o mapa.
      </div>

      <div class="ins-actions">
        <button onclick="insRotate(-45)">‚ü≤ -45¬∞</button>
        <button onclick="insFlip()">‚Üî Flip</button>
        <button onclick="insRotate(45)">‚ü≥ +45¬∞</button>

        <button onclick="insLock(true)">üîí Lock</button>
        <button onclick="insLock(false)">üîì Unlock</button>
        <button class="danger" onclick="insDelete()">üóëÔ∏è Delete</button>
      </div>
    </div>

    <div class="sidebar hud-element" id="sidebar">
      <div class="toggle-sidebar-btn" onclick="toggleSidebar()">‚ò∞</div>
      <div class="p-6 overflow-y-auto h-full">
        <h2 class="text-xl font-bold mb-6 border-b border-gold/30 pb-3">Atelier P2P</h2>

        <!-- MAPA (Host) -->
        <div class="mb-8" id="host-only-map">
          <h3 class="text-xs font-semibold uppercase mb-4 opacity-70">Mapa (Layer 0)</h3>
          <div class="bg-black/40 p-4 border border-dashed border-gold/30 rounded-xl">
            <input type="file" id="map-file" accept="image/*" class="hidden" onchange="importAsset(event, 'map')">
            <label for="map-file" class="btn-luxury block text-center mb-3 cursor-pointer bg-white/5">Ficheiro Local</label>
            <input type="text" id="map-url" class="url-field" placeholder="https://link-do-mapa.jpg">
            <button class="btn-luxury w-full border border-gold/30" onclick="importFromUrl('map-url', 'map')">Definir Mapa</button>
          </div>
          <p class="text-[10px] opacity-50 mt-3 leading-relaxed italic">
            Mapa arrast√°vel com in√©rcia. Trave para evitar mover.
          </p>
        </div>

        <!-- PLAYERS (Host) -->
        <div class="mb-8" id="host-only-players">
          <h3 class="text-xs font-semibold uppercase mb-4 opacity-70">Players (tokens)</h3>
          <div class="bg-black/40 p-4 border border-dashed border-gold/30 rounded-xl">
            <input type="file" id="player-file" accept="image/*" class="hidden" onchange="importAsset(event, 'player')">
            <label for="player-file" class="btn-luxury block text-center mb-3 cursor-pointer bg-white/5">Ficheiro Local</label>
            <input type="text" id="player-url" class="url-field" placeholder="URL Imagem...">
            <button class="btn-luxury w-full border border-gold/30" onclick="importFromUrl('player-url', 'player')">Adicionar Player</button>
          </div>
          <p class="text-[10px] opacity-50 mt-3 leading-relaxed italic">
            Players entram por padr√£o em layer 3.
          </p>
        </div>

        <!-- ASSETS (Host) -->
        <div class="mb-8" id="host-only-assets">
          <h3 class="text-xs font-semibold uppercase mb-4 opacity-70">Assets (tudo que n√£o √© player nem mapa)</h3>
          <div class="bg-black/40 p-4 border border-dashed border-gold/30 rounded-xl">
            <input type="file" id="asset-file" accept="image/*" class="hidden" onchange="importAsset(event, 'asset')">
            <label for="asset-file" class="btn-luxury block text-center mb-3 cursor-pointer bg-white/5">Ficheiro Local</label>
            <input type="text" id="asset-url" class="url-field" placeholder="URL Imagem...">
            <button class="btn-luxury w-full border border-gold/30" onclick="importFromUrl('asset-url', 'asset')">Adicionar Asset</button>
          </div>
          <p class="text-[10px] opacity-50 mt-3 leading-relaxed italic">
            Assets entram por padr√£o em layer 2.
          </p>
        </div>

        <div class="mt-auto pt-6 border-t border-gold/20" id="host-only-clear">
          <button class="btn-luxury w-full text-red-500 border-red-900/30 hover:bg-red-900/20" onclick="clearTable()">Limpar Mesa</button>
        </div>

        <div class="mt-6 text-[10px] opacity-50 leading-relaxed">
          <div><b>Status:</b> <span id="tiny-status">iniciando...</span></div>
          <div><b>Sala:</b> <span id="tiny-room">-</span></div>
        </div>
      </div>
    </div>

    <div class="dice-log hud-element" id="dice-log">
      <div id="dice-entries">
        <div class="text-[11px] opacity-40 mb-3 uppercase tracking-tighter">Hist√≥rico</div>
      </div>
    </div>
  </div>

  <div id="viewport">
    <div id="canvas-container">
      <div id="map-container" class="map-layer"></div>
      <div id="grid-layer" class="grid-layer"></div>
      <canvas id="fog-layer"></canvas>
    </div>
  </div>

  <script>
    /********************************************************************
     * ‚úÖ ADI√á√ïES NESTA VERS√ÉO
     * - FO G por elemento (token): visionEnabled + fogRadius
     * - Player: tudo fora do fog (exceto mapa) fica invis√≠vel
     * - Inspector grande (removeu token-controls)
     * - Saves/Cenas incluem fog
     ********************************************************************/

    // ===== UTIL =====
    const generateUUID = () => Date.now().toString(36) + Math.random().toString(36).slice(2);

    function showNotification(msg){
      const n=document.getElementById('notification');
      n.innerText=msg;
      n.classList.add('active');
      setTimeout(()=>n.classList.remove('active'),2000);
    }

    // ===== ELEMENTOS =====
    const canvas = document.getElementById('canvas-container');
    const viewport = document.getElementById('viewport');
    const mapContainer = document.getElementById('map-container');
    const gridLayer = document.getElementById('grid-layer');
    const fogCanvas = document.getElementById('fog-layer');
    const fogCtx = fogCanvas.getContext('2d');
    const sidebar = document.getElementById('sidebar');
    const diceLogEntries = document.getElementById('dice-entries');

    const statusDot = document.getElementById('status-dot');
    const statusText = document.getElementById('status-text');
    const networkPanel = document.getElementById('network-panel');
    const scenePanel = document.getElementById('scene-panel');

    const roleText = document.getElementById('role-text');
    const tinyStatus = document.getElementById('tiny-status');
    const tinyRoom = document.getElementById('tiny-room');

    const hostOnlyMap = document.getElementById('host-only-map');
    const hostOnlyPlayers = document.getElementById('host-only-players');
    const hostOnlyAssets = document.getElementById('host-only-assets');
    const hostOnlyClear = document.getElementById('host-only-clear');

    const btnLockAll = document.getElementById('btn-lock-all');
    const btnLockMap = document.getElementById('btn-lock-map');
    const btnInvite = document.getElementById('btn-invite');
    const btnD20 = document.getElementById('btn-d20');
    const btnD6 = document.getElementById('btn-d6');
    const btnSaveScene = document.getElementById('btn-save-scene');
    const btnLibrary = document.getElementById('btn-library');
    const btnLayers = document.getElementById('btn-layers');

    // Inspector
    const inspector = document.getElementById('inspector');
    const inspectorSub = document.getElementById('inspector-sub');
    const insLayer = document.getElementById('ins-layer');
    const insX = document.getElementById('ins-x');
    const insY = document.getElementById('ins-y');
    const insW = document.getElementById('ins-w');
    const insH = document.getElementById('ins-h');
    const insRot = document.getElementById('ins-rot');
    const insZoom = document.getElementById('ins-zoom');
    const insFit = document.getElementById('ins-fit');
    const insVision = document.getElementById('ins-vision');
    const insFog = document.getElementById('ins-fog');

    // Biblioteca
    const libraryPanel = document.getElementById('library-panel');
    const libraryGrid = document.getElementById('library-grid');
    const librarySearch = document.getElementById('library-search');
    const libraryCount = document.getElementById('library-count');
    let libraryTab = "maps";
    const library = { maps: [], players: [], assets: [] };

    // Camadas
    const layersPanel = document.getElementById('layers-panel');
    const layersList = document.getElementById('layers-list');

    // ===== CAMERA =====
    let scale = 1;
    let posX = window.innerWidth/2 - 5000;
    let posY = window.innerHeight/2 - 5000;
    let isPanning = false;
    let startPan = {x:0,y:0};

    function updateTransform(){
      canvas.style.transform = `translate(${posX}px, ${posY}px) scale(${scale})`;
    }
    updateTransform();

    // ===== SELE√á√ÉO =====
    let selectedToken = null;

    // ===== REDE =====
    let peer, connections = [], hostConnection = null;
    let myId = null;
    let isHost = false;

    const PEER_ICE_CONFIG = {
      iceServers: [
        { urls: "stun:stun.l.google.com:19302" },
        { urls: "stun:stun1.l.google.com:19302" },
        { urls: "stun:global.stun.twilio.com:3478" }
      ]
    };

    // ===== SISTEMA DE CAMADAS =====
    const layerState = { visible: {}, locked: {} };

    function ensureLayerDefaults(layer){
      if (layer == null) return;
      if (!(layer in layerState.visible)) layerState.visible[layer] = true;
      if (!(layer in layerState.locked)) layerState.locked[layer] = false;
    }

    function computeTokenZIndex(layer){
      const base = 100;
      const l = Number(layer || 1);
      return base + (l * 10);
    }

    function applyLayerVisibilityToDOM(){
      document.querySelectorAll('.token').forEach(t=>{
        const layer = Number(t.dataset.layer || 1);
        ensureLayerDefaults(layer);
        const vis = !!layerState.visible[layer];
        t.style.display = vis ? "" : "none";
      });
      // Player tamb√©m passa por fog
      if (!isHost) updateFogAndVisibility();
    }

    function toggleLayersPanel(){
      if (!isHost) return alert("Apenas o Host gerencia camadas.");
      layersPanel.classList.toggle('show');
      rebuildLayersPanel();
    }

    function rebuildLayersPanel(){
      if (!isHost) return;

      const layers = new Set();
      Object.values(state.tokens).forEach(t => layers.add(Number(t.layer || 1)));
      const maxLayer = layers.size ? Math.max(...Array.from(layers)) : 3;

      layersList.innerHTML = "";

      for (let l=1; l<=Math.max(maxLayer,3); l++){
        ensureLayerDefaults(l);

        const row = document.createElement('div');
        row.className = "layer-row";

        const left = document.createElement('div');
        left.innerHTML = `<b>Layer ${l}</b> <span style="font-size:10px;opacity:.7;">(tokens)</span>`;

        const actions = document.createElement('div');
        actions.className = "layer-actions";

        const vis = document.createElement('div');
        vis.className = "pill " + (layerState.visible[l] ? "active" : "");
        vis.innerText = layerState.visible[l] ? "Vis√≠vel" : "Oculta";
        vis.onclick = () => {
          layerState.visible[l] = !layerState.visible[l];
          const action = { type:"LAYER_SET", layer:l, prop:"visible", value: layerState.visible[l] };
          applyAction(action,false);
          broadcastACT(action);
          rebuildLayersPanel();
          applyLayerVisibilityToDOM();
        };

        const lock = document.createElement('div');
        lock.className = "pill " + (layerState.locked[l] ? "active" : "");
        lock.innerText = layerState.locked[l] ? "Trancada" : "Livre";
        lock.onclick = () => {
          layerState.locked[l] = !layerState.locked[l];
          const action = { type:"LAYER_SET", layer:l, prop:"locked", value: layerState.locked[l] };
          applyAction(action,false);
          broadcastACT(action);
          rebuildLayersPanel();
        };

        actions.appendChild(vis);
        actions.appendChild(lock);

        row.appendChild(left);
        row.appendChild(actions);
        layersList.appendChild(row);
      }
    }

    // ===== ESTADO (Host autoritativo) =====
    const state = {
      map: { src:null, locked:false, x:0, y:0 },
      tokens: {}
    };

    // ===== UI =====
    function toggleHUD(){ document.body.classList.toggle('hud-hidden'); }
    function toggleSidebar(){ sidebar.classList.toggle('open'); }
    function toggleGrid(){ gridLayer.style.display = (gridLayer.style.display === 'none') ? 'block' : 'none'; }
    function toggleNetworkPanel(){ networkPanel.classList.toggle('show'); }

    function setRoleUI(){
      roleText.textContent = isHost ? "HOST (Mestre)" : "PLAYER";

      hostOnlyMap.style.display = isHost ? "" : "none";
      hostOnlyPlayers.style.display = isHost ? "" : "none";
      hostOnlyAssets.style.display = isHost ? "" : "none";
      hostOnlyClear.style.display = isHost ? "" : "none";

      btnLockAll.style.display = isHost ? "" : "none";
      btnLockMap.style.display = isHost ? "" : "none";
      btnInvite.style.display = isHost ? "" : "none";
      btnD20.style.display = isHost ? "" : "none";
      btnD6.style.display = isHost ? "" : "none";
      btnSaveScene.style.display = isHost ? "" : "none";
      btnLibrary.style.display = isHost ? "" : "none";
      btnLayers.style.display = isHost ? "" : "none";
      scenePanel.style.display = isHost ? "" : "none";
      layersPanel.style.display = isHost ? "" : "none";
      libraryPanel.style.display = isHost ? "" : "none";

      // Fog canvas s√≥ pra player
      fogCanvas.style.display = isHost ? "none" : "block";
      if (!isHost) updateFogAndVisibility();
    }

    // ===== Convite =====
    function copyInviteLink(){
      if (!myId) return alert("Aguarde a conex√£o...");
      if (!isHost) return alert("Apenas o Host copia convite.");
      const u = new URL(window.location.href);
      u.searchParams.set('room', myId);
      const invite = u.toString();

      if (navigator.clipboard?.writeText){
        navigator.clipboard.writeText(invite).then(()=>showNotification("Link copiado!")).catch(()=>prompt("Copie:", invite));
      } else prompt("Copie:", invite);
    }

    // ===== PAN/ZOOM viewport =====
    viewport.addEventListener('wheel',(e)=>{
      if (e.ctrlKey) return;
      e.preventDefault();
      const zoomSpeed=.15;
      const delta = e.deltaY>0 ? -zoomSpeed : zoomSpeed;
      const newScale = Math.min(Math.max(.05, scale+delta), 4);

      const mx=e.clientX,my=e.clientY;
      const cx=(mx-posX)/scale, cy=(my-posY)/scale;

      scale = newScale;
      posX = mx - cx*scale;
      posY = my - cy*scale;
      updateTransform();
    },{passive:false});

    window.addEventListener('mousedown',(e)=>{
      if (e.button===2 || e.button===1 || (e.button===0 && e.altKey)){
        isPanning=true;
        startPan={x:e.clientX-posX,y:e.clientY-posY};
        viewport.style.cursor='grabbing';
      }
    });
    window.addEventListener('mousemove',(e)=>{
      if (isPanning){
        posX=e.clientX-startPan.x;
        posY=e.clientY-startPan.y;
        updateTransform();
      }
    });
    window.addEventListener('mouseup',()=>{ isPanning=false; viewport.style.cursor='grab'; });

    // ===== MAPA ‚ÄúPALP√ÅVEL‚Äù COM IN√âRCIA =====
    let mapDragging=false;
    let mapDragStart={mx:0,my:0,x:0,y:0};
    let mapVel={vx:0,vy:0};
    let mapLastMove={t:0,x:0,y:0};
    let mapInertiaRAF=null;

    function setMapLockLocal(lock, emit){
      state.map.locked = !!lock;
      if (state.map.locked) mapContainer.classList.add('locked');
      else mapContainer.classList.remove('locked');

      if (state.map.locked) {
        btnLockMap.innerHTML="üîí Mapa Fixo"; btnLockMap.classList.add('active');
      } else {
        btnLockMap.innerHTML="üîì Mapa M√≥vel"; btnLockMap.classList.remove('active');
      }

      if (emit){
        if (!isHost) return;
        const action = { type:"MAP_LOCK", locked: state.map.locked };
        applyAction(action,false);
        broadcastACT(action);
      }
    }

    function toggleMapLock(){
      if (!isHost) return;
      setMapLockLocal(!state.map.locked, true);
    }

    function setMapOffset(x, y){
      state.map.x = x;
      state.map.y = y;
      mapContainer.style.transform = `translate(${x}px, ${y}px)`;
    }

    function stopMapInertia(){
      if (mapInertiaRAF) cancelAnimationFrame(mapInertiaRAF);
      mapInertiaRAF = null;
    }

    function startMapInertia(){
      stopMapInertia();
      const friction = 0.92;
      const minV = 0.05;

      const step = () => {
        mapVel.vx *= friction;
        mapVel.vy *= friction;

        if (Math.abs(mapVel.vx) < minV && Math.abs(mapVel.vy) < minV) {
          mapVel.vx = 0; mapVel.vy = 0;
          stopMapInertia();

          if (isHost){
            const action = { type:"MAP_MOVE", x: state.map.x, y: state.map.y };
            applyAction(action,false);
            broadcastACT(action);
          }
          return;
        }

        setMapOffset(state.map.x + mapVel.vx, state.map.y + mapVel.vy);

        mapInertiaRAF = requestAnimationFrame(step);
      };

      mapInertiaRAF = requestAnimationFrame(step);
    }

    function setupMapDrag(){
      mapContainer.addEventListener('mousedown', (e)=>{
        if (!isHost) return;
        if (state.map.locked) return;
        const img = mapContainer.querySelector('img');
        if (!img) return;

        if (e.button !== 0 || e.altKey) return;
        e.preventDefault();
        e.stopPropagation();

        mapDragging = true;
        mapContainer.classList.add('dragging');
        stopMapInertia();

        mapDragStart = { mx:e.clientX, my:e.clientY, x:state.map.x, y:state.map.y };
        mapVel = { vx:0, vy:0 };
        mapLastMove = { t: performance.now(), x: state.map.x, y: state.map.y };

        const onMove = (me) => {
          if (!mapDragging) return;

          const dx = (me.clientX - mapDragStart.mx) / scale;
          const dy = (me.clientY - mapDragStart.my) / scale;

          const nx = mapDragStart.x + dx;
          const ny = mapDragStart.y + dy;
          setMapOffset(nx, ny);

          const now = performance.now();
          const dt = Math.max(1, now - mapLastMove.t);
          mapVel.vx = (nx - mapLastMove.x) / dt * 16;
          mapVel.vy = (ny - mapLastMove.y) / dt * 16;
          mapLastMove = { t: now, x: nx, y: ny };
        };

        const onUp = () => {
          mapDragging = false;
          mapContainer.classList.remove('dragging');
          document.removeEventListener('mousemove', onMove);
          document.removeEventListener('mouseup', onUp);

          startMapInertia();

          const action = { type:"MAP_MOVE", x: state.map.x, y: state.map.y };
          applyAction(action,false);
          broadcastACT(action);
        };

        document.addEventListener('mousemove', onMove);
        document.addEventListener('mouseup', onUp);
      });
    }
    setupMapDrag();

    function applyMapLocal(src, emit){
      const img = new Image();
      img.onload = () => {
        mapContainer.innerHTML = "";
        mapContainer.appendChild(img);

        scale = Math.min(window.innerWidth / img.width, window.innerHeight / img.height, 1) * 0.8;
        posX = window.innerWidth/2 - (img.width * scale)/2;
        posY = window.innerHeight/2 - (img.height * scale)/2;
        updateTransform();

        setMapOffset(state.map.x || 0, state.map.y || 0);
      };
      img.src = src;

      if (emit){
        if (!isHost) return;
        const action = { type:"MAP_UPDATE", src };
        applyAction(action,false);
        broadcastACT(action);
      }
    }

    // ===== TOKENS =====
    function normalizeTokenProps(id, src, type, props){
      const p = props || {};
      const layer = Number(p.layer ?? 2);
      ensureLayerDefaults(layer);
      return {
        id,
        src,
        type,
        kind: p.kind ?? "asset",
        layer,
        x: p.x ?? "0px",
        y: p.y ?? "0px",
        w: p.w ?? 140,
        h: p.h ?? 140,
        rotation: p.rotation ?? 0,
        flipped: p.flipped ?? "false",
        innerZoom: p.innerZoom ?? 1,
        locked: p.locked ?? "false",
        fitMode: p.fitMode ?? "contain",

        // FOG por token:
        vision: p.vision ?? "off",     // "on" | "off"
        fogRadius: Number(p.fogRadius ?? 0)
      };
    }

    function hostCreateToken(src, contentType, kind){
      if (!isHost) return;

      const id = generateUUID();
      const isImg = contentType === "image";
      let width = isImg ? 160 : 400;
      let height = isImg ? 160 : 225;

      const layerDefault = (kind === "player") ? 3 : 2;

      const centerX = (window.innerWidth/2 - posX)/scale;
      const centerY = (window.innerHeight/2 - posY)/scale;

      const props = {
        kind,
        layer: layerDefault,
        x: (centerX - width/2) + "px",
        y: (centerY - height/2) + "px",
        w: width,
        h: height,
        rotation: 0,
        flipped: "false",
        innerZoom: 1,
        locked: "false",
        fitMode: "contain",

        vision: "off",
        fogRadius: 0
      };

      const action = { type:"CREATE_TOKEN", id, src, contentType, props };
      applyAction(action,false);
      broadcastACT(action);

      rebuildLayersPanel();
      applyLayerVisibilityToDOM();
      updateSceneSizeEstimate();
    }

    function addTokenLocal(src, contentType, id, props){
      if (document.getElementById(`token-${id}`)) return;

      const token = document.createElement('div');
      token.id = `token-${id}`;
      token.className = "token";
      token.dataset.uuid = id;
      token.dataset.type = contentType;

      const layer = Number(props?.layer ?? 2);
      const kind = props?.kind ?? "asset";
      ensureLayerDefaults(layer);

      token.dataset.layer = String(layer);
      token.dataset.kind = kind;

      token.style.zIndex = String(computeTokenZIndex(layer));

      const width = props?.w ? parseInt(props.w) : (contentType==="web"?400:160);
      const height = props?.h ? parseInt(props.h) : (contentType==="web"?225:160);
      token.style.width = width + "px";
      token.style.height = height + "px";

      const x = props?.x ?? "0px";
      const y = props?.y ?? "0px";
      token.style.left = x;
      token.style.top = y;

      token.dataset.sizeW = width;
      token.dataset.sizeH = height;
      token.dataset.rotation = props?.rotation ?? 0;
      token.dataset.flipped = props?.flipped ?? "false";
      token.dataset.innerZoom = props?.innerZoom ?? 1;
      token.dataset.locked = props?.locked ?? "false";
      token.dataset.fitMode = props?.fitMode ?? "contain";

      // fog props
      token.dataset.vision = props?.vision ?? "off";
      token.dataset.fogRadius = String(Number(props?.fogRadius ?? 0));

      if (token.dataset.locked === "true"){
        token.classList.add('locked');
        token.style.pointerEvents = "none";
      }

      const blocker = document.createElement('div');
      blocker.className = "token-blocker";

      const wrapper = document.createElement('div');
      wrapper.className = "token-content-wrapper";

      let content;
      if (contentType === "image"){
        content = document.createElement('img');
        content.src = src;
      } else {
        content = document.createElement('iframe');
        content.src = src;
        content.setAttribute('frameborder','0');
        content.setAttribute('sandbox','allow-scripts allow-same-origin');
      }

      const handle = document.createElement('div');
      handle.className = "resize-handle";

      wrapper.appendChild(content);
      token.appendChild(blocker);
      token.appendChild(wrapper);
      token.appendChild(handle);
      canvas.appendChild(token);

      setTimeout(()=>updateImgTransform(token),10);

      // layer visibility
      const vis = !!layerState.visible[layer];
      token.style.display = vis ? "" : "none";

      // resize handle (Host only)
      handle.addEventListener('mousedown',(e)=>{
        if (!isHost) return;
        if (token.dataset.locked === "true") return;
        if (layerState.locked[Number(token.dataset.layer||2)]) return;
        if (e.button!==0) return;

        e.stopPropagation(); e.preventDefault();
        const startX=e.clientX;
        const startW=parseInt(token.dataset.sizeW);
        const startH=parseInt(token.dataset.sizeH);
        const ratio=startH/startW;

        let pendingW=startW, pendingH=startH;

        function onMove(me){
          const deltaW=((me.clientX-startX)/scale)*1.5;
          let w=Math.max(40, Math.min(startW+deltaW, 2500));
          let h=Math.max(40, Math.min(w*ratio, 2500));
          pendingW=Math.round(w); pendingH=Math.round(h);
          token.dataset.sizeW=pendingW; token.dataset.sizeH=pendingH;
          token.style.width=pendingW+"px"; token.style.height=pendingH+"px";
        }
        function onUp(){
          document.removeEventListener('mousemove',onMove);
          document.removeEventListener('mouseup',onUp);
          const action={ type:"UPDATE_PROP", id:token.dataset.uuid, prop:"size", value:{w:pendingW,h:pendingH} };
          applyAction(action,false); broadcastACT(action);
          updateSceneSizeEstimate();
        }
        document.addEventListener('mousemove',onMove);
        document.addEventListener('mouseup',onUp);
      });

      // drag token
      token.addEventListener('mousedown',(e)=>{
        if (e.button!==0 || e.altKey) return;
        if (token.dataset.locked==="true") return;
        if (layerState.locked[Number(token.dataset.layer||2)]) return;
        e.stopPropagation();
        selectToken(token);
        startDraggingToken(e, token);
      });
    }

    function updateImgTransform(token){
      const el = token.querySelector('img') || token.querySelector('iframe');
      if (!el) return;

      if (el.tagName === "IMG"){
        el.style.objectFit = token.dataset.fitMode || "contain";
      }
      const rotation = token.dataset.rotation || 0;
      const flipped = token.dataset.flipped === "true";
      const innerZoom = token.dataset.innerZoom || 1;
      el.style.transform = `scale(${innerZoom}) rotate(${rotation}deg) scaleX(${flipped?-1:1})`;
    }

    function selectToken(token){
      if (selectedToken) selectedToken.classList.remove('selected');
      selectedToken = token;
      selectedToken.classList.add('selected');
      openInspectorFor(token);
    }

    function startDraggingToken(e, token){
      let startX=e.clientX, startY=e.clientY;
      let initialLeft=parseFloat(token.style.left);
      let initialTop=parseFloat(token.style.top);
      let moved=false;

      function onMove(me){
        moved=true;
        let dx=(me.clientX-startX)/scale;
        let dy=(me.clientY-startY)/scale;
        let newX=initialLeft+dx;
        let newY=initialTop+dy;
        if (gridLayer.style.display !== 'none'){
          newX=Math.round(newX/50)*50;
          newY=Math.round(newY/50)*50;
        }
        token.style.left=newX+"px";
        token.style.top=newY+"px";
        // inspector acompanha
        if (selectedToken && selectedToken.dataset.uuid===token.dataset.uuid) {
          insX.value = Math.round(newX);
          insY.value = Math.round(newY);
        }
      }

      function onUp(){
        document.removeEventListener('mousemove',onMove);
        document.removeEventListener('mouseup',onUp);
        if (!moved) return;

        const id=token.dataset.uuid;
        const action={ type:"MOVE", id, x:token.style.left, y:token.style.top };

        if (isHost){ applyAction(action,false); broadcastACT(action); }
        else sendREQ(action);

        updateSceneSizeEstimate();
      }

      document.addEventListener('mousemove',onMove);
      document.addEventListener('mouseup',onUp);
    }

    function moveTokenDOM(id,x,y){
      const t=document.getElementById(`token-${id}`);
      if (!t) return;
      t.style.left=x; t.style.top=y;
    }

    function updateTokenPropDOM(id, prop, value){
      const token=document.getElementById(`token-${id}`);
      if (!token) return;

      if (prop==="locked"){
        token.dataset.locked = String(value);
        if (String(value)==="true"){
          token.classList.add('locked');
          token.style.pointerEvents="none";
          token.classList.remove('selected');
          if (selectedToken && selectedToken.dataset.uuid===id) selectedToken=null;
        } else {
          token.classList.remove('locked');
          token.style.pointerEvents="auto";
        }
      } else if (prop==="innerZoom"){
        token.dataset.innerZoom=value; updateImgTransform(token);
      } else if (prop==="rotation"){
        token.dataset.rotation=value; updateImgTransform(token);
      } else if (prop==="flipped"){
        token.dataset.flipped=value; updateImgTransform(token);
      } else if (prop==="fitMode"){
        token.dataset.fitMode=value; updateImgTransform(token);
      } else if (prop==="size"){
        token.style.width=value.w+"px";
        token.style.height=value.h+"px";
        token.dataset.sizeW=value.w;
        token.dataset.sizeH=value.h;
      } else if (prop==="layer"){
        const newLayer = Number(value);
        ensureLayerDefaults(newLayer);
        token.dataset.layer = String(newLayer);
        token.style.zIndex = String(computeTokenZIndex(newLayer));
        const vis = !!layerState.visible[newLayer];
        token.style.display = vis ? "" : "none";
      } else if (prop==="vision"){
        token.dataset.vision = String(value);
      } else if (prop==="fogRadius"){
        token.dataset.fogRadius = String(Number(value||0));
      }

      // player aplica fog
      if (!isHost) updateFogAndVisibility();

      // inspector atualiza se for o selecionado
      if (selectedToken && selectedToken.dataset.uuid === id){
        openInspectorFor(selectedToken, true);
      }

      updateSceneSizeEstimate();
    }

    function removeTokenLocal(id){
      const t=document.getElementById(`token-${id}`);
      if (t) t.remove();
      if (selectedToken && selectedToken.dataset.uuid===id){
        selectedToken=null;
        closeInspector();
      }
      if (!isHost) updateFogAndVisibility();
    }

    // ===== INSPECTOR =====
    function closeInspector(){
      inspector.classList.remove('show');
    }

    function openInspectorFor(token, silent=false){
      if (!token) return;
      inspector.classList.add('show');

      const id = token.dataset.uuid;
      const kind = token.dataset.kind || "asset";
      const layer = Number(token.dataset.layer||2);

      inspectorSub.innerHTML = `
        <div><b style="color:var(--gold)">ID:</b> ${id}</div>
        <div><b style="color:var(--gold)">Tipo:</b> ${kind} &nbsp;|&nbsp; <b style="color:var(--gold)">Layer:</b> ${layer}</div>
        <div class="muted">Host edita tudo. Player s√≥ pode mover tokens destravados.</div>
      `;

      const canEdit = isHost;
      const canMoveOnly = !isHost;

      // valores
      insLayer.value = layer;
      insX.value = Math.round(parseFloat(token.style.left)||0);
      insY.value = Math.round(parseFloat(token.style.top)||0);
      insW.value = Math.round(parseFloat(token.style.width)||0);
      insH.value = Math.round(parseFloat(token.style.height)||0);
      insRot.value = Number(token.dataset.rotation||0);
      insZoom.value = Number(token.dataset.innerZoom||1);
      insFit.value = token.dataset.fitMode || "contain";
      insVision.value = (token.dataset.vision||"off");
      insFog.value = Number(token.dataset.fogRadius||0);

      // habilita/desabilita
      insLayer.disabled = !canEdit;
      insW.disabled = !canEdit;
      insH.disabled = !canEdit;
      insRot.disabled = !canEdit;
      insZoom.disabled = !canEdit;
      insFit.disabled = !canEdit;
      insVision.disabled = !canEdit;
      insFog.disabled = !canEdit;

      // Player pode mexer X/Y s√≥ por ‚Äúvisualiza√ß√£o‚Äù (drag manda pro host).
      insX.disabled = true;
      insY.disabled = true;

      if (!silent) {
        // nada
      }
    }

    function applyInspectorToToken(){
      if (!selectedToken) return;
      if (!isHost) return;

      const id = selectedToken.dataset.uuid;

      // layer
      const layer = Math.max(1, Math.min(50, Number(insLayer.value||2)));
      const w = Math.max(40, Math.min(2500, Number(insW.value||160)));
      const h = Math.max(40, Math.min(2500, Number(insH.value||160)));
      const rot = ((Number(insRot.value||0)%360)+360)%360;
      const zoom = Math.max(0.2, Math.min(5, Number(insZoom.value||1)));
      const fit = String(insFit.value||"contain");
      const vision = String(insVision.value||"off");
      const fogRadius = Math.max(0, Math.min(5000, Number(insFog.value||0)));

      const actions = [
        { type:"UPDATE_PROP", id, prop:"layer", value: layer },
        { type:"UPDATE_PROP", id, prop:"size", value: { w, h } },
        { type:"UPDATE_PROP", id, prop:"rotation", value: rot },
        { type:"UPDATE_PROP", id, prop:"innerZoom", value: zoom },
        { type:"UPDATE_PROP", id, prop:"fitMode", value: fit },
        { type:"UPDATE_PROP", id, prop:"vision", value: vision },
        { type:"UPDATE_PROP", id, prop:"fogRadius", value: fogRadius },
      ];

      actions.forEach(a=>{ applyAction(a,false); broadcastACT(a); });

      rebuildLayersPanel();
      applyLayerVisibilityToDOM();
      updateFogAndVisibility();
    }

    // hooks inspector (host)
    [insLayer, insW, insH, insRot, insZoom, insFit, insVision, insFog].forEach(el=>{
      el.addEventListener('change', ()=>applyInspectorToToken());
      el.addEventListener('input', ()=>{
        if (el === insZoom) applyInspectorToToken();
      });
    });

    function insRotate(deg){
      if (!selectedToken || !isHost) return;
      const id = selectedToken.dataset.uuid;
      const newVal = (Number(selectedToken.dataset.rotation||0) + deg + 360) % 360;
      const a={ type:"UPDATE_PROP", id, prop:"rotation", value:newVal };
      applyAction(a,false); broadcastACT(a);
    }
    function insFlip(){
      if (!selectedToken || !isHost) return;
      const id = selectedToken.dataset.uuid;
      const newVal = (selectedToken.dataset.flipped==="true") ? "false" : "true";
      const a={ type:"UPDATE_PROP", id, prop:"flipped", value:newVal };
      applyAction(a,false); broadcastACT(a);
    }
    function insLock(v){
      if (!selectedToken || !isHost) return;
      const id = selectedToken.dataset.uuid;
      const a={ type:"UPDATE_PROP", id, prop:"locked", value: String(!!v) };
      applyAction(a,false); broadcastACT(a);
    }
    function insDelete(){
      if (!selectedToken || !isHost) return;
      const id = selectedToken.dataset.uuid;
      const a={ type:"REMOVE_TOKEN", id };
      applyAction(a,false); broadcastACT(a);
      closeInspector();
    }

    // ===== FOG (Player Only) =====
    function resizeFogCanvas(){
      fogCanvas.width = 10000;
      fogCanvas.height = 10000;
    }
    resizeFogCanvas();

    function tokenCenterCanvas(t){
      const x = (parseFloat(t.style.left)||0) + (parseFloat(t.style.width)||0)/2;
      const y = (parseFloat(t.style.top)||0) + (parseFloat(t.style.height)||0)/2;
      return {x,y};
    }

    function getVisionSources(){
      const sources = [];
      for (const id of Object.keys(state.tokens)){
        const tok = state.tokens[id];
        if (!tok) continue;
        const vision = String(tok.vision||"off");
        const r = Number(tok.fogRadius||0);
        if (vision === "on" && r > 0){
          sources.push({ id, x: (parseFloat(tok.x)||0) + (Number(tok.w)||0)/2, y: (parseFloat(tok.y)||0) + (Number(tok.h)||0)/2, r });
        }
      }
      return sources;
    }

    // desenha overlay e decide visibilidade dos tokens para player
    function updateFogAndVisibility(){
      if (isHost) return;

      // aplica layer hidden primeiro
      document.querySelectorAll('.token').forEach(t=>{
        const layer = Number(t.dataset.layer||2);
        ensureLayerDefaults(layer);
        const vis = !!layerState.visible[layer];
        t.style.display = vis ? "" : "none";
      });

      const sources = getVisionSources();

      // Se n√£o tem fonte, player v√™ apenas mapa (tokens invis√≠veis)
      if (!sources.length){
        document.querySelectorAll('.token').forEach(t=>{
          t.style.opacity = 0;
          t.style.pointerEvents = "none";
        });
        // fog total
        fogCtx.clearRect(0,0,fogCanvas.width,fogCanvas.height);
        fogCtx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--fog') || 'rgba(0,0,0,0.82)';
        fogCtx.fillRect(0,0,fogCanvas.width,fogCanvas.height);
        return;
      }

      // tokens: vis√≠vel se dentro de algum c√≠rculo
      document.querySelectorAll('.token').forEach(t=>{
        const layer = Number(t.dataset.layer||2);
        ensureLayerDefaults(layer);
        if (!layerState.visible[layer]){
          t.style.opacity = 0;
          t.style.pointerEvents = "none";
          return;
        }
        const {x,y} = tokenCenterCanvas(t);
        let inside = false;
        for (const s of sources){
          const dx = x - s.x;
          const dy = y - s.y;
          const d2 = dx*dx + dy*dy;
          if (d2 <= (s.r*s.r)) { inside = true; break; }
        }
        t.style.opacity = inside ? 1 : 0;
        // player s√≥ interage se dentro e destravado (e a l√≥gica req/host valida)
        t.style.pointerEvents = inside ? "auto" : "none";
      });

      // desenha fog overlay com buracos
      fogCtx.clearRect(0,0,fogCanvas.width,fogCanvas.height);

      // base
      fogCtx.globalCompositeOperation = "source-over";
      fogCtx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--fog') || 'rgba(0,0,0,0.82)';
      fogCtx.fillRect(0,0,fogCanvas.width,fogCanvas.height);

      // recorta c√≠rculos
      fogCtx.globalCompositeOperation = "destination-out";

      for (const s of sources){
        const grd = fogCtx.createRadialGradient(s.x, s.y, Math.max(0, s.r*0.72), s.x, s.y, s.r);
        grd.addColorStop(0, "rgba(0,0,0,1)");
        grd.addColorStop(1, "rgba(0,0,0,0)");
        fogCtx.fillStyle = grd;
        fogCtx.beginPath();
        fogCtx.arc(s.x, s.y, s.r, 0, Math.PI*2);
        fogCtx.fill();
      }

      fogCtx.globalCompositeOperation = "source-over";
    }

    // ===== DADOS / LOG =====
    function rollDice(faces){
      if (!isHost) return;
      const res=Math.floor(Math.random()*faces)+1;
      const action={ type:"DICE", faces, result:res };
      applyAction(action,false); broadcastACT(action);
    }
    function showDiceLog(faces,res){
      const entry=document.createElement('div');
      entry.className="dice-entry mb-2 border-l-2 border-gold pl-3 opacity-0 transform translate-x-4 transition-all duration-300";
      entry.innerHTML=`<span class="opacity-50 text-[10px] font-bold">D${faces}:</span> <b class="text-white text-lg">${res}</b>`;
      diceLogEntries.prepend(entry);
      setTimeout(()=>entry.classList.remove('opacity-0','translate-x-4'),10);
    }

    // ===== IMPORT =====
    function isImageUrl(url){
      return (url.match(/\.(jpeg|jpg|gif|png|webp|avif)$/i)!=null) || url.startsWith('data:image');
    }

    function importFromUrl(inputId, type){
      if (!isHost) return alert("Apenas o Host importa.");
      const url=document.getElementById(inputId).value.trim();
      if (!url) return;

      if (type==="map"){
        if (!isImageUrl(url)) return alert("Mapa precisa ser imagem direta.");
        applyMapLocal(url,true);
        addToLibrary("maps", url);
        document.getElementById(inputId).value="";
        updateSceneSizeEstimate();
        return;
      }

      if (!isImageUrl(url)) return alert("Tokens/Assets precisam ser imagens diretas.");

      if (type==="player"){
        hostCreateToken(url,"image","player");
        addToLibrary("players", url);
      } else if (type==="asset"){
        hostCreateToken(url,"image","asset");
        addToLibrary("assets", url);
      }
      document.getElementById(inputId).value="";
      rebuildLayersPanel();
      applyLayerVisibilityToDOM();
      updateSceneSizeEstimate();
    }

    function importAsset(event, type){
      if (!isHost) return alert("Apenas o Host importa.");
      const file=event.target.files?.[0];
      if (!file) return;

      const reader=new FileReader();
      reader.onload=(e)=>{
        const dataUrl=e.target.result;

        if (type==="map"){
          applyMapLocal(dataUrl,true);
          addToLibrary("maps", dataUrl, "mapa-local");
        } else if (type==="player"){
          hostCreateToken(dataUrl,"image","player");
          addToLibrary("players", dataUrl, "player-local");
        } else if (type==="asset"){
          hostCreateToken(dataUrl,"image","asset");
          addToLibrary("assets", dataUrl, "asset-local");
        }

        rebuildLayersPanel();
        applyLayerVisibilityToDOM();
        updateSceneSizeEstimate();
      };
      reader.readAsDataURL(file);
    }

    // ===== BIBLIOTECA =====
    function toggleLibrary(){
      if (!isHost) return alert("Apenas o Host usa Biblioteca/Perfil.");
      libraryPanel.classList.toggle('show');
      renderLibrary();
    }

    function setLibraryTab(tab){
      libraryTab=tab;
      document.getElementById('tab-maps').classList.toggle('active', tab==='maps');
      document.getElementById('tab-players').classList.toggle('active', tab==='players');
      document.getElementById('tab-assets').classList.toggle('active', tab==='assets');
      renderLibrary();
    }

    function normalizeNameFromSrc(src, fallback){
      if (!src) return fallback || "asset";
      if (src.startsWith("data:image")) return fallback || "local";
      try{
        const u=new URL(src);
        const last=u.pathname.split("/").pop() || fallback || "img";
        return decodeURIComponent(last).slice(0,40);
      }catch{
        return fallback || "asset";
      }
    }

    function addToLibrary(kind, src, name=null){
      if (!isHost) return;
      if (!src) return;
      const list = library[kind];
      if (!Array.isArray(list)) return;
      if (list.some(x=>x.src===src)) return;

      list.unshift({
        id: generateUUID(),
        name: name || normalizeNameFromSrc(src, kind==="maps"?"mapa":kind),
        src
      });
      renderLibrary();
    }

    function renderLibrary(){
      if (!isHost) return;
      const term=(librarySearch.value||"").toLowerCase().trim();
      const list = library[libraryTab] || [];
      const filtered = term ? list.filter(x=>(x.name||"").toLowerCase().includes(term)) : list;

      libraryGrid.innerHTML="";
      filtered.forEach(item=>{
        const card=document.createElement('div');
        card.className="asset-card";

        const thumb=document.createElement('div');
        thumb.className="asset-thumb";
        const img=document.createElement('img');
        img.src=item.src;
        img.alt=item.name||"asset";
        thumb.appendChild(img);

        const title=document.createElement('div');
        title.style.fontSize="10px";
        title.style.opacity=".85";
        title.style.whiteSpace="nowrap";
        title.style.overflow="hidden";
        title.style.textOverflow="ellipsis";
        title.textContent=item.name||"asset";

        const actions=document.createElement('div');
        actions.className="asset-actions";

        const use=document.createElement('button');
        use.textContent = (libraryTab==="maps") ? "Usar" : "Add";
        use.onclick=()=>{
          if (libraryTab==="maps"){
            applyMapLocal(item.src,true);
          } else if (libraryTab==="players"){
            hostCreateToken(item.src,"image","player");
          } else if (libraryTab==="assets"){
            hostCreateToken(item.src,"image","asset");
          }
          rebuildLayersPanel();
          applyLayerVisibilityToDOM();
          updateSceneSizeEstimate();
        };

        const del=document.createElement('button');
        del.textContent="Remover";
        del.onclick=()=>removeFromLibrary(item.id);

        actions.appendChild(use);
        actions.appendChild(del);

        card.appendChild(thumb);
        card.appendChild(title);
        card.appendChild(actions);

        libraryGrid.appendChild(card);
      });

      const count=(library[libraryTab]||[]).length;
      libraryCount.textContent = `${count} itens`;
    }

    function removeFromLibrary(id){
      if (!isHost) return;
      for (const k of ["maps","players","assets"]){
        library[k] = (library[k]||[]).filter(x=>x.id!==id);
      }
      renderLibrary();
    }

    function clearLibrary(){
      if (!isHost) return;
      if (!confirm("Limpar toda a Biblioteca?")) return;
      library.maps=[]; library.players=[]; library.assets=[];
      renderLibrary();
    }

    function saveProfileToFile(){
      if (!isHost) return;
      const payload={ version:2, savedAt:new Date().toISOString(), library };
      const json=JSON.stringify(payload);
      const blob=new Blob([json],{type:"application/json"});

      const a=document.createElement('a');
      a.href=URL.createObjectURL(blob);
      a.download=`perfil-${new Date().toISOString().replace(/[:.]/g,'-')}.json`;
      document.body.appendChild(a);
      a.click();
      a.remove();
      setTimeout(()=>URL.revokeObjectURL(a.href),1500);
      showNotification("Perfil salvo!");
    }

    function loadProfileFromFile(event){
      if (!isHost) return;
      const file=event.target.files?.[0];
      if (!file) return;
      const r=new FileReader();
      r.onload=()=>{
        try{
          const payload=JSON.parse(String(r.result||"{}"));
          if (!payload?.library) throw 0;
          library.maps=Array.isArray(payload.library.maps)?payload.library.maps:[];
          library.players=Array.isArray(payload.library.players)?payload.library.players:[];
          library.assets=Array.isArray(payload.library.assets)?payload.library.assets:[];
          showNotification("Perfil carregado!");
          renderLibrary();
        }catch{
          alert("perfil.json inv√°lido.");
        }
        event.target.value="";
      };
      r.readAsText(file);
    }

    // ===== CENAS (SAVE/LOAD) =====
    function openScenePanel(){
      if (!isHost) return alert("Apenas o Host.");
      scenePanel.classList.toggle('show');
      updateQualityLabel();
      updateSceneSizeEstimate();
    }

    function byteLengthOfString(str){ return new Blob([str]).size; }
    function prettyBytes(bytes){
      const units=["B","KB","MB","GB"];
      let i=0,num=bytes;
      while(num>=1024 && i<units.length-1){ num/=1024; i++; }
      return `${num.toFixed(i===0?0:2)} ${units[i]}`;
    }

    function updateQualityLabel(){
      const q=document.getElementById('quality');
      const label=document.getElementById('quality-label');
      if (q && label) label.textContent=`Q ${Number(q.value).toFixed(2)}`;
    }

    function estimatePayloadSizeBytes(payload){
      try{ return byteLengthOfString(JSON.stringify(payload)); }
      catch{ return 0; }
    }

    function updateSceneSizeEstimate(){
      if (!isHost) return;
      const payload={
        version:5,
        savedAt:new Date().toISOString(),
        map: state.map,
        tokens: state.tokens,
        layerState
      };
      const bytes=estimatePayloadSizeBytes(payload);
      document.getElementById('scene-size').textContent = `~ ${prettyBytes(bytes)}`;
    }

    function blobToDataURL(blob){
      return new Promise((resolve,reject)=>{
        const r=new FileReader();
        r.onload=()=>resolve(r.result);
        r.onerror=reject;
        r.readAsDataURL(blob);
      });
    }

    async function tryFetchAsBlob(url){
      try{
        const resp=await fetch(url,{mode:"cors"});
        if(!resp.ok) throw 0;
        return await resp.blob();
      }catch{ return null; }
    }

    async function tryFetchAsDataURL(url){
      const blob=await tryFetchAsBlob(url);
      if(!blob) return null;
      if(!blob.type.startsWith("image/")) return null;
      return await blobToDataURL(blob);
    }

    async function compressBlobToWebP(blob, maxDim, quality){
      try{
        const bmp=await createImageBitmap(blob);
        const w=bmp.width,h=bmp.height;
        const s=Math.min(1, maxDim/Math.max(w,h));
        const nw=Math.max(1,Math.round(w*s));
        const nh=Math.max(1,Math.round(h*s));
        const c=document.createElement('canvas');
        c.width=nw; c.height=nh;
        const ctx=c.getContext('2d',{alpha:true});
        ctx.drawImage(bmp,0,0,nw,nh);
        const outBlob=await new Promise(res=>c.toBlob(res,"image/webp",quality));
        if(!outBlob) return null;
        return await blobToDataURL(outBlob);
      }catch{ return null; }
    }

    async function compressDataURLToWebP(dataUrl, maxDim, quality){
      try{
        const resp=await fetch(dataUrl);
        const blob=await resp.blob();
        if(!blob.type.startsWith("image/")) return null;
        return await compressBlobToWebP(blob,maxDim,quality);
      }catch{ return null; }
    }

    async function compressImageSrcIfPossible(src, maxDim, quality){
      if (typeof src==="string" && src.startsWith("http")){
        const blob=await tryFetchAsBlob(src);
        if(!blob || !blob.type.startsWith("image/")) return src;
        const webp=await compressBlobToWebP(blob,maxDim,quality);
        return webp || src;
      }
      if (typeof src==="string" && src.startsWith("data:image")){
        const webp=await compressDataURLToWebP(src,maxDim,quality);
        return webp || src;
      }
      return src;
    }

    async function buildScenePayloadSelfContained(){
      if (!isHost) return null;

      const embedRemote = !!document.getElementById('embed-remote')?.checked;
      const compress = !!document.getElementById('compress-images')?.checked;
      const maxDim = parseInt(document.getElementById('max-dim')?.value || "2048", 10);
      const quality = parseFloat(document.getElementById('quality')?.value || "0.75");

      const payload = {
        version:5,
        savedAt:new Date().toISOString(),
        map: JSON.parse(JSON.stringify(state.map)),
        tokens: JSON.parse(JSON.stringify(state.tokens)),
        layerState: JSON.parse(JSON.stringify(layerState))
      };

      if (payload.map?.src){
        if (embedRemote && payload.map.src.startsWith("http")){
          const du = await tryFetchAsDataURL(payload.map.src);
          if (du) payload.map.src = du;
        }
        if (compress && (payload.map.src.startsWith("http") || payload.map.src.startsWith("data:image"))){
          payload.map.src = await compressImageSrcIfPossible(payload.map.src, maxDim, quality);
        }
      }

      for (const id of Object.keys(payload.tokens)){
        const t = payload.tokens[id];
        if (!t?.src) continue;

        if (embedRemote && typeof t.src==="string" && t.src.startsWith("http")){
          const du = await tryFetchAsDataURL(t.src);
          if (du) t.src = du;
        }
        if (compress && t.type==="image"){
          t.src = await compressImageSrcIfPossible(t.src, maxDim, quality);
        }
      }

      return payload;
    }

    async function saveSceneToFile(){
      if (!isHost) return alert("Apenas o Host.");
      showNotification("Salvando...");
      const payload = await buildScenePayloadSelfContained();
      if (!payload) return;

      const json=JSON.stringify(payload);
      const blob=new Blob([json],{type:"application/json"});

      const a=document.createElement('a');
      a.href=URL.createObjectURL(blob);
      a.download=`cena-${new Date().toISOString().replace(/[:.]/g,'-')}.json`;
      document.body.appendChild(a);
      a.click();
      a.remove();
      setTimeout(()=>URL.revokeObjectURL(a.href),1500);

      showNotification(`Cena salva (${prettyBytes(blob.size)})!`);
      updateSceneSizeEstimate();
    }

    function hostLoadScenePayload(payload){
      if (!isHost) return;
      if (!payload || typeof payload!=="object") return alert("Cena inv√°lida.");

      const clear = { type:"CLEAR" };
      applyAction(clear,false); broadcastACT(clear);

      if (payload.layerState){
        layerState.visible = payload.layerState.visible || {};
        layerState.locked = payload.layerState.locked || {};
      }

      const map = payload.map || {src:null,locked:false,x:0,y:0};
      if (map.src){
        const a = { type:"MAP_UPDATE", src: map.src };
        applyAction(a,false); broadcastACT(a);
      }
      const lockA = { type:"MAP_LOCK", locked: !!map.locked };
      applyAction(lockA,false); broadcastACT(lockA);

      const moveA = { type:"MAP_MOVE", x: Number(map.x||0), y: Number(map.y||0) };
      applyAction(moveA,false); broadcastACT(moveA);

      const tokens = payload.tokens || {};
      for (const id of Object.keys(tokens)){
        const t = tokens[id];
        if (!t?.src || !t.type) continue;
        ensureLayerDefaults(Number(t.layer||2));
        const create = {
          type:"CREATE_TOKEN",
          id,
          src: t.src,
          contentType: t.type,
          props: {
            kind: t.kind || "asset",
            layer: Number(t.layer||2),
            x: t.x, y: t.y, w: t.w, h: t.h,
            rotation: t.rotation, flipped: t.flipped,
            innerZoom: t.innerZoom, locked: t.locked,
            fitMode: t.fitMode || "contain",

            // fog
            vision: t.vision || "off",
            fogRadius: Number(t.fogRadius||0)
          }
        };
        applyAction(create,false); broadcastACT(create);
      }

      applyLayerVisibilityToDOM();
      rebuildLayersPanel();
      showNotification("Cena carregada!");
      updateSceneSizeEstimate();
    }

    function loadSceneFromFile(event){
      if (!isHost) return;
      const file=event.target.files?.[0];
      if (!file) return;
      const r=new FileReader();
      r.onload=()=>{
        try{
          const payload=JSON.parse(String(r.result||"{}"));
          hostLoadScenePayload(payload);
        }catch{ alert("JSON inv√°lido."); }
        event.target.value="";
      };
      r.readAsText(file);
    }

    // ===== CLEAR / UNLOCK =====
    function clearTable(emit=true){
      if (!isHost) return;
      if (emit && !confirm("Deseja limpar todos os tokens e o mapa?")) return;
      const action={ type:"CLEAR" };
      applyAction(action,false); broadcastACT(action);
      updateSceneSizeEstimate();
      closeInspector();
    }

    function unlockEverything(){
      if (!isHost) return;
      document.querySelectorAll('.token.locked').forEach(t=>{
        const id=t.dataset.uuid;
        const action={ type:"UPDATE_PROP", id, prop:"locked", value:"false" };
        applyAction(action,false); broadcastACT(action);
      });
      if (state.map.locked) setMapLockLocal(false,true);
      updateSceneSizeEstimate();
    }

    // ===== PROTOCOLO REDE (Host autoritativo) =====
    function sendREQ(action){
      if (isHost){
        applyHostAuthorizedAction(action,{sender:myId});
        return;
      }
      if (hostConnection?.open){
        hostConnection.send({kind:"REQ", sender:myId, action});
      }
    }

    function broadcastACT(action, meta={}){
      if (!isHost) return;
      const msg={kind:"ACT", sender:myId, action, meta};
      connections.forEach(c=>{ if(c.open) c.send(msg); });
    }

    function sendSYNC(conn){
      if (!isHost) return;
      conn.send({kind:"SYNC", sender:myId, state, layerState});
    }

    function handleNetworkData(data, connPeerId=null){
      if (!data?.kind) return;

      if (data.kind==="SYNC"){
        applyFullSync(data.state, data.layerState);
        return;
      }
      if (data.kind==="ACT"){
        applyAction(data.action,true);
        return;
      }
      if (data.kind==="REQ"){
        if (!isHost) return;
        const sender=data.sender || connPeerId || "unknown";
        applyHostAuthorizedAction(data.action,{sender});
      }
    }

    // ===== VALIDA√á√ÉO (player) =====
    // Player: SOMENTE MOVE tokens destravados e layer vis√≠vel/livre
    function validateClientAction(action){
      if (!action?.type) return {ok:false,reason:"A√ß√£o inv√°lida"};
      if (action.type !== "MOVE") return {ok:false,reason:"Player s√≥ pode mover"};

      const id=action.id;
      if (!id || !state.tokens[id]) return {ok:false,reason:"Token inexistente"};

      const tok=state.tokens[id];
      const layer = Number(tok.layer||2);
      ensureLayerDefaults(layer);

      if (!layerState.visible[layer]) return {ok:false,reason:"Layer oculta"};
      if (layerState.locked[layer]) return {ok:false,reason:"Layer trancada"};
      if (String(tok.locked)==="true") return {ok:false,reason:"Token travado"};

      return {ok:true};
    }

    function applyHostAuthorizedAction(action,{sender}){
      const fromClient = sender && sender !== myId;
      if (fromClient){
        const v=validateClientAction(action);
        if (!v.ok){ console.warn("REQ negada:", v.reason, action); return; }
      }
      applyAction(action,false);
      broadcastACT(action,{approvedBy:myId, originalSender:sender});
    }

    // ===== APPLY ACTION =====
    function applyAction(action, fromNetwork){
      switch(action.type){
        case "CLEAR":{
          document.querySelectorAll('.token').forEach(t=>t.remove());
          mapContainer.innerHTML="";
          document.querySelectorAll('.dice-entry').forEach(l=>l.remove());
          selectedToken=null;
          stopMapInertia();
          mapDragging=false;

          state.map={src:null,locked:false,x:0,y:0};
          state.tokens={};

          setMapLockLocal(false,false);
          setMapOffset(0,0);

          rebuildLayersPanel();
          applyLayerVisibilityToDOM();
          if (!isHost) updateFogAndVisibility();
          break;
        }

        case "MAP_UPDATE":{
          state.map.src = action.src;
          applyMapLocal(action.src,false);
          break;
        }

        case "MAP_LOCK":{
          setMapLockLocal(!!action.locked,false);
          break;
        }

        case "MAP_MOVE":{
          const x=Number(action.x||0), y=Number(action.y||0);
          setMapOffset(x,y);
          break;
        }

        case "CREATE_TOKEN":{
          const {id, src, contentType, props} = action;
          addTokenLocal(src, contentType, id, props);
          state.tokens[id]=normalizeTokenProps(id,src,contentType,props);
          rebuildLayersPanel();
          applyLayerVisibilityToDOM();
          if (!isHost) updateFogAndVisibility();
          break;
        }

        case "REMOVE_TOKEN":{
          const {id}=action;
          removeTokenLocal(id);
          delete state.tokens[id];
          rebuildLayersPanel();
          applyLayerVisibilityToDOM();
          if (!isHost) updateFogAndVisibility();
          break;
        }

        case "MOVE":{
          const {id,x,y}=action;
          moveTokenDOM(id,x,y);
          if (state.tokens[id]){ state.tokens[id].x=x; state.tokens[id].y=y; }
          if (!isHost) updateFogAndVisibility();
          break;
        }

        case "UPDATE_PROP":{
          const {id,prop,value}=action;
          updateTokenPropDOM(id,prop,value);
          if (state.tokens[id]){
            if (prop==="locked") state.tokens[id].locked=String(value);
            if (prop==="innerZoom") state.tokens[id].innerZoom=value;
            if (prop==="rotation") state.tokens[id].rotation=value;
            if (prop==="flipped") state.tokens[id].flipped=value;
            if (prop==="fitMode") state.tokens[id].fitMode=value;
            if (prop==="size"){ state.tokens[id].w=value.w; state.tokens[id].h=value.h; }
            if (prop==="layer"){
              state.tokens[id].layer=Number(value);
              ensureLayerDefaults(Number(value));
            }
            if (prop==="vision") state.tokens[id].vision=String(value);
            if (prop==="fogRadius") state.tokens[id].fogRadius=Number(value||0);
          }
          rebuildLayersPanel();
          applyLayerVisibilityToDOM();
          if (!isHost) updateFogAndVisibility();
          break;
        }

        case "DICE":{
          showDiceLog(action.faces, action.result);
          break;
        }

        case "LAYER_SET":{
          const l=Number(action.layer);
          ensureLayerDefaults(l);
          if (action.prop==="visible") layerState.visible[l]=!!action.value;
          if (action.prop==="locked") layerState.locked[l]=!!action.value;
          applyLayerVisibilityToDOM();
          rebuildLayersPanel();
          if (!isHost) updateFogAndVisibility();
          break;
        }
      }
      if (isHost) updateSceneSizeEstimate();
    }

    function applyFullSync(s, ls){
      document.querySelectorAll('.token').forEach(t=>t.remove());
      mapContainer.innerHTML="";
      document.querySelectorAll('.dice-entry').forEach(l=>l.remove());
      selectedToken=null;
      stopMapInertia();

      layerState.visible = ls?.visible || {};
      layerState.locked = ls?.locked || {};

      if (s?.map){
        state.map = JSON.parse(JSON.stringify(s.map));
        if (state.map.src) applyMapLocal(state.map.src,false);
        setMapLockLocal(!!state.map.locked,false);
        setMapOffset(Number(state.map.x||0), Number(state.map.y||0));
      }

      state.tokens = {};
      const tokens = s?.tokens || {};
      for (const id of Object.keys(tokens)){
        const t=tokens[id];
        ensureLayerDefaults(Number(t.layer||2));
        addTokenLocal(t.src, t.type, id, t);
        state.tokens[id]=JSON.parse(JSON.stringify(t));
      }

      applyLayerVisibilityToDOM();
      rebuildLayersPanel();
      updateSceneSizeEstimate();
      if (!isHost) updateFogAndVisibility();
    }

    // ===== Keyboard =====
    window.addEventListener('keydown',(e)=>{
      if (!selectedToken) return;
      if (!isHost) return; // s√≥ host gira/flip/delete pelo teclado

      if (e.key.toLowerCase()==='f'){
        insFlip();
      }
      if (e.key==='Delete'){
        insDelete();
      }
    });

    viewport.addEventListener('mousedown',(e)=>{
      if (e.target===viewport || e.target===canvas || e.target===gridLayer || e.target===fogCanvas){
        if (selectedToken) selectedToken.classList.remove('selected');
        selectedToken=null;
        closeInspector();
      }
    });

    // ===== PeerJS setup =====
    function initNetwork(){
      const urlParams=new URLSearchParams(window.location.search);
      const roomID=urlParams.get('room');

      peer=new Peer(null,{debug:2, config:PEER_ICE_CONFIG});

      peer.on('open',(id)=>{
        myId=id;

        if (roomID){
          isHost=false;
          setRoleUI();
          statusText.innerText="Conectando ao Host...";
          tinyStatus.textContent="Conectando...";
          tinyRoom.textContent=roomID;
          connectToHost(roomID);
        } else {
          isHost=true;
          setRoleUI();
          statusText.innerText="Online (Host)";
          tinyStatus.textContent="Online (Host)";
          tinyRoom.textContent=id;
          statusDot.classList.add('online');
          toggleNetworkPanel();

          peer.on('connection',(conn)=>{
            connections.push(conn);
            setupConnection(conn);
            conn.on('open',()=>setTimeout(()=>sendSYNC(conn),200));
            conn.on('close',()=>{connections=connections.filter(c=>c!==conn);});
          });
        }
      });

      peer.on('error',(err)=>{
        console.error(err);
        statusText.innerText="Erro Rede";
        tinyStatus.textContent="Erro Rede";
        statusDot.classList.remove('online');
      });
    }

    function connectToHost(hostId){
      hostConnection=peer.connect(hostId);
      setupConnection(hostConnection);

      hostConnection.on('open',()=>{
        statusText.innerText="Conectado";
        tinyStatus.textContent="Conectado";
        statusDot.classList.add('online');
      });

      hostConnection.on('close',()=>{
        statusText.innerText="Desconectado";
        tinyStatus.textContent="Desconectado";
        statusDot.classList.remove('online');
        alert("O Host desconectou.");
      });
    }

    function setupConnection(conn){
      conn.on('data',(data)=>handleNetworkData(data, conn.peer));
    }

    // ===== Scene UI hooks =====
    function initUI(){
      const q=document.getElementById('quality');
      q?.addEventListener('input',updateQualityLabel);
      q?.addEventListener('change',updateSceneSizeEstimate);
      document.getElementById('max-dim')?.addEventListener('change',updateSceneSizeEstimate);
      document.getElementById('compress-images')?.addEventListener('change',updateSceneSizeEstimate);
      document.getElementById('embed-remote')?.addEventListener('change',updateSceneSizeEstimate);
      updateQualityLabel();
      updateSceneSizeEstimate();
    }

    // ===== Context menu off =====
    window.addEventListener('contextmenu',(e)=>e.preventDefault());

    // ===== Start =====
    initNetwork();
    initUI();
  </script>
</body>
</html>
