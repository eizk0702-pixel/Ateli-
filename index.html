<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>Tabletop Luxury - P2P (Mapa ‚Äúpalp√°vel‚Äù + Camadas + Biblioteca de Assets)</title>

  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>

  <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Inter:wght@300;400;600&display=swap" rel="stylesheet">

  <style>
    :root{
      --gold:#c5a059;
      --dark-bg:#0f0f0f;
      --panel-bg:rgba(20,20,20,.9);
      --glass:rgba(255,255,255,.03);
      --status-online:#4ade80;
      --status-offline:#ef4444;
    }
    body{margin:0;overflow:hidden;background:var(--dark-bg);font-family:'Inter',sans-serif;color:#e0e0e0;}

    #viewport{width:100vw;height:100vh;overflow:hidden;position:relative;background:radial-gradient(circle,#1a1a1a 0%,#0a0a0a 100%);z-index:1;}
    #canvas-container{width:10000px;height:10000px;position:absolute;top:0;left:0;transform-origin:0 0;cursor:grab;z-index:2;}

    /* MAPA = camada 0 */
    #map-container{
      position:absolute;top:0;left:0;
      z-index:5;
      pointer-events:auto;
      transform: translate(0px,0px);
      transform-origin: 0 0;
    }
    #map-container.locked{pointer-events:none;}
    #map-container img{
      display:block;max-width:none;
      user-select:none;
      -webkit-user-drag:none;
      cursor: grab;
      filter: drop-shadow(0 0 25px rgba(0,0,0,.45));
    }
    #map-container.dragging img{cursor: grabbing;}

    .grid-layer{
      position:absolute;top:0;left:0;width:100%;height:100%;
      pointer-events:none;
      background-image:
        linear-gradient(to right, rgba(197,160,89,.05) 1px, transparent 1px),
        linear-gradient(to bottom, rgba(197,160,89,.05) 1px, transparent 1px);
      background-size:50px 50px;
      z-index:6;
    }

    /* TOKENS = camadas >= 1 */
    .token{
      position:absolute;
      cursor:move;
      user-select:none;
      display:flex;align-items:center;justify-content:center;
      background:transparent;
      overflow:visible;
      transition:filter .2s ease, outline .2s ease;
    }
    .token.locked{cursor:default!important;pointer-events:none;}
    .token.locked .token-controls,.token.locked .resize-handle{display:none!important;}

    .token-blocker{position:absolute;top:0;left:0;width:100%;height:100%;z-index:50;background:rgba(255,255,255,.001);}
    .token-content-wrapper{width:100%;height:100%;overflow:hidden;display:flex;align-items:center;justify-content:center;pointer-events:none;}

    .token iframe,.token img{
      width:100%;height:100%;border:none;background:transparent;pointer-events:none;
      object-fit:contain;
      transition:transform .2s ease-out;
    }

    .token.selected:not(.locked){
      filter:drop-shadow(0 0 15px var(--gold));
      outline:2px dashed rgba(197,160,89,.6);
      outline-offset:4px;
    }

    .resize-handle{
      position:absolute;width:16px;height:16px;background:var(--gold);
      border:2px solid #fff;border-radius:4px;display:none;z-index:110;
      cursor:nwse-resize;bottom:-8px;right:-8px;
    }
    .token.selected:not(.locked) .resize-handle{display:block;}

    .token-controls{
      position:absolute;top:-65px;left:50%;transform:translateX(-50%);
      display:none;background:var(--panel-bg);backdrop-filter:blur(12px);
      border:1px solid rgba(197,160,89,.4);border-radius:40px;
      padding:8px 16px;gap:12px;z-index:200;
      box-shadow:0 4px 20px rgba(0,0,0,.5);
      white-space:nowrap;
    }
    .token.selected:not(.locked) .token-controls{display:flex;align-items:center;}
    .token-btn{
      color:#fff;font-size:16px;cursor:pointer;opacity:.85;transition:all .2s;
      display:flex;align-items:center;gap:5px;
    }
    .token-btn:hover{opacity:1;color:var(--gold);transform:scale(1.08);}

    .hud-element{transition:opacity .4s ease, transform .4s ease;}
    .hud-hidden .hud-element{opacity:0!important;pointer-events:none!important;transform:translateY(10px);}

    .sidebar{
      width:300px;background:var(--panel-bg);backdrop-filter:blur(15px);
      height:100vh;position:fixed;left:0;top:0;z-index:1000;
      border-right:1px solid rgba(197,160,89,.2);
      transform:translateX(-100%);
      transition:transform .4s cubic-bezier(.16,1,.3,1);
    }
    .sidebar.open{transform:translateX(0);}
    .toggle-sidebar-btn{
      position:absolute;right:-35px;top:20px;background:var(--panel-bg);
      border:1px solid rgba(197,160,89,.2);border-left:none;
      padding:10px 8px;border-radius:0 8px 8px 0;cursor:pointer;color:var(--gold);
    }

    .controls-top{
      position:fixed;top:20px;left:50%;transform:translateX(-50%);
      display:flex;gap:10px;z-index:1000;background:var(--panel-bg);
      padding:8px;border-radius:40px;border:1px solid rgba(197,160,89,.2);
      backdrop-filter:blur(10px);box-shadow:0 5px 25px rgba(0,0,0,.4);
    }

    .btn-luxury{
      padding:8px 16px;border-radius:20px;font-size:12px;font-weight:600;
      text-transform:uppercase;letter-spacing:1px;transition:all .3s;
      border:1px solid transparent;color:#ccc;background:transparent;
    }
    .btn-luxury:hover,.btn-luxury.active{
      color:var(--gold);background:var(--glass);border-color:rgba(197,160,89,.4);
    }

    .dice-log{
      position:fixed;bottom:25px;right:25px;width:240px;max-height:200px;
      background:var(--panel-bg);border-radius:12px;border:1px solid rgba(197,160,89,.15);
      padding:15px;overflow-y:auto;font-size:13px;z-index:1000;
      box-shadow:0 4px 15px rgba(0,0,0,.3);
    }

    .btn-toggle-hud{
      position:fixed;bottom:25px;left:25px;z-index:2000;background:var(--panel-bg);
      width:45px;height:45px;border-radius:50%;
      display:flex;align-items:center;justify-content:center;
      border:1px solid rgba(197,160,89,.3);cursor:pointer;color:var(--gold);
      box-shadow:0 4px 10px rgba(0,0,0,.4);
    }

    .url-field{
      background:rgba(0,0,0,.3);border:1px solid rgba(197,160,89,.2);color:#fff;
      width:100%;font-size:12px;padding:8px;margin-bottom:10px;outline:none;border-radius:6px;
    }
    .url-field:focus{border-color:var(--gold);background:rgba(0,0,0,.5);}

    h2,h3{font-family:'Cinzel',serif;letter-spacing:1px;color:var(--gold);}

    .network-status{
      position:fixed;top:80px;right:20px;display:flex;align-items:center;gap:10px;
      background:var(--panel-bg);padding:8px 16px;border-radius:20px;
      border:1px solid rgba(197,160,89,.2);font-size:11px;z-index:1000;
      backdrop-filter:blur(10px);
      opacity:0;pointer-events:none;transform:translateY(-10px);transition:all .3s;
    }
    .network-status.show{opacity:1;pointer-events:auto;transform:translateY(0);}

    .status-dot{width:8px;height:8px;border-radius:50%;background:var(--status-offline);box-shadow:0 0 5px currentColor;}
    .status-dot.online{background:var(--status-online);}

    .lock-manager{
      position:fixed;top:20px;right:20px;z-index:1000;display:flex;flex-direction:column;gap:10px;
    }

    #notification{
      position:fixed;top:50%;left:50%;transform:translate(-50%,-50%) scale(.9);
      background:rgba(0,0,0,.9);border:1px solid var(--gold);
      padding:20px 40px;border-radius:10px;z-index:9999;color:var(--gold);
      font-family:'Cinzel',serif;opacity:0;pointer-events:none;transition:all .3s;
    }
    #notification.active{opacity:1;transform:translate(-50%,-50%) scale(1);}

    #role-badge{
      position:fixed;top:140px;right:20px;z-index:1100;background:var(--panel-bg);
      border:1px solid rgba(197,160,89,.2);border-radius:999px;padding:6px 12px;
      font-size:11px;backdrop-filter:blur(10px);opacity:.95;
    }
    #role-badge b{color:var(--gold);}

    /* BIBLIOTECA */
    .library-panel{
      position:fixed;top:170px;right:20px;z-index:1200;width:380px;max-height:560px;
      background:var(--panel-bg);border:1px solid rgba(197,160,89,.2);
      border-radius:16px;padding:12px;backdrop-filter:blur(10px);
      box-shadow:0 10px 30px rgba(0,0,0,.45);overflow:hidden;display:none;
    }
    .library-panel.show{display:block;}

    .library-tabs{display:flex;gap:8px;margin-bottom:10px;}
    .library-tab{
      flex:1;padding:8px 10px;border-radius:12px;border:1px solid rgba(197,160,89,.25);
      background:rgba(255,255,255,.03);font-size:11px;text-transform:uppercase;letter-spacing:.6px;
      cursor:pointer;color:#ccc;text-align:center;
    }
    .library-tab.active{color:var(--gold);border-color:rgba(197,160,89,.55);background:rgba(255,255,255,.05);}

    .library-search{
      width:100%;margin-bottom:10px;padding:8px 10px;border-radius:10px;
      border:1px solid rgba(197,160,89,.2);background:rgba(0,0,0,.35);color:#fff;font-size:12px;outline:none;
    }

    .library-grid{
      overflow:auto;max-height:390px;padding-right:6px;
      display:grid;grid-template-columns:repeat(3,1fr);gap:10px;
    }

    .asset-card{
      border:1px solid rgba(197,160,89,.18);background:rgba(255,255,255,.03);
      border-radius:14px;padding:8px;display:flex;flex-direction:column;gap:8px;
    }
    .asset-thumb{
      width:100%;aspect-ratio:1/1;border-radius:12px;overflow:hidden;border:1px solid rgba(255,255,255,.06);
      background:rgba(0,0,0,.35);display:flex;align-items:center;justify-content:center;
    }
    .asset-thumb img{width:100%;height:100%;object-fit:cover;}
    .asset-actions{display:flex;gap:6px;}
    .asset-actions button{
      flex:1;padding:6px 8px;border-radius:10px;border:1px solid rgba(197,160,89,.25);
      background:rgba(255,255,255,.03);color:#ddd;font-size:10px;cursor:pointer;
    }
    .asset-actions button:hover{color:var(--gold);border-color:rgba(197,160,89,.55);background:rgba(255,255,255,.05);}

    /* CAMADAS */
    .layers-panel{
      position:fixed;top:230px;left:50%;transform:translateX(-50%);
      z-index:1200;min-width:360px;max-width:520px;
      background:var(--panel-bg);border:1px solid rgba(197,160,89,.2);
      border-radius:16px;padding:12px;backdrop-filter:blur(10px);
      box-shadow:0 10px 30px rgba(0,0,0,.45);
      display:none;
    }
    .layers-panel.show{display:block;}
    .layer-row{display:flex;align-items:center;justify-content:space-between;gap:10px;padding:8px 10px;border-radius:12px;background:rgba(255,255,255,.03);border:1px solid rgba(197,160,89,.12);margin-bottom:8px;}
    .layer-row b{color:var(--gold);}
    .layer-actions{display:flex;gap:8px;align-items:center;}
    .pill{
      font-size:10px;padding:5px 10px;border-radius:999px;border:1px solid rgba(197,160,89,.25);cursor:pointer;
      background:rgba(255,255,255,.03);color:#ddd;
    }
    .pill.active{color:var(--gold);border-color:rgba(197,160,89,.55);background:rgba(255,255,255,.05);}

    /* PAINEL DE JOGADORES (Host) */
    .players-panel{
      position:fixed;top:170px;right:20px;z-index:1300;width:380px;max-height:560px;
      background:var(--panel-bg);border:1px solid rgba(197,160,89,.2);
      border-radius:16px;padding:12px;backdrop-filter:blur(10px);
      box-shadow:0 10px 30px rgba(0,0,0,.45);overflow:hidden;display:none;
    }
    .players-panel.show{display:block;}
    .players-list{max-height:460px;overflow:auto;padding-right:6px;display:flex;flex-direction:column;gap:8px;}
    .player-row{
      display:flex;flex-direction:column;gap:8px;
      border:1px solid rgba(197,160,89,.14);background:rgba(255,255,255,.03);
      border-radius:14px;padding:10px;
    }
    .player-top{display:flex;align-items:center;justify-content:space-between;gap:10px;}
    .player-id{font-size:11px;opacity:.9;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;max-width:250px;}
    .player-meta{display:flex;gap:10px;align-items:center;font-size:10px;opacity:.75;flex-wrap:wrap;}
    .mini-badge{
      border:1px solid rgba(197,160,89,.25);
      border-radius:999px;padding:3px 8px;background:rgba(255,255,255,.03);
    }
    .player-actions{display:flex;gap:8px;}
    .player-actions button{
      flex:1;padding:6px 8px;border-radius:10px;border:1px solid rgba(197,160,89,.25);
      background:rgba(255,255,255,.03);color:#ddd;font-size:10px;cursor:pointer;
    }
    .player-actions button:hover{color:var(--gold);border-color:rgba(197,160,89,.55);background:rgba(255,255,255,.05);}
    .player-actions .kick:hover{color:#ff6b6b;border-color:rgba(255,107,107,.55);background:rgba(255,107,107,.08);}
  </style>
</head>

<body>
  <div id="notification">OK</div>
  <div id="role-badge">Modo: <b id="role-text">...</b></div>

  <div class="btn-toggle-hud" onclick="toggleHUD()" title="Esconder/Mostrar Interface">üëÅÔ∏è</div>

  <div id="hud-root">
    <div class="controls-top hud-element">
      <button class="btn-luxury" id="btn-d20" onclick="rollDice(20)">D20</button>
      <button class="btn-luxury" id="btn-d6" onclick="rollDice(6)">D6</button>
      <button class="btn-luxury" onclick="toggleGrid()">Grelha</button>
      <button class="btn-luxury" id="btn-lock-all" onclick="unlockEverything()">üîì Destrancar</button>
      <button class="btn-luxury" id="btn-save-scene" onclick="openScenePanel()">üíæ Cena</button>
      <button class="btn-luxury" id="btn-library" onclick="toggleLibrary()">üì¶ Biblioteca</button>
      <button class="btn-luxury" id="btn-layers" onclick="toggleLayersPanel()">üß± Camadas</button>
      <button class="btn-luxury" id="btn-players" onclick="togglePlayersPanel()">üë• Jogadores</button>
      <button class="btn-luxury" onclick="toggleNetworkPanel()">üåê Rede</button>
    </div>

    <div class="lock-manager hud-element">
      <button class="btn-luxury bg-black/40 border-gold/20" id="btn-lock-map" onclick="toggleMapLock()">üîì Mapa M√≥vel</button>
    </div>

    <div class="network-status" id="network-panel">
      <div id="status-dot" class="status-dot"></div>
      <span id="status-text">Offline</span>
      <div class="h-4 w-px bg-white/20 mx-2"></div>
      <button class="btn-luxury py-0 px-2 text-[10px]" onclick="copyInviteLink()" id="btn-invite">üîó Copiar Convite</button>
    </div>

    <!-- Painel de Cenas -->
    <div class="network-status" id="scene-panel" style="top: 120px;">
      <span style="color: var(--gold); font-weight:700;">Cenas</span>
      <div class="h-4 w-px bg-white/20 mx-2"></div>

      <label class="btn-luxury py-0 px-2 text-[10px] cursor-pointer" style="display:flex;align-items:center;gap:6px;">
        <input type="checkbox" id="embed-remote" checked> Embutir URLs
      </label>

      <label class="btn-luxury py-0 px-2 text-[10px] cursor-pointer" style="display:flex;align-items:center;gap:6px;">
        <input type="checkbox" id="compress-images" checked> Comprimir
      </label>

      <select id="max-dim" class="url-field" style="margin:0; padding:6px; width:95px;">
        <option value="1024">1024px</option>
        <option value="1536">1536px</option>
        <option value="2048" selected>2048px</option>
        <option value="3072">3072px</option>
        <option value="4096">4096px</option>
      </select>

      <input id="quality" type="range" min="0.4" max="0.95" step="0.05" value="0.75" style="width:90px;">
      <span id="quality-label" style="font-size:10px;opacity:.8;">Q 0.75</span>

      <span id="scene-size" style="font-size:10px;opacity:.8; margin-left:6px;">~ -</span>

      <div class="h-4 w-px bg-white/20 mx-2"></div>

      <button class="btn-luxury py-0 px-2 text-[10px]" onclick="saveSceneToFile()">Salvar .JSON</button>
      <label class="btn-luxury py-0 px-2 text-[10px] cursor-pointer">
        Carregar .JSON
        <input type="file" id="scene-file" accept="application/json" style="display:none" onchange="loadSceneFromFile(event)">
      </label>
    </div>

    <!-- Biblioteca / Perfil -->
    <div class="library-panel" id="library-panel">
      <div style="display:flex; align-items:center; justify-content:space-between; gap:10px; margin-bottom:10px;">
        <div style="color: var(--gold); font-weight:700; font-family:'Cinzel',serif;">Biblioteca</div>
        <div style="display:flex; gap:8px;">
          <button class="btn-luxury py-0 px-2 text-[10px]" onclick="saveProfileToFile()">Salvar Perfil</button>
          <label class="btn-luxury py-0 px-2 text-[10px] cursor-pointer">
            Carregar Perfil
            <input type="file" id="profile-file" accept="application/json" style="display:none" onchange="loadProfileFromFile(event)">
          </label>
        </div>
      </div>

      <div class="library-tabs">
        <div class="library-tab active" id="tab-maps" onclick="setLibraryTab('maps')">Mapas</div>
        <div class="library-tab" id="tab-players" onclick="setLibraryTab('players')">Players</div>
        <div class="library-tab" id="tab-assets" onclick="setLibraryTab('assets')">Assets</div>
      </div>

      <input class="library-search" id="library-search" placeholder="Buscar..." oninput="renderLibrary()">
      <div class="library-grid" id="library-grid"></div>

      <div style="display:flex; justify-content:space-between; align-items:center; margin-top:10px; font-size:10px; opacity:.8;">
        <span id="library-count">0 itens</span>
        <button class="btn-luxury py-0 px-2 text-[10px]" onclick="clearLibrary()">Limpar Biblioteca</button>
      </div>
    </div>

    <!-- Jogadores (Host) -->
    <div class="players-panel" id="players-panel">
      <div style="display:flex; align-items:center; justify-content:space-between; gap:10px; margin-bottom:10px;">
        <div style="color: var(--gold); font-weight:700; font-family:'Cinzel',serif;">Jogadores Conectados</div>
        <div style="display:flex; gap:8px;">
          <button class="btn-luxury py-0 px-2 text-[10px]" onclick="pingAll()">Ping</button>
          <button class="btn-luxury py-0 px-2 text-[10px]" onclick="resyncAll()">Re-sync</button>
        </div>
      </div>
      <div class="players-list" id="players-list"></div>
      <div style="display:flex; justify-content:space-between; align-items:center; margin-top:10px; font-size:10px; opacity:.8;">
        <span id="players-count">0 online</span>
        <button class="btn-luxury py-0 px-2 text-[10px]" onclick="closePlayersPanel()">Fechar</button>
      </div>
    </div>

    <!-- Camadas -->
    <div class="layers-panel" id="layers-panel">
      <div style="display:flex;align-items:center;justify-content:space-between;gap:10px;margin-bottom:10px;">
        <div style="color: var(--gold); font-weight:700; font-family:'Cinzel',serif;">Camadas (Layer 0 = Mapa)</div>
        <button class="btn-luxury py-0 px-2 text-[10px]" onclick="rebuildLayersPanel()">Atualizar</button>
      </div>
      <div id="layers-list"></div>
      <div style="font-size:10px;opacity:.75; margin-top:10px;">
        Dica: tokens t√™m ‚Äúlayer‚Äù e ‚Äúkind‚Äù (player/asset). Player s√≥ move o que est√° destravado e em camada vis√≠vel.
      </div>
    </div>

    <div class="sidebar hud-element" id="sidebar">
      <div class="toggle-sidebar-btn" onclick="toggleSidebar()">‚ò∞</div>
      <div class="p-6 overflow-y-auto h-full">
        <h2 class="text-xl font-bold mb-6 border-b border-gold/30 pb-3">Atelier P2P</h2>

        <!-- MAPA (Host) -->
        <div class="mb-8" id="host-only-map">
          <h3 class="text-xs font-semibold uppercase mb-4 opacity-70">Mapa (Layer 0)</h3>
          <div class="bg-black/40 p-4 border border-dashed border-gold/30 rounded-xl">
            <input type="file" id="map-file" accept="image/*" class="hidden" onchange="importAsset(event, 'map')">
            <label for="map-file" class="btn-luxury block text-center mb-3 cursor-pointer bg-white/5">Ficheiro Local</label>
            <input type="text" id="map-url" class="url-field" placeholder="https://link-do-mapa.jpg">
            <button class="btn-luxury w-full border border-gold/30" onclick="importFromUrl('map-url', 'map')">Definir Mapa</button>
          </div>
          <p class="text-[10px] opacity-50 mt-3 leading-relaxed italic">
            Agora o mapa √© arrast√°vel com ‚Äúin√©rcia‚Äù (palp√°vel). Trave para evitar mover.
          </p>
        </div>

        <!-- PLAYERS (Host) -->
        <div class="mb-8" id="host-only-players">
          <h3 class="text-xs font-semibold uppercase mb-4 opacity-70">Players (tokens)</h3>
          <div class="bg-black/40 p-4 border border-dashed border-gold/30 rounded-xl">
            <input type="file" id="player-file" accept="image/*" class="hidden" onchange="importAsset(event, 'player')">
            <label for="player-file" class="btn-luxury block text-center mb-3 cursor-pointer bg-white/5">Ficheiro Local</label>
            <input type="text" id="player-url" class="url-field" placeholder="URL Imagem...">
            <button class="btn-luxury w-full border border-gold/30" onclick="importFromUrl('player-url', 'player')">Adicionar Player</button>
          </div>
          <p class="text-[10px] opacity-50 mt-3 leading-relaxed italic">
            Players entram por padr√£o em layer 3.
          </p>
        </div>

        <!-- ASSETS (Host) -->
        <div class="mb-8" id="host-only-assets">
          <h3 class="text-xs font-semibold uppercase mb-4 opacity-70">Assets (tudo que n√£o √© player nem mapa)</h3>
          <div class="bg-black/40 p-4 border border-dashed border-gold/30 rounded-xl">
            <input type="file" id="asset-file" accept="image/*" class="hidden" onchange="importAsset(event, 'asset')">
            <label for="asset-file" class="btn-luxury block text-center mb-3 cursor-pointer bg-white/5">Ficheiro Local</label>
            <input type="text" id="asset-url" class="url-field" placeholder="URL Imagem...">
            <button class="btn-luxury w-full border border-gold/30" onclick="importFromUrl('asset-url', 'asset')">Adicionar Asset</button>
          </div>
          <p class="text-[10px] opacity-50 mt-3 leading-relaxed italic">
            Assets entram por padr√£o em layer 2.
          </p>
        </div>

        <div class="mt-auto pt-6 border-t border-gold/20" id="host-only-clear">
          <button class="btn-luxury w-full text-red-500 border-red-900/30 hover:bg-red-900/20" onclick="clearTable()">Limpar Mesa</button>
        </div>

        <div class="mt-6 text-[10px] opacity-50 leading-relaxed">
          <div><b>Status:</b> <span id="tiny-status">iniciando...</span></div>
          <div><b>Sala:</b> <span id="tiny-room">-</span></div>
        </div>
      </div>
    </div>

    <div class="dice-log hud-element" id="dice-log">
      <div id="dice-entries">
        <div class="text-[11px] opacity-40 mb-3 uppercase tracking-tighter">Hist√≥rico</div>
      </div>
    </div>
  </div>

  <div id="viewport">
    <div id="canvas-container">
      <div id="map-container" class="map-layer"></div>
      <div id="grid-layer" class="grid-layer"></div>
    </div>
  </div>

  <script>
    /********************************************************************
     * ‚úÖ MULTIPLAYER ARRUMADO DE VERDADE:
     * - Fila de envio + backpressure (bufferedAmount) -> evita chunks perdidos e SYNC quebrado
     * - Chunk menor e robusto
     * - RESYNC autom√°tico no player se SYNC n√£o chega / chunks expiram
     * - Painel do Host: lista conectados + ping + re-sync + kick
     ********************************************************************/

    // ===== UTIL =====
    const generateUUID = () => Date.now().toString(36) + Math.random().toString(36).slice(2);

    function showNotification(msg){
      const n=document.getElementById('notification');
      n.innerText=msg;
      n.classList.add('active');
      setTimeout(()=>n.classList.remove('active'),2000);
    }

    // ===== ELEMENTOS =====
    const canvas = document.getElementById('canvas-container');
    const viewport = document.getElementById('viewport');
    const mapContainer = document.getElementById('map-container');
    const gridLayer = document.getElementById('grid-layer');
    const sidebar = document.getElementById('sidebar');
    const diceLogEntries = document.getElementById('dice-entries');

    const statusDot = document.getElementById('status-dot');
    const statusText = document.getElementById('status-text');
    const networkPanel = document.getElementById('network-panel');
    const scenePanel = document.getElementById('scene-panel');

    const roleText = document.getElementById('role-text');
    const tinyStatus = document.getElementById('tiny-status');
    const tinyRoom = document.getElementById('tiny-room');

    const hostOnlyMap = document.getElementById('host-only-map');
    const hostOnlyPlayers = document.getElementById('host-only-players');
    const hostOnlyAssets = document.getElementById('host-only-assets');
    const hostOnlyClear = document.getElementById('host-only-clear');

    const btnLockAll = document.getElementById('btn-lock-all');
    const btnLockMap = document.getElementById('btn-lock-map');
    const btnInvite = document.getElementById('btn-invite');
    const btnD20 = document.getElementById('btn-d20');
    const btnD6 = document.getElementById('btn-d6');
    const btnSaveScene = document.getElementById('btn-save-scene');
    const btnLibrary = document.getElementById('btn-library');
    const btnLayers = document.getElementById('btn-layers');
    const btnPlayers = document.getElementById('btn-players');

    // Biblioteca
    const libraryPanel = document.getElementById('library-panel');
    const libraryGrid = document.getElementById('library-grid');
    const librarySearch = document.getElementById('library-search');
    const libraryCount = document.getElementById('library-count');
    let libraryTab = "maps";
    const library = { maps: [], players: [], assets: [] };

    // Camadas
    const layersPanel = document.getElementById('layers-panel');
    const layersList = document.getElementById('layers-list');

    // Players panel
    const playersPanel = document.getElementById('players-panel');
    const playersListEl = document.getElementById('players-list');
    const playersCountEl = document.getElementById('players-count');

    // ===== CAMERA =====
    let scale = 1;
    let posX = window.innerWidth/2 - 5000;
    let posY = window.innerHeight/2 - 5000;
    let isPanning = false;
    let startPan = {x:0,y:0};

    function updateTransform(){
      canvas.style.transform = `translate(${posX}px, ${posY}px) scale(${scale})`;
    }
    updateTransform();

    // ===== SELE√á√ÉO =====
    let selectedToken = null;

    // ===== REDE =====
    let peer, connections = [], hostConnection = null;
    let myId = null;
    let isHost = false;

    let hasSynced = false;
    let resyncTimer = null;
    let lastResyncAt = 0;

    const clients = new Map(); // host: peerId -> {conn, joinedAt, lastSeen, rtt, synced}

    const PEER_ICE_CONFIG = {
      iceServers: [
        { urls: "stun:stun.l.google.com:19302" },
        { urls: "stun:stun1.l.google.com:19302" },
        { urls: "stun:global.stun.twilio.com:3478" }
      ]
    };

    // ======= ‚úÖ TRANSPORTE COM BACKPRESSURE + CHUNKING =======
    const NET_CHUNK_SIZE = 8000;      // mais seguro que 12k
    const NET_MAX_BUFFER = 900000;    // ~0.9MB de bufferedAmount antes de pausar
    const NET_TICK_MS = 0;            // processa fila r√°pido, mas respeita buffer

    const chunkInbox = new Map(); // msgId -> { total, parts:[], ts }
    const CHUNK_TTL_MS = 20000;

    function nowMs(){ return performance.now(); }
    function safeJsonStringify(obj){ try { return JSON.stringify(obj); } catch { return null; } }
    function safeJsonParse(str){ try { return JSON.parse(str); } catch { return null; } }

    function getDataChannel(conn){
      return conn? (conn._dc || conn.dataChannel || conn._dataChannel || null) : null;
    }

    function enqueueSend(conn, payload){
      if (!conn?.open) return;
      if (!conn.__sendQueue) conn.__sendQueue = [];
      conn.__sendQueue.push(payload);
      if (!conn.__sending) processSendQueue(conn);
    }

    function processSendQueue(conn){
      if (!conn?.open){ conn.__sending = false; return; }
      conn.__sending = true;

      const dc = getDataChannel(conn);
      const buffered = dc?.bufferedAmount || 0;

      if (buffered > NET_MAX_BUFFER){
        setTimeout(()=>processSendQueue(conn), 60);
        return;
      }

      const item = conn.__sendQueue?.shift();
      if (!item){
        conn.__sending = false;
        return;
      }

      try{
        conn.send(item);
      }catch(e){
        console.warn("send fail", e);
        conn.__sendQueue = [];
        conn.__sending = false;
        return;
      }

      setTimeout(()=>processSendQueue(conn), NET_TICK_MS);
    }

    function gcChunks(){
      const t = nowMs();
      let expiredAny = false;
      for (const [k,v] of chunkInbox.entries()){
        if ((t - (v.ts||0)) > CHUNK_TTL_MS){
          chunkInbox.delete(k);
          expiredAny = true;
        }
      }
      if (expiredAny && !isHost && hostConnection?.open){
        requestResync("chunk-timeout");
      }
    }

    function requestResync(reason=""){
      const now = Date.now();
      if (now - lastResyncAt < 1500) return; // debouce
      lastResyncAt = now;
      if (hostConnection?.open){
        enqueueSend(hostConnection, {kind:"RESYNC", sender:myId, reason});
      }
    }

    function sendNet(conn, obj){
      if (!conn?.open) return;
      const json = safeJsonStringify(obj);
      if (!json) return;

      // pequeno? manda direto (em fila)
      if (json.length <= NET_CHUNK_SIZE){
        enqueueSend(conn, obj);
        return;
      }

      // grande? chunk em fila
      const msgId = generateUUID();
      const total = Math.ceil(json.length / NET_CHUNK_SIZE);

      for (let i=0;i<total;i++){
        const part = json.slice(i*NET_CHUNK_SIZE, (i+1)*NET_CHUNK_SIZE);
        enqueueSend(conn, { kind:"CHUNK", msgId, index:i, total, part });
      }
    }

    function broadcastNet(obj){
      if (!isHost) return;
      connections.forEach(c=>sendNet(c, obj));
    }

    function onNetData(data, connPeerId=null){
      gcChunks();

      // Host: last seen
      if (isHost && connPeerId){
        const c = clients.get(connPeerId);
        if (c) c.lastSeen = Date.now();
      }

      if (typeof data === "string"){
        const parsed = safeJsonParse(data);
        if (parsed) data = parsed;
        else return;
      }

      if (!data?.kind) return;

      if (data.kind === "CHUNK"){
        const { msgId, index, total, part } = data;
        if (!msgId || !Number.isFinite(index) || !Number.isFinite(total) || typeof part !== "string") return;

        let entry = chunkInbox.get(msgId);
        if (!entry){
          entry = { total, parts: new Array(total), ts: nowMs() };
          chunkInbox.set(msgId, entry);
        }
        entry.ts = nowMs();
        if (entry.total !== total) { chunkInbox.delete(msgId); return; }
        entry.parts[index] = part;

        if (entry.parts.every(p => typeof p === "string")){
          const full = entry.parts.join("");
          chunkInbox.delete(msgId);
          const parsed = safeJsonParse(full);
          if (parsed) handleNetworkData(parsed, connPeerId);
          else if (!isHost && hostConnection?.open) requestResync("chunk-parse-fail");
        }
        return;
      }

      handleNetworkData(data, connPeerId);
    }

    // ===== SISTEMA DE CAMADAS =====
    const layerState = { visible: {}, locked: {} };

    function ensureLayerDefaults(layer){
      if (layer == null) return;
      if (!(layer in layerState.visible)) layerState.visible[layer] = true;
      if (!(layer in layerState.locked)) layerState.locked[layer] = false;
    }

    function computeTokenZIndex(layer){
      const base = 100;
      const l = Number(layer || 1);
      return base + (l * 10);
    }

    function applyLayerVisibilityToDOM(){
      document.querySelectorAll('.token').forEach(t=>{
        const layer = Number(t.dataset.layer || 1);
        ensureLayerDefaults(layer);
        const vis = !!layerState.visible[layer];
        t.style.display = vis ? "" : "none";
      });
    }

    function toggleLayersPanel(){
      if (!isHost) return alert("Apenas o Host gerencia camadas.");
      layersPanel.classList.toggle('show');
      rebuildLayersPanel();
    }

    function rebuildLayersPanel(){
      if (!isHost) return;

      const layers = new Set();
      Object.values(state.tokens).forEach(t => layers.add(Number(t.layer || 1)));
      const maxLayer = layers.size ? Math.max(...Array.from(layers)) : 3;

      layersList.innerHTML = "";

      for (let l=1; l<=Math.max(maxLayer,3); l++){
        ensureLayerDefaults(l);

        const row = document.createElement('div');
        row.className = "layer-row";

        const left = document.createElement('div');
        left.innerHTML = `<b>Layer ${l}</b> <span style="font-size:10px;opacity:.7;">(tokens)</span>`;

        const actions = document.createElement('div');
        actions.className = "layer-actions";

        const vis = document.createElement('div');
        vis.className = "pill " + (layerState.visible[l] ? "active" : "");
        vis.innerText = layerState.visible[l] ? "Vis√≠vel" : "Oculta";
        vis.onclick = () => {
          layerState.visible[l] = !layerState.visible[l];
          const action = { type:"LAYER_SET", layer:l, prop:"visible", value: layerState.visible[l] };
          applyAction(action,false);
          broadcastACT(action);
          rebuildLayersPanel();
          applyLayerVisibilityToDOM();
        };

        const lock = document.createElement('div');
        lock.className = "pill " + (layerState.locked[l] ? "active" : "");
        lock.innerText = layerState.locked[l] ? "Trancada" : "Livre";
        lock.onclick = () => {
          layerState.locked[l] = !layerState.locked[l];
          const action = { type:"LAYER_SET", layer:l, prop:"locked", value: layerState.locked[l] };
          applyAction(action,false);
          broadcastACT(action);
          rebuildLayersPanel();
        };

        actions.appendChild(vis);
        actions.appendChild(lock);

        row.appendChild(left);
        row.appendChild(actions);
        layersList.appendChild(row);
      }
    }

    // ===== ESTADO (Host autoritativo) =====
    const state = {
      map: { src:null, locked:false, x:0, y:0 },
      tokens: {}
    };

    // ===== UI =====
    function toggleHUD(){ document.body.classList.toggle('hud-hidden'); }
    function toggleSidebar(){ sidebar.classList.toggle('open'); }
    function toggleGrid(){ gridLayer.style.display = (gridLayer.style.display === 'none') ? 'block' : 'none'; }
    function toggleNetworkPanel(){ networkPanel.classList.toggle('show'); }

    function closePlayersPanel(){ playersPanel.classList.remove('show'); }
    function togglePlayersPanel(){
      if (!isHost) return alert("Apenas o Host v√™ jogadores.");
      // evita overlap visual com biblioteca (opcional)
      libraryPanel.classList.remove('show');
      playersPanel.classList.toggle('show');
      renderPlayersPanel();
    }

    function setRoleUI(){
      roleText.textContent = isHost ? "HOST (Mestre)" : "PLAYER";

      hostOnlyMap.style.display = isHost ? "" : "none";
      hostOnlyPlayers.style.display = isHost ? "" : "none";
      hostOnlyAssets.style.display = isHost ? "" : "none";
      hostOnlyClear.style.display = isHost ? "" : "none";

      btnLockAll.style.display = isHost ? "" : "none";
      btnLockMap.style.display = isHost ? "" : "none";
      btnInvite.style.display = isHost ? "" : "none";
      btnD20.style.display = isHost ? "" : "none";
      btnD6.style.display = isHost ? "" : "none";
      btnSaveScene.style.display = isHost ? "" : "none";
      btnLibrary.style.display = isHost ? "" : "none";
      btnLayers.style.display = isHost ? "" : "none";
      btnPlayers.style.display = isHost ? "" : "none";
      scenePanel.style.display = isHost ? "" : "none";
      layersPanel.style.display = isHost ? "" : "none";
      libraryPanel.style.display = isHost ? "" : "none";
      playersPanel.style.display = "none";
    }

    // ===== Painel de Jogadores (Host) =====
    function prettySince(ms){
      const s = Math.max(0, Math.round(ms/1000));
      if (s < 60) return `${s}s`;
      const m = Math.round(s/60);
      return `${m}m`;
    }

    function renderPlayersPanel(){
      if (!isHost) return;
      const arr = Array.from(clients.values()).sort((a,b)=> (b.joinedAt||0)-(a.joinedAt||0));

      playersListEl.innerHTML = "";
      arr.forEach(c=>{
        const row = document.createElement("div");
        row.className = "player-row";

        const top = document.createElement("div");
        top.className = "player-top";

        const left = document.createElement("div");
        left.className = "player-id";
        left.textContent = c.id;

        const dot = document.createElement("div");
        dot.className = "status-dot " + (c.conn?.open ? "online" : "");
        dot.title = c.conn?.open ? "Online" : "Offline";

        top.appendChild(left);
        top.appendChild(dot);

        const meta = document.createElement("div");
        meta.className = "player-meta";
        const rtt = (c.rtt==null) ? "‚Äî" : `${Math.round(c.rtt)}ms`;
        const last = c.lastSeen ? prettySince(Date.now()-c.lastSeen) : "‚Äî";
        const synced = c.synced ? "SIM" : "N√ÉO";

        meta.innerHTML = `
          <span class="mini-badge">Ping: ${rtt}</span>
          <span class="mini-badge">Last: ${last}</span>
          <span class="mini-badge">Synced: ${synced}</span>
        `;

        const actions = document.createElement("div");
        actions.className = "player-actions";

        const btnRes = document.createElement("button");
        btnRes.textContent = "Re-sync";
        btnRes.onclick = ()=>{ if (c.conn?.open) sendSYNC(c.conn); };

        const btnPing = document.createElement("button");
        btnPing.textContent = "Ping";
        btnPing.onclick = ()=>{ if (c.conn?.open) pingClient(c.id); };

        const btnKick = document.createElement("button");
        btnKick.textContent = "Kick";
        btnKick.className = "kick";
        btnKick.onclick = ()=>kickClient(c.id);

        actions.appendChild(btnPing);
        actions.appendChild(btnRes);
        actions.appendChild(btnKick);

        row.appendChild(top);
        row.appendChild(meta);
        row.appendChild(actions);
        playersListEl.appendChild(row);
      });

      playersCountEl.textContent = `${arr.filter(x=>x.conn?.open).length} online`;
    }

    function registerClient(conn){
      clients.set(conn.peer, {
        id: conn.peer,
        conn,
        joinedAt: Date.now(),
        lastSeen: Date.now(),
        rtt: null,
        synced: false
      });
      renderPlayersPanel();
      showNotification(`Player conectou: ${conn.peer}`);
    }

    function unregisterClient(peerId){
      clients.delete(peerId);
      renderPlayersPanel();
    }

    function kickClient(peerId){
      if (!isHost) return;
      const c = clients.get(peerId);
      if (!c) return;
      try{ c.conn?.close(); }catch{}
      unregisterClient(peerId);
      showNotification(`Kick: ${peerId}`);
    }

    function pingClient(peerId){
      if (!isHost) return;
      const c = clients.get(peerId);
      if (!c?.conn?.open) return;
      const t = Date.now();
      c.__pingSentAt = t;
      sendNet(c.conn, {kind:"PING", sender:myId, t});
      renderPlayersPanel();
    }

    function pingAll(){
      if (!isHost) return;
      clients.forEach((c)=>{ if (c.conn?.open) pingClient(c.id); });
    }

    function resyncAll(){
      if (!isHost) return;
      clients.forEach((c)=>{ if (c.conn?.open) sendSYNC(c.conn); });
      showNotification("Re-sync enviado!");
    }

    let hostPingInterval = null;
    function startHostPinger(){
      if (!isHost) return;
      if (hostPingInterval) clearInterval(hostPingInterval);
      hostPingInterval = setInterval(()=>{
        clients.forEach((c)=>{ if (c.conn?.open) pingClient(c.id); });
      }, 8000);
    }

    // ===== Convite =====
    function copyInviteLink(){
      if (!myId) return alert("Aguarde a conex√£o...");
      if (!isHost) return alert("Apenas o Host copia convite.");
      const u = new URL(window.location.href);
      u.searchParams.set('room', myId);
      const invite = u.toString();

      if (navigator.clipboard?.writeText){
        navigator.clipboard.writeText(invite).then(()=>showNotification("Link copiado!")).catch(()=>prompt("Copie:", invite));
      } else prompt("Copie:", invite);
    }

    // ===== PAN/ZOOM viewport =====
    viewport.addEventListener('wheel',(e)=>{
      if (e.ctrlKey) return;
      e.preventDefault();
      const zoomSpeed=.15;
      const delta = e.deltaY>0 ? -zoomSpeed : zoomSpeed;
      const newScale = Math.min(Math.max(.05, scale+delta), 4);

      const mx=e.clientX,my=e.clientY;
      const cx=(mx-posX)/scale, cy=(my-posY)/scale;

      scale = newScale;
      posX = mx - cx*scale;
      posY = my - cy*scale;
      updateTransform();
    },{passive:false});

    window.addEventListener('mousedown',(e)=>{
      if (e.button===2 || e.button===1 || (e.button===0 && e.altKey)){
        isPanning=true;
        startPan={x:e.clientX-posX,y:e.clientY-posY};
        viewport.style.cursor='grabbing';
      }
    });
    window.addEventListener('mousemove',(e)=>{
      if (isPanning){
        posX=e.clientX-startPan.x;
        posY=e.clientY-startPan.y;
        updateTransform();
      }
    });
    window.addEventListener('mouseup',()=>{ isPanning=false; viewport.style.cursor='grab'; });

    // ===== MAPA ‚ÄúPALP√ÅVEL‚Äù COM IN√âRCIA =====
    let mapDragging=false;
    let mapDragStart={mx:0,my:0,x:0,y:0};
    let mapVel={vx:0,vy:0};
    let mapLastMove={t:0,x:0,y:0};
    let mapInertiaRAF=null;

    function setMapLockLocal(lock, emit){
      state.map.locked = !!lock;
      if (state.map.locked) mapContainer.classList.add('locked');
      else mapContainer.classList.remove('locked');

      if (state.map.locked) {
        btnLockMap.innerHTML="üîí Mapa Fixo"; btnLockMap.classList.add('active');
      } else {
        btnLockMap.innerHTML="üîì Mapa M√≥vel"; btnLockMap.classList.remove('active');
      }

      if (emit){
        if (!isHost) return;
        const action = { type:"MAP_LOCK", locked: state.map.locked };
        applyAction(action,false);
        broadcastACT(action);
      }
    }

    function toggleMapLock(){
      if (!isHost) return;
      setMapLockLocal(!state.map.locked, true);
    }

    function setMapOffset(x, y){
      state.map.x = x;
      state.map.y = y;
      mapContainer.style.transform = `translate(${x}px, ${y}px)`;
    }

    function stopMapInertia(){
      if (mapInertiaRAF) cancelAnimationFrame(mapInertiaRAF);
      mapInertiaRAF = null;
    }

    function startMapInertia(){
      stopMapInertia();
      const friction = 0.92;
      const minV = 0.05;

      const step = () => {
        mapVel.vx *= friction;
        mapVel.vy *= friction;

        if (Math.abs(mapVel.vx) < minV && Math.abs(mapVel.vy) < minV) {
          mapVel.vx = 0; mapVel.vy = 0;
          stopMapInertia();

          if (isHost){
            const action = { type:"MAP_MOVE", x: state.map.x, y: state.map.y };
            applyAction(action,false);
            broadcastACT(action);
          }
          return;
        }

        setMapOffset(state.map.x + mapVel.vx, state.map.y + mapVel.vy);
        mapInertiaRAF = requestAnimationFrame(step);
      };

      mapInertiaRAF = requestAnimationFrame(step);
    }

    function setupMapDrag(){
      mapContainer.addEventListener('mousedown', (e)=>{
        if (!isHost) return;
        if (state.map.locked) return;
        const img = mapContainer.querySelector('img');
        if (!img) return;

        if (e.button !== 0 || e.altKey) return;
        e.preventDefault();
        e.stopPropagation();

        mapDragging = true;
        mapContainer.classList.add('dragging');
        stopMapInertia();

        mapDragStart = { mx:e.clientX, my:e.clientY, x:state.map.x, y:state.map.y };
        mapVel = { vx:0, vy:0 };
        mapLastMove = { t: performance.now(), x: state.map.x, y: state.map.y };

        const onMove = (me) => {
          if (!mapDragging) return;

          const dx = (me.clientX - mapDragStart.mx) / scale;
          const dy = (me.clientY - mapDragStart.my) / scale;

          const nx = mapDragStart.x + dx;
          const ny = mapDragStart.y + dy;
          setMapOffset(nx, ny);

          const now = performance.now();
          const dt = Math.max(1, now - mapLastMove.t);
          mapVel.vx = (nx - mapLastMove.x) / dt * 16;
          mapVel.vy = (ny - mapLastMove.y) / dt * 16;
          mapLastMove = { t: now, x: nx, y: ny };
        };

        const onUp = () => {
          mapDragging = false;
          mapContainer.classList.remove('dragging');
          document.removeEventListener('mousemove', onMove);
          document.removeEventListener('mouseup', onUp);

          startMapInertia();

          const action = { type:"MAP_MOVE", x: state.map.x, y: state.map.y };
          applyAction(action,false);
          broadcastACT(action);
        };

        document.addEventListener('mousemove', onMove);
        document.addEventListener('mouseup', onUp);
      });
    }
    setupMapDrag();

    function applyMapLocal(src, emit){
      const img = new Image();
      img.onload = () => {
        mapContainer.innerHTML = "";
        mapContainer.appendChild(img);

        scale = Math.min(window.innerWidth / img.width, window.innerHeight / img.height, 1) * 0.8;
        posX = window.innerWidth/2 - (img.width * scale)/2;
        posY = window.innerHeight/2 - (img.height * scale)/2;
        updateTransform();

        setMapOffset(state.map.x || 0, state.map.y || 0);
      };
      img.onerror = () => {
        showNotification("Falha ao carregar mapa (URL sem acesso?)");
      };
      img.src = src;

      if (emit){
        if (!isHost) return;
        const action = { type:"MAP_UPDATE", src };
        applyAction(action,false);
        broadcastACT(action);
      }
    }

    // ===== TOKENS =====
    function normalizeTokenProps(id, src, type, props){
      const p = props || {};
      const layer = Number(p.layer ?? 2);
      ensureLayerDefaults(layer);
      return {
        id,
        src,
        type,
        kind: p.kind ?? "asset",
        layer,
        x: p.x ?? "0px",
        y: p.y ?? "0px",
        w: p.w ?? 140,
        h: p.h ?? 140,
        rotation: p.rotation ?? 0,
        flipped: p.flipped ?? "false",
        innerZoom: p.innerZoom ?? 1,
        locked: p.locked ?? "false",
        fitMode: p.fitMode ?? "contain"
      };
    }

    function hostCreateToken(src, contentType, kind){
      if (!isHost) return;

      const id = generateUUID();

      const isImg = contentType === "image";
      let width = isImg ? 160 : 400;
      let height = isImg ? 160 : 225;

      const layerDefault = (kind === "player") ? 3 : 2;

      const centerX = (window.innerWidth/2 - posX)/scale;
      const centerY = (window.innerHeight/2 - posY)/scale;

      const props = {
        kind,
        layer: layerDefault,
        x: (centerX - width/2) + "px",
        y: (centerY - height/2) + "px",
        w: width,
        h: height,
        rotation: 0,
        flipped: "false",
        innerZoom: 1,
        locked: "false",
        fitMode: "contain"
      };

      const action = { type:"CREATE_TOKEN", id, src, contentType, props };
      applyAction(action,false);
      broadcastACT(action);

      rebuildLayersPanel();
      applyLayerVisibilityToDOM();
      updateSceneSizeEstimate();
    }

    function addTokenLocal(src, contentType, id, props){
      if (document.getElementById(`token-${id}`)) return;

      const token = document.createElement('div');
      token.id = `token-${id}`;
      token.className = "token";
      token.dataset.uuid = id;
      token.dataset.type = contentType;

      const layer = Number(props?.layer ?? 2);
      const kind = props?.kind ?? "asset";
      ensureLayerDefaults(layer);

      token.dataset.layer = String(layer);
      token.dataset.kind = kind;

      token.style.zIndex = String(computeTokenZIndex(layer));

      const width = props?.w ? parseInt(props.w) : (contentType==="web"?400:160);
      const height = props?.h ? parseInt(props.h) : (contentType==="web"?225:160);
      token.style.width = width + "px";
      token.style.height = height + "px";

      const x = props?.x ?? "0px";
      const y = props?.y ?? "0px";
      token.style.left = x;
      token.style.top = y;

      token.dataset.sizeW = width;
      token.dataset.sizeH = height;
      token.dataset.rotation = props?.rotation ?? 0;
      token.dataset.flipped = props?.flipped ?? "false";
      token.dataset.innerZoom = props?.innerZoom ?? 1;
      token.dataset.locked = props?.locked ?? "false";
      token.dataset.fitMode = props?.fitMode ?? "contain";

      if (token.dataset.locked === "true"){
        token.classList.add('locked');
        token.style.pointerEvents = "none";
      }

      const blocker = document.createElement('div');
      blocker.className = "token-blocker";

      const wrapper = document.createElement('div');
      wrapper.className = "token-content-wrapper";

      let content;
      if (contentType === "image"){
        content = document.createElement('img');
        content.src = src;
        content.onerror = ()=>showNotification("Falha ao carregar token (URL sem acesso?)");
      } else {
        content = document.createElement('iframe');
        content.src = src;
        content.setAttribute('frameborder','0');
        content.setAttribute('sandbox','allow-scripts allow-same-origin');
      }

      const handle = document.createElement('div');
      handle.className = "resize-handle";

      const controls = document.createElement('div');
      controls.className = "token-controls";
      controls.innerHTML = `
        <span class="token-btn" title="Layer -" onclick="layerToken(event, -1)">üß±‚ûñ</span>
        <span class="token-btn" title="Layer +" onclick="layerToken(event, 1)">üß±‚ûï</span>
        <span class="token-btn" title="Tamanho -" onclick="scaleToken(event, -40)">üìè‚ûñ</span>
        <span class="token-btn" title="Tamanho +" onclick="scaleToken(event, 40)">üìè‚ûï</span>
        <span class="token-btn" title="Zoom Interno -" onclick="zoomInnerToken(event, -0.1)">‚ûñ</span>
        <span class="token-btn" title="Zoom Interno +" onclick="zoomInnerToken(event, 0.1)">‚ûï</span>
        <span class="token-btn" title="Fit" onclick="fitToken(event)">üß©</span>
        <span class="token-btn" title="Reset" onclick="resetToken(event)">‚ôªÔ∏è</span>
        <span class="token-btn" title="Espelhar (F)" onclick="flipToken(this.closest('.token'))">‚ÜîÔ∏è</span>
        <span class="token-btn" title="Girar 45¬∞" onclick="rotateToken(event, 45)">üîÑ</span>
        <span class="token-btn" title="Trancar" onclick="lockToken(event)">üîí</span>
        <span class="token-btn text-red-400" title="Eliminar" onclick="deleteToken(event)">üóëÔ∏è</span>
      `;

      wrapper.appendChild(content);
      token.appendChild(blocker);
      token.appendChild(wrapper);
      token.appendChild(handle);
      token.appendChild(controls);
      canvas.appendChild(token);

      setTimeout(()=>updateImgTransform(token),10);

      const vis = !!layerState.visible[layer];
      token.style.display = vis ? "" : "none";

      token.addEventListener('wheel',(e)=>{
        if (!e.ctrlKey) return;
        if (token.dataset.locked === "true") return;
        if (layerState.locked[Number(token.dataset.layer||2)]) return;

        e.preventDefault(); e.stopPropagation();
        const delta = e.deltaY>0 ? -20 : 20;

        const startW = parseInt(token.dataset.sizeW);
        const startH = parseInt(token.dataset.sizeH);
        const ratio = startH/startW;
        const newW = Math.max(40, Math.min(startW + delta, 2500));
        const newH = Math.max(40, Math.min(newW * ratio, 2500));

        const action = { type:"UPDATE_PROP", id: token.dataset.uuid, prop:"size", value:{w:newW,h:newH} };
        if (isHost){ applyAction(action,false); broadcastACT(action); }
        else sendREQ(action);

        updateSceneSizeEstimate();
      },{passive:false});

      handle.addEventListener('mousedown',(e)=>{
        if (token.dataset.locked === "true") return;
        if (layerState.locked[Number(token.dataset.layer||2)]) return;
        if (e.button!==0) return;

        e.stopPropagation(); e.preventDefault();
        const startX=e.clientX;
        const startW=parseInt(token.dataset.sizeW);
        const startH=parseInt(token.dataset.sizeH);
        const ratio=startH/startW;

        let pendingW=startW, pendingH=startH;

        function onMove(me){
          const deltaW=((me.clientX-startX)/scale)*1.5;
          let w=Math.max(40, Math.min(startW+deltaW, 2500));
          let h=Math.max(40, Math.min(w*ratio, 2500));
          pendingW=Math.round(w); pendingH=Math.round(h);
          token.dataset.sizeW=pendingW; token.dataset.sizeH=pendingH;
          token.style.width=pendingW+"px"; token.style.height=pendingH+"px";
        }
        function onUp(){
          document.removeEventListener('mousemove',onMove);
          document.removeEventListener('mouseup',onUp);
          const action={ type:"UPDATE_PROP", id:token.dataset.uuid, prop:"size", value:{w:pendingW,h:pendingH} };
          if (isHost){ applyAction(action,false); broadcastACT(action); }
          else sendREQ(action);
          updateSceneSizeEstimate();
        }
        document.addEventListener('mousemove',onMove);
        document.addEventListener('mouseup',onUp);
      });

      token.addEventListener('mousedown',(e)=>{
        if (e.button!==0 || e.altKey) return;
        if (token.dataset.locked==="true") return;
        if (layerState.locked[Number(token.dataset.layer||2)]) return;
        e.stopPropagation();
        selectToken(token);
        startDraggingToken(e, token);
      });
    }

    function updateImgTransform(token){
      const el = token.querySelector('img') || token.querySelector('iframe');
      if (!el) return;

      if (el.tagName === "IMG"){
        el.style.objectFit = token.dataset.fitMode || "contain";
      }
      const rotation = token.dataset.rotation || 0;
      const flipped = token.dataset.flipped === "true";
      const innerZoom = token.dataset.innerZoom || 1;
      el.style.transform = `scale(${innerZoom}) rotate(${rotation}deg) scaleX(${flipped?-1:1})`;
    }

    function selectToken(token){
      if (selectedToken) selectedToken.classList.remove('selected');
      selectedToken = token;
      selectedToken.classList.add('selected');
    }

    function startDraggingToken(e, token){
      let startX=e.clientX, startY=e.clientY;
      let initialLeft=parseFloat(token.style.left);
      let initialTop=parseFloat(token.style.top);
      let moved=false;

      function onMove(me){
        moved=true;
        let dx=(me.clientX-startX)/scale;
        let dy=(me.clientY-startY)/scale;
        let newX=initialLeft+dx;
        let newY=initialTop+dy;
        if (gridLayer.style.display !== 'none'){
          newX=Math.round(newX/50)*50;
          newY=Math.round(newY/50)*50;
        }
        token.style.left=newX+"px";
        token.style.top=newY+"px";
      }

      function onUp(){
        document.removeEventListener('mousemove',onMove);
        document.removeEventListener('mouseup',onUp);
        if (!moved) return;

        const id=token.dataset.uuid;
        const action={ type:"MOVE", id, x:token.style.left, y:token.style.top };

        if (isHost){ applyAction(action,false); broadcastACT(action); }
        else sendREQ(action);

        updateSceneSizeEstimate();
      }

      document.addEventListener('mousemove',onMove);
      document.addEventListener('mouseup',onUp);
    }

    function moveTokenDOM(id,x,y){
      const t=document.getElementById(`token-${id}`);
      if (!t) return;
      t.style.left=x; t.style.top=y;
    }

    function updateTokenPropDOM(id, prop, value){
      const token=document.getElementById(`token-${id}`);
      if (!token) return;

      if (prop==="locked"){
        token.dataset.locked = String(value);
        if (String(value)==="true"){
          token.classList.add('locked');
          token.style.pointerEvents="none";
          token.classList.remove('selected');
          if (selectedToken && selectedToken.dataset.uuid===id) selectedToken=null;
        } else {
          token.classList.remove('locked');
          token.style.pointerEvents="auto";
        }
      } else if (prop==="innerZoom"){
        token.dataset.innerZoom=value; updateImgTransform(token);
      } else if (prop==="rotation"){
        token.dataset.rotation=value; updateImgTransform(token);
      } else if (prop==="flipped"){
        token.dataset.flipped=value; updateImgTransform(token);
      } else if (prop==="fitMode"){
        token.dataset.fitMode=value; updateImgTransform(token);
      } else if (prop==="size"){
        token.style.width=value.w+"px";
        token.style.height=value.h+"px";
        token.dataset.sizeW=value.w;
        token.dataset.sizeH=value.h;
      } else if (prop==="layer"){
        const newLayer = Number(value);
        ensureLayerDefaults(newLayer);
        token.dataset.layer = String(newLayer);
        token.style.zIndex = String(computeTokenZIndex(newLayer));
        const vis = !!layerState.visible[newLayer];
        token.style.display = vis ? "" : "none";
      }

      updateSceneSizeEstimate();
    }

    function removeTokenLocal(id){
      const t=document.getElementById(`token-${id}`);
      if (t) t.remove();
      if (selectedToken && selectedToken.dataset.uuid===id) selectedToken=null;
    }

    // ===== A√á√ïES DE TOKEN (UI) =====
    window.lockToken = (e)=>{
      e.stopPropagation();
      const token=e.target.closest('.token');
      if (!token) return;
      if (!isHost) return;
      const id=token.dataset.uuid;
      const action={ type:"UPDATE_PROP", id, prop:"locked", value:"true" };
      applyAction(action,false); broadcastACT(action);
      updateSceneSizeEstimate();
    };

    window.deleteToken = (e)=>{
      e.stopPropagation();
      const token=e.target.closest('.token');
      if (!token) return;
      if (!isHost) return;
      const id=token.dataset.uuid;
      const action={ type:"REMOVE_TOKEN", id };
      applyAction(action,false); broadcastACT(action);
      updateSceneSizeEstimate();
    };

    window.zoomInnerToken = (e, delta)=>{
      e.stopPropagation();
      const token=e.target.closest('.token'); if (!token) return;
      if (token.dataset.locked==="true") return;
      if (layerState.locked[Number(token.dataset.layer||2)]) return;

      let z=parseFloat(token.dataset.innerZoom||1);
      z=Math.max(.2, Math.min(5, z+delta));

      const action={ type:"UPDATE_PROP", id:token.dataset.uuid, prop:"innerZoom", value:z };
      if (isHost){ applyAction(action,false); broadcastACT(action); }
      else sendREQ(action);
      updateSceneSizeEstimate();
    };

    window.flipToken = (token)=>{
      if (!token) return;
      if (token.dataset.locked==="true") return;
      if (layerState.locked[Number(token.dataset.layer||2)]) return;

      const newVal = token.dataset.flipped==="false" ? "true" : "false";
      const action={ type:"UPDATE_PROP", id:token.dataset.uuid, prop:"flipped", value:newVal };
      if (isHost){ applyAction(action,false); broadcastACT(action); }
      else sendREQ(action);
      updateSceneSizeEstimate();
    };

    window.rotateToken = (e, deg)=>{
      e.stopPropagation();
      const token=e.target.closest('.token'); if (!token) return;
      if (token.dataset.locked==="true") return;
      if (layerState.locked[Number(token.dataset.layer||2)]) return;

      const newVal = (parseInt(token.dataset.rotation||0)+deg)%360;
      const action={ type:"UPDATE_PROP", id:token.dataset.uuid, prop:"rotation", value:newVal };
      if (isHost){ applyAction(action,false); broadcastACT(action); }
      else sendREQ(action);
      updateSceneSizeEstimate();
    };

    window.fitToken = (e)=>{
      e.stopPropagation();
      const token=e.target.closest('.token'); if (!token) return;
      if (token.dataset.locked==="true") return;
      if (layerState.locked[Number(token.dataset.layer||2)]) return;

      const id=token.dataset.uuid;
      const a1={ type:"UPDATE_PROP", id, prop:"innerZoom", value:1 };
      const a2={ type:"UPDATE_PROP", id, prop:"fitMode", value:"contain" };
      if (isHost){ applyAction(a1,false); broadcastACT(a1); applyAction(a2,false); broadcastACT(a2); }
      else { sendREQ(a1); sendREQ(a2); }
    };

    window.resetToken = (e)=>{
      e.stopPropagation();
      const token=e.target.closest('.token'); if (!token) return;
      if (token.dataset.locked==="true") return;
      if (layerState.locked[Number(token.dataset.layer||2)]) return;

      const id=token.dataset.uuid;
      const acts=[
        { type:"UPDATE_PROP", id, prop:"innerZoom", value:1 },
        { type:"UPDATE_PROP", id, prop:"rotation", value:0 },
        { type:"UPDATE_PROP", id, prop:"flipped", value:"false" },
        { type:"UPDATE_PROP", id, prop:"fitMode", value:"contain" }
      ];
      if (isHost) acts.forEach(a=>{ applyAction(a,false); broadcastACT(a); });
      else acts.forEach(a=>sendREQ(a));
    };

    window.scaleToken = (e, deltaW)=>{
      e.stopPropagation();
      const token=e.target.closest('.token'); if (!token) return;
      if (token.dataset.locked==="true") return;
      if (layerState.locked[Number(token.dataset.layer||2)]) return;

      const w0=parseInt(token.dataset.sizeW), h0=parseInt(token.dataset.sizeH);
      const ratio=h0/w0;
      let w=Math.max(40, Math.min(2500, w0+deltaW));
      let h=Math.max(40, Math.min(2500, Math.round(w*ratio)));

      const action={ type:"UPDATE_PROP", id:token.dataset.uuid, prop:"size", value:{w,h} };
      if (isHost){ applyAction(action,false); broadcastACT(action); }
      else sendREQ(action);
      updateSceneSizeEstimate();
    };

    window.layerToken = (e, delta)=>{
      e.stopPropagation();
      const token=e.target.closest('.token'); if (!token) return;
      if (token.dataset.locked==="true") return;

      const cur = Number(token.dataset.layer||2);
      const next = Math.max(1, cur + delta);
      ensureLayerDefaults(next);

      const action={ type:"UPDATE_PROP", id:token.dataset.uuid, prop:"layer", value: next };
      if (isHost){ applyAction(action,false); broadcastACT(action); rebuildLayersPanel(); applyLayerVisibilityToDOM(); }
      else sendREQ(action);
      updateSceneSizeEstimate();
    };

    // ===== Keyboard =====
    window.addEventListener('keydown',(e)=>{
      if (!selectedToken) return;
      if (selectedToken.dataset.locked==="true") return;
      if (layerState.locked[Number(selectedToken.dataset.layer||2)]) return;

      if (e.key.toLowerCase()==='f') flipToken(selectedToken);
      if (e.key==='Delete'){
        if (!isHost) return;
        const id=selectedToken.dataset.uuid;
        const action={ type:"REMOVE_TOKEN", id };
        applyAction(action,false); broadcastACT(action);
        selectedToken=null;
        updateSceneSizeEstimate();
      }
    });

    viewport.addEventListener('mousedown',(e)=>{
      if (e.target===viewport || e.target===canvas || e.target===gridLayer){
        if (selectedToken) selectedToken.classList.remove('selected');
        selectedToken=null;
      }
    });

    // ===== DADOS / LOG =====
    function rollDice(faces){
      if (!isHost) return;
      const res=Math.floor(Math.random()*faces)+1;
      const action={ type:"DICE", faces, result:res };
      applyAction(action,false); broadcastACT(action);
    }
    function showDiceLog(faces,res){
      const entry=document.createElement('div');
      entry.className="dice-entry mb-2 border-l-2 border-gold pl-3 opacity-0 transform translate-x-4 transition-all duration-300";
      entry.innerHTML=`<span class="opacity-50 text-[10px] font-bold">D${faces}:</span> <b class="text-white text-lg">${res}</b>`;
      diceLogEntries.prepend(entry);
      setTimeout(()=>entry.classList.remove('opacity-0','translate-x-4'),10);
    }

    // ===== IMPORT + compress local =====
    function isImageUrl(url){
      return (url.match(/\.(jpeg|jpg|gif|png|webp|avif)$/i)!=null) || url.startsWith('data:image');
    }

    function byteLengthOfString(str){ return new Blob([str]).size; }

    async function compressDataURLToWebP(dataUrl, maxDim, quality){
      try{
        const resp=await fetch(dataUrl);
        const blob=await resp.blob();
        if(!blob.type.startsWith("image/")) return null;

        const bmp=await createImageBitmap(blob);
        const w=bmp.width,h=bmp.height;
        const s=Math.min(1, maxDim/Math.max(w,h));
        const nw=Math.max(1,Math.round(w*s));
        const nh=Math.max(1,Math.round(h*s));
        const c=document.createElement('canvas');
        c.width=nw; c.height=nh;
        const ctx=c.getContext('2d',{alpha:true});
        ctx.drawImage(bmp,0,0,nw,nh);
        const outBlob=await new Promise(res=>c.toBlob(res,"image/webp",quality));
        if(!outBlob) return null;

        return await new Promise((resolve,reject)=>{
          const r=new FileReader();
          r.onload=()=>resolve(r.result);
          r.onerror=reject;
          r.readAsDataURL(outBlob);
        });
      }catch{
        return null;
      }
    }

    async function maybeCompressLocalDataUrl(dataUrl){
      const bytes = byteLengthOfString(dataUrl);
      if (bytes < 450000) return dataUrl;
      const maxDim = parseInt(document.getElementById('max-dim')?.value || "2048", 10);
      const quality = parseFloat(document.getElementById('quality')?.value || "0.78");
      const webp = await compressDataURLToWebP(dataUrl, maxDim, quality);
      return webp || dataUrl;
    }

    function importFromUrl(inputId, type){
      if (!isHost) return alert("Apenas o Host importa.");
      const url=document.getElementById(inputId).value.trim();
      if (!url) return;

      if (type==="map"){
        if (!isImageUrl(url)) return alert("Mapa precisa ser imagem direta.");
        applyMapLocal(url,true);
        addToLibrary("maps", url);
        document.getElementById(inputId).value="";
        updateSceneSizeEstimate();
        return;
      }

      if (!isImageUrl(url)) return alert("Tokens/Assets precisam ser imagens diretas.");

      if (type==="player"){
        hostCreateToken(url,"image","player");
        addToLibrary("players", url);
      } else if (type==="asset"){
        hostCreateToken(url,"image","asset");
        addToLibrary("assets", url);
      }
      document.getElementById(inputId).value="";
      rebuildLayersPanel();
      applyLayerVisibilityToDOM();
      updateSceneSizeEstimate();
    }

    async function importAsset(event, type){
      if (!isHost) return alert("Apenas o Host importa.");
      const file=event.target.files?.[0];
      if (!file) return;

      const reader=new FileReader();
      reader.onload=async (e)=>{
        let dataUrl=e.target.result;
        dataUrl = await maybeCompressLocalDataUrl(dataUrl);

        if (type==="map"){
          applyMapLocal(dataUrl,true);
          addToLibrary("maps", dataUrl, "mapa-local");
        } else if (type==="player"){
          hostCreateToken(dataUrl,"image","player");
          addToLibrary("players", dataUrl, "player-local");
        } else if (type==="asset"){
          hostCreateToken(dataUrl,"image","asset");
          addToLibrary("assets", dataUrl, "asset-local");
        }

        rebuildLayersPanel();
        applyLayerVisibilityToDOM();
        updateSceneSizeEstimate();
      };
      reader.readAsDataURL(file);
    }

    // ===== BIBLIOTECA =====
    function toggleLibrary(){
      if (!isHost) return alert("Apenas o Host usa Biblioteca/Perfil.");
      // evita overlap visual com painel de jogadores (opcional)
      playersPanel.classList.remove('show');
      libraryPanel.classList.toggle('show');
      renderLibrary();
    }

    function setLibraryTab(tab){
      libraryTab=tab;
      document.getElementById('tab-maps').classList.toggle('active', tab==='maps');
      document.getElementById('tab-players').classList.toggle('active', tab==='players');
      document.getElementById('tab-assets').classList.toggle('active', tab==='assets');
      renderLibrary();
    }

    function normalizeNameFromSrc(src, fallback){
      if (!src) return fallback || "asset";
      if (src.startsWith("data:image")) return fallback || "local";
      try{
        const u=new URL(src);
        const last=u.pathname.split("/").pop() || fallback || "img";
        return decodeURIComponent(last).slice(0,40);
      }catch{
        return fallback || "asset";
      }
    }

    function addToLibrary(kind, src, name=null){
      if (!isHost) return;
      if (!src) return;
      const list = library[kind];
      if (!Array.isArray(list)) return;
      if (list.some(x=>x.src===src)) return;

      list.unshift({
        id: generateUUID(),
        name: name || normalizeNameFromSrc(src, kind==="maps"?"mapa":kind),
        src
      });
      renderLibrary();
    }

    function renderLibrary(){
      if (!isHost) return;
      const term=(librarySearch.value||"").toLowerCase().trim();
      const list = library[libraryTab] || [];
      const filtered = term ? list.filter(x=>(x.name||"").toLowerCase().includes(term)) : list;

      libraryGrid.innerHTML="";
      filtered.forEach(item=>{
        const card=document.createElement('div');
        card.className="asset-card";

        const thumb=document.createElement('div');
        thumb.className="asset-thumb";
        const img=document.createElement('img');
        img.src=item.src;
        img.alt=item.name||"asset";
        thumb.appendChild(img);

        const title=document.createElement('div');
        title.style.fontSize="10px";
        title.style.opacity=".85";
        title.style.whiteSpace="nowrap";
        title.style.overflow="hidden";
        title.style.textOverflow="ellipsis";
        title.textContent=item.name||"asset";

        const actions=document.createElement('div');
        actions.className="asset-actions";

        const use=document.createElement('button');
        use.textContent = (libraryTab==="maps") ? "Usar" : "Add";
        use.onclick=()=>{
          if (libraryTab==="maps"){
            applyMapLocal(item.src,true);
          } else if (libraryTab==="players"){
            hostCreateToken(item.src,"image","player");
          } else if (libraryTab==="assets"){
            hostCreateToken(item.src,"image","asset");
          }
          rebuildLayersPanel();
          applyLayerVisibilityToDOM();
          updateSceneSizeEstimate();
        };

        const del=document.createElement('button');
        del.textContent="Remover";
        del.onclick=()=>removeFromLibrary(item.id);

        actions.appendChild(use);
        actions.appendChild(del);

        card.appendChild(thumb);
        card.appendChild(title);
        card.appendChild(actions);

        libraryGrid.appendChild(card);
      });

      const count=(library[libraryTab]||[]).length;
      libraryCount.textContent = `${count} itens`;
    }

    function removeFromLibrary(id){
      if (!isHost) return;
      for (const k of ["maps","players","assets"]){
        library[k] = (library[k]||[]).filter(x=>x.id!==id);
      }
      renderLibrary();
    }

    function clearLibrary(){
      if (!isHost) return;
      if (!confirm("Limpar toda a Biblioteca?")) return;
      library.maps=[]; library.players=[]; library.assets=[];
      renderLibrary();
    }

    function saveProfileToFile(){
      if (!isHost) return;
      const payload={ version:2, savedAt:new Date().toISOString(), library };
      const json=JSON.stringify(payload);
      const blob=new Blob([json],{type:"application/json"});

      const a=document.createElement('a');
      a.href=URL.createObjectURL(blob);
      a.download=`perfil-${new Date().toISOString().replace(/[:.]/g,'-')}.json`;
      document.body.appendChild(a);
      a.click();
      a.remove();
      setTimeout(()=>URL.revokeObjectURL(a.href),1500);
      showNotification("Perfil salvo!");
    }

    function loadProfileFromFile(event){
      if (!isHost) return;
      const file=event.target.files?.[0];
      if (!file) return;
      const r=new FileReader();
      r.onload=()=>{
        try{
          const payload=JSON.parse(String(r.result||"{}"));
          if (!payload?.library) throw 0;
          library.maps=Array.isArray(payload.library.maps)?payload.library.maps:[];
          library.players=Array.isArray(payload.library.players)?payload.library.players:[];
          library.assets=Array.isArray(payload.library.assets)?payload.library.assets:[];
          showNotification("Perfil carregado!");
          renderLibrary();
        }catch{
          alert("perfil.json inv√°lido.");
        }
        event.target.value="";
      };
      r.readAsText(file);
    }

    // ===== CENAS (SAVE/LOAD) =====
    function openScenePanel(){
      if (!isHost) return alert("Apenas o Host.");
      scenePanel.classList.toggle('show');
      updateQualityLabel();
      updateSceneSizeEstimate();
    }

    function prettyBytes(bytes){
      const units=["B","KB","MB","GB"];
      let i=0,num=bytes;
      while(num>=1024 && i<units.length-1){ num/=1024; i++; }
      return `${num.toFixed(i===0?0:2)} ${units[i]}`;
    }

    function updateQualityLabel(){
      const q=document.getElementById('quality');
      const label=document.getElementById('quality-label');
      if (q && label) label.textContent=`Q ${Number(q.value).toFixed(2)}`;
    }

    function estimatePayloadSizeBytes(payload){
      try{ return byteLengthOfString(JSON.stringify(payload)); }
      catch{ return 0; }
    }

    function updateSceneSizeEstimate(){
      if (!isHost) return;
      const payload={
        version:4,
        savedAt:new Date().toISOString(),
        map: state.map,
        tokens: state.tokens,
        layerState
      };
      const bytes=estimatePayloadSizeBytes(payload);
      document.getElementById('scene-size').textContent = `~ ${prettyBytes(bytes)}`;
    }

    function blobToDataURL(blob){
      return new Promise((resolve,reject)=>{
        const r=new FileReader();
        r.onload=()=>resolve(r.result);
        r.onerror=reject;
        r.readAsDataURL(blob);
      });
    }

    async function tryFetchAsBlob(url){
      try{
        const resp=await fetch(url,{mode:"cors"});
        if(!resp.ok) throw 0;
        return await resp.blob();
      }catch{ return null; }
    }

    async function tryFetchAsDataURL(url){
      const blob=await tryFetchAsBlob(url);
      if(!blob) return null;
      if(!blob.type.startsWith("image/")) return null;
      return await blobToDataURL(blob);
    }

    async function compressBlobToWebP(blob, maxDim, quality){
      try{
        const bmp=await createImageBitmap(blob);
        const w=bmp.width,h=bmp.height;
        const s=Math.min(1, maxDim/Math.max(w,h));
        const nw=Math.max(1,Math.round(w*s));
        const nh=Math.max(1,Math.round(h*s));
        const c=document.createElement('canvas');
        c.width=nw; c.height=nh;
        const ctx=c.getContext('2d',{alpha:true});
        ctx.drawImage(bmp,0,0,nw,nh);
        const outBlob=await new Promise(res=>c.toBlob(res,"image/webp",quality));
        if(!outBlob) return null;
        return await blobToDataURL(outBlob);
      }catch{ return null; }
    }

    async function compressDataURLToWebP_scene(dataUrl, maxDim, quality){
      try{
        const resp=await fetch(dataUrl);
        const blob=await resp.blob();
        if(!blob.type.startsWith("image/")) return null;
        return await compressBlobToWebP(blob,maxDim,quality);
      }catch{ return null; }
    }

    async function compressImageSrcIfPossible(src, maxDim, quality){
      if (typeof src==="string" && src.startsWith("http")){
        const blob=await tryFetchAsBlob(src);
        if(!blob || !blob.type.startsWith("image/")) return src;
        const webp=await compressBlobToWebP(blob,maxDim,quality);
        return webp || src;
      }
      if (typeof src==="string" && src.startsWith("data:image")){
        const webp=await compressDataURLToWebP_scene(src,maxDim,quality);
        return webp || src;
      }
      return src;
    }

    async function buildScenePayloadSelfContained(){
      if (!isHost) return null;

      const embedRemote = !!document.getElementById('embed-remote')?.checked;
      const compress = !!document.getElementById('compress-images')?.checked;
      const maxDim = parseInt(document.getElementById('max-dim')?.value || "2048", 10);
      const quality = parseFloat(document.getElementById('quality')?.value || "0.75");

      const payload = {
        version:4,
        savedAt:new Date().toISOString(),
        map: JSON.parse(JSON.stringify(state.map)),
        tokens: JSON.parse(JSON.stringify(state.tokens)),
        layerState: JSON.parse(JSON.stringify(layerState))
      };

      if (payload.map?.src){
        if (embedRemote && payload.map.src.startsWith("http")){
          const du = await tryFetchAsDataURL(payload.map.src);
          if (du) payload.map.src = du;
        }
        if (compress && (payload.map.src.startsWith("http") || payload.map.src.startsWith("data:image"))){
          payload.map.src = await compressImageSrcIfPossible(payload.map.src, maxDim, quality);
        }
      }

      for (const id of Object.keys(payload.tokens)){
        const t = payload.tokens[id];
        if (!t?.src) continue;

        if (embedRemote && typeof t.src==="string" && t.src.startsWith("http")){
          const du = await tryFetchAsDataURL(t.src);
          if (du) t.src = du;
        }
        if (compress && t.type==="image"){
          t.src = await compressImageSrcIfPossible(t.src, maxDim, quality);
        }
      }

      return payload;
    }

    async function saveSceneToFile(){
      if (!isHost) return alert("Apenas o Host.");
      showNotification("Salvando...");
      const payload = await buildScenePayloadSelfContained();
      if (!payload) return;

      const json=JSON.stringify(payload);
      const blob=new Blob([json],{type:"application/json"});

      const a=document.createElement('a');
      a.href=URL.createObjectURL(blob);
      a.download=`cena-${new Date().toISOString().replace(/[:.]/g,'-')}.json`;
      document.body.appendChild(a);
      a.click();
      a.remove();
      setTimeout(()=>URL.revokeObjectURL(a.href),1500);

      showNotification(`Cena salva (${prettyBytes(blob.size)})!`);
      updateSceneSizeEstimate();
    }

    function hostLoadScenePayload(payload){
      if (!isHost) return;
      if (!payload || typeof payload!=="object") return alert("Cena inv√°lida.");

      const clear = { type:"CLEAR" };
      applyAction(clear,false); broadcastACT(clear);

      if (payload.layerState){
        layerState.visible = payload.layerState.visible || {};
        layerState.locked = payload.layerState.locked || {};
      }

      const map = payload.map || {src:null,locked:false,x:0,y:0};
      if (map.src){
        const a = { type:"MAP_UPDATE", src: map.src };
        applyAction(a,false); broadcastACT(a);
      }
      const lockA = { type:"MAP_LOCK", locked: !!map.locked };
      applyAction(lockA,false); broadcastACT(lockA);

      const moveA = { type:"MAP_MOVE", x: Number(map.x||0), y: Number(map.y||0) };
      applyAction(moveA,false); broadcastACT(moveA);

      const tokens = payload.tokens || {};
      for (const id of Object.keys(tokens)){
        const t = tokens[id];
        if (!t?.src || !t.type) continue;
        ensureLayerDefaults(Number(t.layer||2));
        const create = {
          type:"CREATE_TOKEN",
          id,
          src: t.src,
          contentType: t.type,
          props: {
            kind: t.kind || "asset",
            layer: Number(t.layer||2),
            x: t.x, y: t.y, w: t.w, h: t.h,
            rotation: t.rotation, flipped: t.flipped,
            innerZoom: t.innerZoom, locked: t.locked,
            fitMode: t.fitMode || "contain"
          }
        };
        applyAction(create,false); broadcastACT(create);
      }

      applyLayerVisibilityToDOM();
      rebuildLayersPanel();
      showNotification("Cena carregada!");
      updateSceneSizeEstimate();
    }

    function loadSceneFromFile(event){
      if (!isHost) return;
      const file=event.target.files?.[0];
      if (!file) return;
      const r=new FileReader();
      r.onload=()=>{
        try{
          const payload=JSON.parse(String(r.result||"{}"));
          hostLoadScenePayload(payload);
        }catch{ alert("JSON inv√°lido."); }
        event.target.value="";
      };
      r.readAsText(file);
    }

    // ===== CLEAR / UNLOCK =====
    function clearTable(emit=true){
      if (!isHost) return;
      if (emit && !confirm("Deseja limpar todos os tokens e o mapa?")) return;
      const action={ type:"CLEAR" };
      applyAction(action,false); broadcastACT(action);
      updateSceneSizeEstimate();
    }

    function unlockEverything(){
      if (!isHost) return;
      document.querySelectorAll('.token.locked').forEach(t=>{
        const id=t.dataset.uuid;
        const action={ type:"UPDATE_PROP", id, prop:"locked", value:"false" };
        applyAction(action,false); broadcastACT(action);
      });
      if (state.map.locked) setMapLockLocal(false,true);
      updateSceneSizeEstimate();
    }

    // ===== PROTOCOLO REDE (Host autoritativo) =====
    function sendREQ(action){
      if (isHost){
        applyHostAuthorizedAction(action,{sender:myId});
        return;
      }
      if (hostConnection?.open){
        sendNet(hostConnection, {kind:"REQ", sender:myId, action});
      }
    }

    function broadcastACT(action, meta={}){
      if (!isHost) return;
      const msg={kind:"ACT", sender:myId, action, meta};
      broadcastNet(msg);
    }

    function sendSYNC(conn){
      if (!isHost) return;
      sendNet(conn, {kind:"SYNC", sender:myId, state, layerState});
    }

    function handleNetworkData(data, connPeerId=null){
      if (!data?.kind) return;

      if (data.kind==="HELLO"){
        if (!isHost) return;
        const conn = connections.find(c=>c.peer===data.sender) || null;
        if (conn) sendSYNC(conn);
        return;
      }

      if (data.kind==="RESYNC"){
        if (!isHost) return;
        const conn = connections.find(c=>c.peer===data.sender) || null;
        if (conn) sendSYNC(conn);
        return;
      }

      if (data.kind==="PING"){
        // host -> player
        if (isHost) return;
        if (hostConnection?.open){
          sendNet(hostConnection, {kind:"PONG", sender:myId, t:data.t});
        }
        return;
      }

      if (data.kind==="PONG"){
        // player -> host
        if (!isHost) return;
        const peerId = data.sender || connPeerId;
        const c = clients.get(peerId);
        if (c && typeof data.t === "number"){
          c.rtt = Date.now() - data.t;
          c.lastSeen = Date.now();
          renderPlayersPanel();
        }
        return;
      }

      if (data.kind==="SYNC_OK"){
        if (!isHost) return;
        const peerId = data.sender || connPeerId;
        const c = clients.get(peerId);
        if (c){
          c.synced = true;
          c.lastSeen = Date.now();
          renderPlayersPanel();
        }
        return;
      }

      if (data.kind==="SYNC"){
        applyFullSync(data.state, data.layerState);
        hasSynced = true;
        if (!isHost && hostConnection?.open){
          sendNet(hostConnection, {kind:"SYNC_OK", sender:myId});
        }
        if (resyncTimer){ clearInterval(resyncTimer); resyncTimer = null; }
        return;
      }

      if (data.kind==="ACT"){
        applyAction(data.action,true);
        return;
      }

      if (data.kind==="REQ"){
        if (!isHost) return;
        const sender=data.sender || connPeerId || "unknown";
        applyHostAuthorizedAction(data.action,{sender});
      }
    }

    // ===== VALIDA√á√ÉO (player) =====
    function validateClientAction(action){
      if (!action?.type) return {ok:false,reason:"A√ß√£o inv√°lida"};

      const allowed = new Set(["MOVE","UPDATE_PROP"]);
      if (!allowed.has(action.type)) return {ok:false,reason:"A√ß√£o n√£o permitida"};

      const id=action.id;
      if (!id || !state.tokens[id]) return {ok:false,reason:"Token inexistente"};

      const tok=state.tokens[id];
      const layer = Number(tok.layer||2);
      ensureLayerDefaults(layer);

      if (!layerState.visible[layer]) return {ok:false,reason:"Layer oculta"};
      if (layerState.locked[layer]) return {ok:false,reason:"Layer trancada"};
      if (String(tok.locked)==="true") return {ok:false,reason:"Token travado"};

      if (action.type==="UPDATE_PROP"){
        const allowedProps = new Set(["rotation","flipped","innerZoom","size","fitMode","layer"]);
        if (!allowedProps.has(action.prop)) return {ok:false,reason:"Prop n√£o permitida"};

        if (action.prop==="innerZoom"){
          const z=Number(action.value);
          if (!Number.isFinite(z) || z<.2 || z>5) return {ok:false,reason:"Zoom inv√°lido"};
        }
        if (action.prop==="size"){
          const w=Number(action.value?.w), h=Number(action.value?.h);
          if(!Number.isFinite(w)||!Number.isFinite(h)) return {ok:false,reason:"Size inv√°lido"};
          if(w<40||w>2500||h<40||h>2500) return {ok:false,reason:"Size fora limite"};
        }
        if (action.prop==="fitMode"){
          const m=String(action.value);
          if(!["contain","cover"].includes(m)) return {ok:false,reason:"fit inv√°lido"};
        }
        if (action.prop==="layer"){
          const l=Number(action.value);
          if(!Number.isFinite(l)||l<1||l>50) return {ok:false,reason:"Layer inv√°lida"};
        }
      }
      return {ok:true};
    }

    function applyHostAuthorizedAction(action,{sender}){
      const fromClient = sender && sender !== myId;
      if (fromClient){
        const v=validateClientAction(action);
        if (!v.ok){ console.warn("REQ negada:", v.reason, action); return; }
      }
      applyAction(action,false);
      broadcastACT(action,{approvedBy:myId, originalSender:sender});
    }

    // ===== APPLY ACTION =====
    function applyAction(action, fromNetwork){
      switch(action.type){
        case "CLEAR":{
          document.querySelectorAll('.token').forEach(t=>t.remove());
          mapContainer.innerHTML="";
          document.querySelectorAll('.dice-entry').forEach(l=>l.remove());
          selectedToken=null;
          stopMapInertia();
          mapDragging=false;

          state.map={src:null,locked:false,x:0,y:0};
          state.tokens={};

          setMapLockLocal(false,false);
          setMapOffset(0,0);

          rebuildLayersPanel();
          applyLayerVisibilityToDOM();
          break;
        }

        case "MAP_UPDATE":{
          state.map.src = action.src;
          applyMapLocal(action.src,false);
          break;
        }

        case "MAP_LOCK":{
          setMapLockLocal(!!action.locked,false);
          break;
        }

        case "MAP_MOVE":{
          const x=Number(action.x||0), y=Number(action.y||0);
          setMapOffset(x,y);
          break;
        }

        case "CREATE_TOKEN":{
          const {id, src, contentType, props} = action;
          addTokenLocal(src, contentType, id, props);
          state.tokens[id]=normalizeTokenProps(id,src,contentType,props);
          rebuildLayersPanel();
          applyLayerVisibilityToDOM();
          break;
        }

        case "REMOVE_TOKEN":{
          const {id}=action;
          removeTokenLocal(id);
          delete state.tokens[id];
          rebuildLayersPanel();
          applyLayerVisibilityToDOM();
          break;
        }

        case "MOVE":{
          const {id,x,y}=action;
          moveTokenDOM(id,x,y);
          if (state.tokens[id]){ state.tokens[id].x=x; state.tokens[id].y=y; }
          break;
        }

        case "UPDATE_PROP":{
          const {id,prop,value}=action;
          updateTokenPropDOM(id,prop,value);
          if (state.tokens[id]){
            if (prop==="locked") state.tokens[id].locked=String(value);
            if (prop==="innerZoom") state.tokens[id].innerZoom=value;
            if (prop==="rotation") state.tokens[id].rotation=value;
            if (prop==="flipped") state.tokens[id].flipped=value;
            if (prop==="fitMode") state.tokens[id].fitMode=value;
            if (prop==="size"){ state.tokens[id].w=value.w; state.tokens[id].h=value.h; }
            if (prop==="layer"){
              state.tokens[id].layer=Number(value);
              ensureLayerDefaults(Number(value));
            }
          }
          rebuildLayersPanel();
          applyLayerVisibilityToDOM();
          break;
        }

        case "DICE":{
          showDiceLog(action.faces, action.result);
          break;
        }

        case "LAYER_SET":{
          const l=Number(action.layer);
          ensureLayerDefaults(l);
          if (action.prop==="visible") layerState.visible[l]=!!action.value;
          if (action.prop==="locked") layerState.locked[l]=!!action.value;
          applyLayerVisibilityToDOM();
          rebuildLayersPanel();
          break;
        }
      }
      if (isHost) updateSceneSizeEstimate();
    }

    function applyFullSync(s, ls){
      document.querySelectorAll('.token').forEach(t=>t.remove());
      mapContainer.innerHTML="";
      document.querySelectorAll('.dice-entry').forEach(l=>l.remove());
      selectedToken=null;
      stopMapInertia();

      layerState.visible = ls?.visible || {};
      layerState.locked = ls?.locked || {};

      if (s?.map){
        state.map = JSON.parse(JSON.stringify(s.map));
        if (state.map.src) applyMapLocal(state.map.src,false);
        setMapLockLocal(!!state.map.locked,false);
        setMapOffset(Number(state.map.x||0), Number(state.map.y||0));
      }

      state.tokens = {};
      const tokens = s?.tokens || {};
      for (const id of Object.keys(tokens)){
        const t=tokens[id];
        ensureLayerDefaults(Number(t.layer||2));
        addTokenLocal(t.src, t.type, id, t);
        state.tokens[id]=JSON.parse(JSON.stringify(t));
      }

      applyLayerVisibilityToDOM();
      rebuildLayersPanel();
      updateSceneSizeEstimate();
    }

    // ===== PeerJS setup =====
    function initNetwork(){
      const urlParams=new URLSearchParams(window.location.search);
      const roomID=urlParams.get('room');

      peer=new Peer(null,{debug:2, config:PEER_ICE_CONFIG});

      peer.on('open',(id)=>{
        myId=id;

        if (roomID){
          isHost=false;
          setRoleUI();
          statusText.innerText="Conectando ao Host...";
          tinyStatus.textContent="Conectando...";
          tinyRoom.textContent=roomID;
          connectToHost(roomID);
        } else {
          isHost=true;
          setRoleUI();
          statusText.innerText="Online (Host)";
          tinyStatus.textContent="Online (Host)";
          tinyRoom.textContent=id;
          statusDot.classList.add('online');
          toggleNetworkPanel();
          startHostPinger();

          peer.on('connection',(conn)=>{
            connections.push(conn);
            setupConnection(conn);
            registerClient(conn);

            conn.on('open',()=>{
              // SYNC imediato + redund√¢ncia
              sendSYNC(conn);
              setTimeout(()=>sendSYNC(conn), 350);
            });

            conn.on('close',()=>{
              connections=connections.filter(c=>c!==conn);
              unregisterClient(conn.peer);
            });

            conn.on('error',()=>{
              connections=connections.filter(c=>c!==conn);
              unregisterClient(conn.peer);
            });
          });
        }
      });

      peer.on('error',(err)=>{
        console.error(err);
        statusText.innerText="Erro Rede";
        tinyStatus.textContent="Erro Rede";
        statusDot.classList.remove('online');
      });
    }

    function connectToHost(hostId){
      hostConnection=peer.connect(hostId);
      setupConnection(hostConnection);

      hostConnection.on('open',()=>{
        statusText.innerText="Conectado";
        tinyStatus.textContent="Conectado";
        statusDot.classList.add('online');

        // HELLO pede SYNC
        sendNet(hostConnection, {kind:"HELLO", sender:myId});
        setTimeout(()=>sendNet(hostConnection, {kind:"HELLO", sender:myId}), 450);

        // Se n√£o sincronizar, insiste com RESYNC por um tempo
        hasSynced = false;
        if (resyncTimer) clearInterval(resyncTimer);
        let tries = 0;
        resyncTimer = setInterval(()=>{
          if (hasSynced || !hostConnection?.open){ clearInterval(resyncTimer); resyncTimer=null; return; }
          tries++;
          requestResync("no-sync");
          if (tries >= 8){ clearInterval(resyncTimer); resyncTimer=null; }
        }, 1400);
      });

      hostConnection.on('close',()=>{
        statusText.innerText="Desconectado";
        tinyStatus.textContent="Desconectado";
        statusDot.classList.remove('online');
        alert("O Host desconectou.");
      });

      hostConnection.on('error',()=>{
        statusText.innerText="Erro";
        tinyStatus.textContent="Erro";
        statusDot.classList.remove('online');
      });
    }

    function setupConnection(conn){
      conn.on('data',(data)=>onNetData(data, conn.peer));
    }

    // ===== UI init =====
    function initUI(){
      const q=document.getElementById('quality');
      q?.addEventListener('input',updateQualityLabel);
      q?.addEventListener('change',updateSceneSizeEstimate);
      document.getElementById('max-dim')?.addEventListener('change',updateSceneSizeEstimate);
      document.getElementById('compress-images')?.addEventListener('change',updateSceneSizeEstimate);
      document.getElementById('embed-remote')?.addEventListener('change',updateSceneSizeEstimate);
      updateQualityLabel();
      updateSceneSizeEstimate();
    }

    // ===== Context menu off =====
    window.addEventListener('contextmenu',(e)=>e.preventDefault());

    // ===== Start =====
    initNetwork();
    initUI();
  </script>
</body>
</html>
