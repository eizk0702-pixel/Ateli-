<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>Tabletop Luxury - P2P (Saves + Perfil + Fog por Elemento + Layers)</title>

  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>

  <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Inter:wght@300;400;600&display=swap" rel="stylesheet">

  <style>
    :root{
      --gold:#c5a059;
      --dark-bg:#0f0f0f;
      --panel-bg:rgba(20,20,20,.92);
      --glass:rgba(255,255,255,.04);
      --status-online:#4ade80;
      --status-offline:#ef4444;
    }
    body{margin:0;overflow:hidden;background:var(--dark-bg);font-family:'Inter',sans-serif;color:#e0e0e0;}

    #viewport{width:100vw;height:100vh;overflow:hidden;position:relative;background:radial-gradient(circle,#1a1a1a 0%,#0a0a0a 100%);z-index:1;}
    #canvas-container{width:10000px;height:10000px;position:absolute;top:0;left:0;transform-origin:0 0;cursor:grab;z-index:2;}

    /* MAPA = layer 0 */
    #map-container{
      position:absolute;top:0;left:0;
      z-index:5;
      pointer-events:auto;
      transform: translate(0px,0px);
      transform-origin: 0 0;
    }
    #map-container.locked{pointer-events:none;}
    #map-container img{
      display:block;max-width:none;
      user-select:none;-webkit-user-drag:none;
      cursor:grab;
      filter: drop-shadow(0 0 25px rgba(0,0,0,.45));
    }
    #map-container.dragging img{cursor:grabbing;}

    .grid-layer{
      position:absolute;top:0;left:0;width:100%;height:100%;
      pointer-events:none;
      background-image:
        linear-gradient(to right, rgba(197,160,89,.05) 1px, transparent 1px),
        linear-gradient(to bottom, rgba(197,160,89,.05) 1px, transparent 1px);
      background-size:50px 50px;
      z-index:6;
    }

    /* TOKENS */
    .token{
      position:absolute;
      cursor:move;
      user-select:none;
      display:flex;align-items:center;justify-content:center;
      background:transparent;
      overflow:visible;
      transition:filter .15s ease, outline .15s ease, opacity .15s ease;
    }
    .token.locked{cursor:default!important;pointer-events:none;}
    .token.hidden-by-fog{visibility:hidden !important; pointer-events:none !important;}
    .token.selected:not(.locked){
      filter:drop-shadow(0 0 15px var(--gold));
      outline:2px dashed rgba(197,160,89,.6);
      outline-offset:6px;
    }

    .token-blocker{position:absolute;top:0;left:0;width:100%;height:100%;z-index:50;background:rgba(255,255,255,.001);}
    .token-content-wrapper{width:100%;height:100%;overflow:hidden;display:flex;align-items:center;justify-content:center;pointer-events:none;}

    .token iframe,.token img{
      width:100%;height:100%;border:none;background:transparent;pointer-events:none;
      object-fit:contain;
      transition:transform .15s ease-out;
      image-rendering:auto;
    }

    .resize-handle{
      position:absolute;width:18px;height:18px;background:var(--gold);
      border:2px solid #fff;border-radius:5px;display:none;z-index:110;
      cursor:nwse-resize;bottom:-9px;right:-9px;
    }
    .token.selected:not(.locked) .resize-handle{display:block;}

    /* HUD */
    .hud-element{transition:opacity .35s ease, transform .35s ease;}
    .hud-hidden .hud-element{opacity:0!important;pointer-events:none!important;transform:translateY(10px);}

    .sidebar{
      width:360px;background:var(--panel-bg);backdrop-filter:blur(15px);
      height:100vh;position:fixed;left:0;top:0;z-index:1000;
      border-right:1px solid rgba(197,160,89,.2);
      transform:translateX(-100%);
      transition:transform .35s cubic-bezier(.16,1,.3,1);
    }
    .sidebar.open{transform:translateX(0);}
    .toggle-sidebar-btn{
      position:absolute;right:-38px;top:20px;background:var(--panel-bg);
      border:1px solid rgba(197,160,89,.2);border-left:none;
      padding:12px 10px;border-radius:0 10px 10px 0;cursor:pointer;color:var(--gold);
      font-size:16px;
    }

    .controls-top{
      position:fixed;top:18px;left:50%;transform:translateX(-50%);
      display:flex;gap:10px;z-index:1000;background:var(--panel-bg);
      padding:10px;border-radius:999px;border:1px solid rgba(197,160,89,.2);
      backdrop-filter:blur(10px);box-shadow:0 6px 26px rgba(0,0,0,.45);
    }

    .btn-luxury{
      padding:10px 16px;border-radius:999px;font-size:12px;font-weight:700;
      text-transform:uppercase;letter-spacing:1px;transition:all .2s;
      border:1px solid transparent;color:#ccc;background:transparent;
    }
    .btn-luxury:hover,.btn-luxury.active{
      color:var(--gold);background:var(--glass);border-color:rgba(197,160,89,.45);
    }

    .dice-log{
      position:fixed;bottom:22px;right:22px;width:260px;max-height:220px;
      background:var(--panel-bg);border-radius:14px;border:1px solid rgba(197,160,89,.15);
      padding:16px;overflow-y:auto;font-size:13px;z-index:1000;
      box-shadow:0 6px 18px rgba(0,0,0,.35);
    }

    .btn-toggle-hud{
      position:fixed;bottom:22px;left:22px;z-index:2000;background:var(--panel-bg);
      width:48px;height:48px;border-radius:50%;
      display:flex;align-items:center;justify-content:center;
      border:1px solid rgba(197,160,89,.3);cursor:pointer;color:var(--gold);
      box-shadow:0 5px 12px rgba(0,0,0,.45);
      font-size:18px;
    }

    .url-field{
      background:rgba(0,0,0,.3);border:1px solid rgba(197,160,89,.2);color:#fff;
      width:100%;font-size:12px;padding:10px;margin-bottom:10px;outline:none;border-radius:12px;
    }
    .url-field:focus{border-color:var(--gold);background:rgba(0,0,0,.5);}

    h2,h3{font-family:'Cinzel',serif;letter-spacing:1px;color:var(--gold);}

    .network-status{
      position:fixed;top:78px;right:20px;display:flex;align-items:center;gap:10px;
      background:var(--panel-bg);padding:10px 16px;border-radius:999px;
      border:1px solid rgba(197,160,89,.2);font-size:11px;z-index:1000;
      backdrop-filter:blur(10px);
      opacity:0;pointer-events:none;transform:translateY(-10px);transition:all .25s;
    }
    .network-status.show{opacity:1;pointer-events:auto;transform:translateY(0);}

    .status-dot{width:9px;height:9px;border-radius:50%;background:var(--status-offline);box-shadow:0 0 6px currentColor;}
    .status-dot.online{background:var(--status-online);}

    .lock-manager{
      position:fixed;top:18px;right:20px;z-index:1000;display:flex;flex-direction:column;gap:10px;
    }

    #notification{
      position:fixed;top:50%;left:50%;transform:translate(-50%,-50%) scale(.92);
      background:rgba(0,0,0,.92);border:1px solid var(--gold);
      padding:20px 40px;border-radius:12px;z-index:9999;color:var(--gold);
      font-family:'Cinzel',serif;opacity:0;pointer-events:none;transition:all .22s;
    }
    #notification.active{opacity:1;transform:translate(-50%,-50%) scale(1);}

    #role-badge{
      position:fixed;top:138px;right:20px;z-index:1100;background:var(--panel-bg);
      border:1px solid rgba(197,160,89,.2);border-radius:999px;padding:8px 12px;
      font-size:11px;backdrop-filter:blur(10px);opacity:.95;
    }
    #role-badge b{color:var(--gold);}

    /* Inspector grande (√∫nica UI de edi√ß√£o) */
    .inspector{
      position:fixed;top:178px;right:20px;z-index:1200;width:420px;max-height:72vh;
      background:var(--panel-bg);border:1px solid rgba(197,160,89,.2);
      border-radius:18px;padding:14px;backdrop-filter:blur(10px);
      box-shadow:0 12px 34px rgba(0,0,0,.5);
      display:none;overflow:auto;
    }
    .inspector.show{display:block;}
    .inspector h4{font-family:'Cinzel',serif;color:var(--gold);margin:0 0 10px 0;font-size:16px;}
    .inspector .row{display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-bottom:10px;}
    .inspector .block{background:rgba(255,255,255,.03);border:1px solid rgba(197,160,89,.18);border-radius:14px;padding:10px;}
    .inspector label{font-size:11px;opacity:.85;display:flex;justify-content:space-between;gap:10px;margin-bottom:6px;}
    .inspector input[type="range"]{width:100%;}
    .inspector input[type="number"], .inspector select, .inspector input[type="text"]{
      width:100%;padding:10px;border-radius:12px;border:1px solid rgba(197,160,89,.22);
      background:rgba(0,0,0,.35);color:#fff;outline:none;
    }
    .inspector .actions{display:flex;gap:10px;margin-top:8px;}
    .inspector .actions button{
      flex:1;padding:10px 12px;border-radius:14px;border:1px solid rgba(197,160,89,.25);
      background:rgba(255,255,255,.03);color:#ddd;font-weight:700;font-size:12px;cursor:pointer;
    }
    .inspector .actions button:hover{color:var(--gold);border-color:rgba(197,160,89,.55);background:rgba(255,255,255,.05);}
    .pill{
      font-size:11px;padding:8px 12px;border-radius:999px;border:1px solid rgba(197,160,89,.25);
      cursor:pointer;background:rgba(255,255,255,.03);color:#ddd;font-weight:700;
      display:inline-flex;align-items:center;justify-content:center;gap:8px;
      user-select:none;
    }
    .pill.active{color:var(--gold);border-color:rgba(197,160,89,.55);background:rgba(255,255,255,.06);}

    /* Layers panel */
    .layers-panel{
      position:fixed;top:86px;left:50%;transform:translateX(-50%);
      z-index:1200;min-width:420px;max-width:620px;
      background:var(--panel-bg);border:1px solid rgba(197,160,89,.2);
      border-radius:18px;padding:12px;backdrop-filter:blur(10px);
      box-shadow:0 12px 34px rgba(0,0,0,.5);
      display:none;
    }
    .layers-panel.show{display:block;}
    .layer-row{display:flex;align-items:center;justify-content:space-between;gap:10px;padding:10px 12px;border-radius:14px;background:rgba(255,255,255,.03);border:1px solid rgba(197,160,89,.12);margin-bottom:8px;}
    .layer-row b{color:var(--gold);}

    .mini{font-size:10px;opacity:.85;line-height:1.35;}

    /* Fog overlay: canvas full screen (n√£o escala com o board) */
    #fog-overlay{
      position:fixed; inset:0;
      z-index:900; /* acima do board, abaixo do HUD/Sidebar/Inspector */
      pointer-events:none;
      opacity:0;
      transition:opacity .18s ease;
    }
    #fog-overlay.on{opacity:1;}
    #fog-canvas{width:100%;height:100%;display:block;}

    /* Biblioteca UI */
    .tabbar{display:flex;gap:8px;margin-bottom:10px;}
    .tab{flex:1;text-align:center;padding:10px;border-radius:14px;border:1px solid rgba(197,160,89,.2);background:rgba(255,255,255,.03);cursor:pointer;font-weight:800;font-size:11px;letter-spacing:.5px;}
    .tab.active{color:var(--gold);border-color:rgba(197,160,89,.55);background:rgba(255,255,255,.05);}
    .library-grid{display:grid;grid-template-columns:repeat(3,1fr);gap:10px;}
    .lib-card{border:1px solid rgba(197,160,89,.18);background:rgba(255,255,255,.02);border-radius:14px;overflow:hidden;cursor:pointer;transition:transform .12s ease, border-color .12s ease;}
    .lib-card:hover{transform:scale(1.02);border-color:rgba(197,160,89,.5);}
    .lib-thumb{width:100%;aspect-ratio:1/1;object-fit:cover;display:block;background:#0b0b0b;}
    .lib-meta{padding:8px;}
    .lib-meta b{display:block;font-size:11px;color:var(--gold);white-space:nowrap;overflow:hidden;text-overflow:ellipsis;}
    .lib-meta span{display:block;font-size:10px;opacity:.75;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;}
    .lib-actions{display:flex;gap:8px;margin-top:8px;}
    .lib-actions button{flex:1;padding:10px;border-radius:14px;border:1px solid rgba(197,160,89,.18);background:rgba(255,255,255,.03);cursor:pointer;font-weight:800;font-size:11px;}
    .lib-actions button:hover{color:var(--gold);border-color:rgba(197,160,89,.55);background:rgba(255,255,255,.05);}

    /* Scene list */
    .scene-row{display:flex;gap:8px;align-items:center;justify-content:space-between;padding:10px;border-radius:14px;border:1px solid rgba(197,160,89,.15);background:rgba(255,255,255,.02);margin-bottom:8px;}
    .scene-row b{color:var(--gold);font-size:11px;}
    .scene-row span{font-size:10px;opacity:.75;}
    .scene-row .btn{padding:8px 10px;border-radius:12px;border:1px solid rgba(197,160,89,.18);background:rgba(255,255,255,.03);cursor:pointer;font-weight:900;font-size:10px;}
    .scene-row .btn:hover{color:var(--gold);border-color:rgba(197,160,89,.55);background:rgba(255,255,255,.05);}
  </style>
</head>

<body>
  <div id="notification">OK</div>
  <div id="role-badge">Modo: <b id="role-text">...</b></div>

  <!-- Fog overlay -->
  <div id="fog-overlay">
    <canvas id="fog-canvas"></canvas>
  </div>

  <div class="btn-toggle-hud" onclick="toggleHUD()" title="Esconder/Mostrar Interface">üëÅÔ∏è</div>

  <div id="hud-root">
    <div class="controls-top hud-element">
      <button class="btn-luxury" id="btn-d20" onclick="rollDice(20)">D20</button>
      <button class="btn-luxury" id="btn-d6" onclick="rollDice(6)">D6</button>
      <button class="btn-luxury" onclick="toggleGrid()">Grelha</button>
      <button class="btn-luxury" id="btn-lock-all" onclick="unlockEverything()">üîì Destrancar</button>
      <button class="btn-luxury" id="btn-fog" onclick="toggleFog()">üå´Ô∏è Fog</button>
      <button class="btn-luxury" id="btn-layers" onclick="toggleLayersPanel()">üß± Camadas</button>
      <button class="btn-luxury" id="btn-inspector" onclick="toggleInspector()">üõ†Ô∏è Inspector</button>
      <button class="btn-luxury" onclick="toggleNetworkPanel()">üåê Rede</button>
    </div>

    <div class="lock-manager hud-element">
      <button class="btn-luxury bg-black/40 border-gold/20" id="btn-lock-map" onclick="toggleMapLock()">üîì Mapa M√≥vel</button>
    </div>

    <div class="network-status" id="network-panel">
      <div id="status-dot" class="status-dot"></div>
      <span id="status-text">Offline</span>
      <div class="h-4 w-px bg-white/20 mx-2"></div>
      <button class="btn-luxury py-0 px-2 text-[10px]" onclick="copyInviteLink()" id="btn-invite">üîó Copiar Convite</button>
    </div>

    <!-- Inspector (√∫nico controle de token) -->
    <div class="inspector" id="inspector">
      <h4>Inspector</h4>
      <div class="mini" id="inspector-sub">Selecione um token.</div>

      <div class="block" style="margin:10px 0;">
        <label>Nome <span id="v-name">-</span></label>
        <input type="text" id="i-name" placeholder="Ex: Goblin, NPC 1..." />
        <div class="mini" style="margin-top:6px;">S√≥ pra organiza√ß√£o (salvo em cenas e perfil).</div>
      </div>

      <div class="row">
        <div class="block">
          <label>Layer <span id="v-layer">-</span></label>
          <input type="number" id="i-layer" min="1" max="50" value="1" />
        </div>

        <div class="block">
          <label>Lock <span id="v-locked">-</span></label>
          <div style="display:flex;gap:10px;flex-wrap:wrap;">
            <div class="pill" id="i-lock" onclick="inspectorToggleLock()">üîí Trancar</div>
            <div class="pill" id="i-unlock" onclick="inspectorUnlock()">üîì Destrancar</div>
          </div>
        </div>
      </div>

      <div class="row">
        <div class="block">
          <label>Tamanho <span id="v-size">-</span></label>
          <input type="range" id="i-size" min="40" max="2500" value="180" />
        </div>
        <div class="block">
          <label>Rota√ß√£o <span id="v-rot">-</span></label>
          <input type="range" id="i-rot" min="0" max="359" value="0" />
        </div>
      </div>

      <div class="row">
        <div class="block">
          <label>Zoom interno <span id="v-zoom">-</span></label>
          <input type="range" id="i-zoom" min="0.2" max="5" step="0.05" value="1" />
        </div>
        <div class="block">
          <label>Fit <span id="v-fit">-</span></label>
          <select id="i-fit">
            <option value="contain">Contain</option>
            <option value="cover">Cover (preenche)</option>
          </select>
          <div class="mini" style="margin-top:6px;">Melhora ‚Äúportrait‚Äù com cover, sem cortar estranho.</div>
        </div>
      </div>

      <div class="block" style="margin-bottom:10px;">
        <div style="display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap;">
          <div>
            <div style="font-family:'Cinzel',serif;color:var(--gold);font-weight:700;">Fog do Elemento</div>
            <div class="mini">Se ativar ‚ÄúEmite vis√£o‚Äù, esse token abre o fog no raio definido.</div>
          </div>
          <div class="pill" id="i-fog-emitter" onclick="inspectorToggleFogEmitter()">üëÅÔ∏è Emite vis√£o</div>
        </div>
        <div style="margin-top:10px;">
          <label>Raio de vis√£o <span id="v-fog">-</span></label>
          <input type="range" id="i-fog" min="50" max="2500" step="10" value="600" />
        </div>
        <div class="mini" style="margin-top:8px;">
          Regras: Players s√≥ enxergam tokens dentro de pelo menos 1 √°rea de vis√£o ativa (exceto o mapa).
        </div>
      </div>

      <div class="actions">
        <button onclick="inspectorBringFront()">‚¨ÜÔ∏è Subir layer</button>
        <button onclick="inspectorSendBack()">‚¨áÔ∏è Descer layer</button>
      </div>

      <div class="actions">
        <button onclick="inspectorReset()">‚ôªÔ∏è Reset</button>
        <button style="color:#ff6b6b;border-color:rgba(255,107,107,.35);" onclick="inspectorDelete()">üóëÔ∏è Deletar</button>
      </div>

      <div class="block" style="margin-top:10px;">
        <div style="display:flex;gap:10px;flex-wrap:wrap;align-items:center;justify-content:space-between;">
          <div>
            <div style="font-family:'Cinzel',serif;color:var(--gold);font-weight:700;">Adicionar ao Perfil</div>
            <div class="mini">Guarda este item no perfil/biblioteca.</div>
          </div>
          <div class="pill" onclick="inspectorAddToProfile()">‚ûï Salvar no Perfil</div>
        </div>
      </div>
    </div>

    <!-- Camadas -->
    <div class="layers-panel" id="layers-panel">
      <div style="display:flex;align-items:center;justify-content:space-between;gap:10px;margin-bottom:10px;">
        <div style="color: var(--gold); font-weight:700; font-family:'Cinzel',serif;">Camadas</div>
        <button class="btn-luxury py-0 px-2 text-[10px]" onclick="rebuildLayersPanel()">Atualizar</button>
      </div>
      <div class="mini" style="margin-bottom:10px;">Layer 0 √© o mapa. Layers aparecem automaticamente conforme voc√™ adiciona elementos.</div>
      <div id="layers-list"></div>
    </div>

    <!-- Sidebar -->
    <div class="sidebar hud-element" id="sidebar">
      <div class="toggle-sidebar-btn" onclick="toggleSidebar()">‚ò∞</div>
      <div class="p-6 overflow-y-auto h-full">
        <h2 class="text-xl font-bold mb-4 border-b border-gold/30 pb-3">Atelier P2P</h2>

        <!-- CENAS -->
        <div class="mb-8" id="host-only-scenes">
          <h3 class="text-xs font-semibold uppercase mb-3 opacity-70">Cenas (Save/Load)</h3>
          <div class="bg-black/40 p-4 border border-dashed border-gold/30 rounded-xl">
            <input type="text" id="scene-name" class="url-field" placeholder="Nome da cena (ex: Dungeon 01)">
            <div style="display:flex;gap:10px;">
              <button class="btn-luxury w-full border border-gold/30" onclick="saveScene()">Salvar</button>
              <button class="btn-luxury w-full border border-gold/30" onclick="saveSceneAsNew()">Salvar como nova</button>
            </div>

            <div class="mini" style="margin-top:10px;">Export/Import JSON</div>
            <div style="display:flex;gap:10px;margin-top:8px;">
              <button class="btn-luxury w-full border border-gold/30" onclick="exportAll()">Exportar Tudo</button>
              <label class="btn-luxury w-full border border-gold/30 text-center cursor-pointer">
                Importar Tudo
                <input type="file" id="import-all-file" accept="application/json" class="hidden" onchange="importAllFile(event)">
              </label>
            </div>
          </div>

          <div class="mini" style="margin:10px 0 6px 2px;">Lista de cenas</div>
          <div id="scene-list"></div>
        </div>

        <!-- PERFIL / BIBLIOTECA -->
        <div class="mb-8" id="host-only-profile">
          <h3 class="text-xs font-semibold uppercase mb-3 opacity-70">Perfil / Biblioteca (perfil.json)</h3>
          <div class="bg-black/40 p-4 border border-dashed border-gold/30 rounded-xl">
            <div class="tabbar">
              <div class="tab active" id="tab-maps" onclick="setProfileTab('maps')">MAPAS</div>
              <div class="tab" id="tab-players" onclick="setProfileTab('players')">PLAYERS</div>
              <div class="tab" id="tab-assets" onclick="setProfileTab('assets')">ASSETS</div>
            </div>

            <div class="mini" style="margin-bottom:10px;">
              Clique em um item para colocar na mesa. (Mapa aplica como Layer 0)
            </div>

            <div id="profile-grid" class="library-grid"></div>

            <div class="lib-actions">
              <button onclick="exportProfile()">Exportar Perfil</button>
              <label style="flex:1;">
                <button style="width:100%;" onclick="document.getElementById('import-profile-file').click()">Importar Perfil</button>
                <input type="file" id="import-profile-file" accept="application/json" class="hidden" onchange="importProfileFile(event)">
              </label>
            </div>
          </div>
        </div>

        <!-- IMPORT HOST -->
        <div class="mb-8" id="host-only-map">
          <h3 class="text-xs font-semibold uppercase mb-3 opacity-70">Mapa (Layer 0)</h3>
          <div class="bg-black/40 p-4 border border-dashed border-gold/30 rounded-xl">
            <input type="file" id="map-file" accept="image/*" class="hidden" onchange="importAsset(event, 'map')">
            <label for="map-file" class="btn-luxury block text-center mb-3 cursor-pointer bg-white/5">Ficheiro Local</label>
            <input type="text" id="map-url" class="url-field" placeholder="https://link-do-mapa.jpg">
            <button class="btn-luxury w-full border border-gold/30" onclick="importFromUrl('map-url', 'map')">Definir Mapa</button>
          </div>
        </div>

        <div class="mb-8" id="host-only-players">
          <h3 class="text-xs font-semibold uppercase mb-3 opacity-70">Players</h3>
          <div class="bg-black/40 p-4 border border-dashed border-gold/30 rounded-xl">
            <input type="file" id="player-file" accept="image/*" class="hidden" onchange="importAsset(event, 'player')">
            <label for="player-file" class="btn-luxury block text-center mb-3 cursor-pointer bg-white/5">Ficheiro Local</label>
            <input type="text" id="player-url" class="url-field" placeholder="URL Imagem...">
            <button class="btn-luxury w-full border border-gold/30" onclick="importFromUrl('player-url', 'player')">Adicionar Player</button>
          </div>
        </div>

        <div class="mb-8" id="host-only-assets">
          <h3 class="text-xs font-semibold uppercase mb-3 opacity-70">Assets</h3>
          <div class="bg-black/40 p-4 border border-dashed border-gold/30 rounded-xl">
            <input type="file" id="asset-file" accept="image/*" class="hidden" onchange="importAsset(event, 'asset')">
            <label for="asset-file" class="btn-luxury block text-center mb-3 cursor-pointer bg-white/5">Ficheiro Local</label>
            <input type="text" id="asset-url" class="url-field" placeholder="URL Imagem...">
            <button class="btn-luxury w-full border border-gold/30" onclick="importFromUrl('asset-url', 'asset')">Adicionar Asset</button>
          </div>
          <p class="mini" style="margin-top:8px;">Assets = tudo que n√£o √© player nem mapa.</p>
        </div>

        <div class="mt-auto pt-6 border-t border-gold/20" id="host-only-clear">
          <button class="btn-luxury w-full text-red-500 border-red-900/30 hover:bg-red-900/20" onclick="clearTable()">Limpar Mesa</button>
        </div>

        <div class="mt-6 text-[10px] opacity-50 leading-relaxed">
          <div><b>Status:</b> <span id="tiny-status">iniciando...</span></div>
          <div><b>Sala:</b> <span id="tiny-room">-</span></div>
        </div>
      </div>
    </div>

    <div class="dice-log hud-element" id="dice-log">
      <div id="dice-entries">
        <div class="text-[11px] opacity-40 mb-3 uppercase tracking-tighter">Hist√≥rico</div>
      </div>
    </div>
  </div>

  <div id="viewport">
    <div id="canvas-container">
      <div id="map-container"></div>
      <div id="grid-layer" class="grid-layer"></div>
    </div>
  </div>

  <script>
    /********************************************************************
     * ‚úÖ Implementado nesta vers√£o:
     * - Save/Load de Cenas (localStorage + export/import JSON)
     * - Perfil/Biblioteca (perfil.json) com abas (Mapas/Players/Assets)
     * - Salva URLs + Arquivos (DataURL base64)
     * - Fog por token: cada token pode emitir vis√£o com raio pr√≥prio
     * - Para PLAYER: tokens fora de qualquer vis√£o ficam invis√≠veis (exceto mapa)
     * - Removeu token-controls (barra em cima). S√≥ Inspector edita.
     * - Layers din√¢micas (0 mapa). Mapa palp√°vel com in√©rcia.
     * - Host autoritativo via PeerJS: players s√≥ mexem em tokens desbloqueados e layer destrancada.
     ********************************************************************/

    // ===== Util =====
    const clamp = (v,min,max)=>Math.max(min,Math.min(max,v));
    const generateUUID = () => Date.now().toString(36) + Math.random().toString(36).slice(2);
    const nowISO = ()=> new Date().toISOString();

    function showNotification(msg){
      const n=document.getElementById('notification');
      n.innerText=msg;
      n.classList.add('active');
      setTimeout(()=>n.classList.remove('active'),1600);
    }

    // ===== Elements =====
    const canvas = document.getElementById('canvas-container');
    const viewport = document.getElementById('viewport');
    const mapContainer = document.getElementById('map-container');
    const gridLayer = document.getElementById('grid-layer');
    const sidebar = document.getElementById('sidebar');
    const diceLogEntries = document.getElementById('dice-entries');

    const fogOverlay = document.getElementById('fog-overlay');
    const fogCanvas  = document.getElementById('fog-canvas');
    const fogCtx = fogCanvas.getContext('2d');

    const statusDot = document.getElementById('status-dot');
    const statusText = document.getElementById('status-text');
    const networkPanel = document.getElementById('network-panel');

    const roleText = document.getElementById('role-text');
    const tinyStatus = document.getElementById('tiny-status');
    const tinyRoom = document.getElementById('tiny-room');

    const hostOnlyScenes = document.getElementById('host-only-scenes');
    const hostOnlyProfile = document.getElementById('host-only-profile');
    const hostOnlyMap = document.getElementById('host-only-map');
    const hostOnlyPlayers = document.getElementById('host-only-players');
    const hostOnlyAssets = document.getElementById('host-only-assets');
    const hostOnlyClear = document.getElementById('host-only-clear');

    const btnLockAll = document.getElementById('btn-lock-all');
    const btnLockMap = document.getElementById('btn-lock-map');
    const btnInvite = document.getElementById('btn-invite');
    const btnD20 = document.getElementById('btn-d20');
    const btnD6 = document.getElementById('btn-d6');
    const btnFog = document.getElementById('btn-fog');
    const btnLayers = document.getElementById('btn-layers');
    const btnInspector = document.getElementById('btn-inspector');

    const layersPanel = document.getElementById('layers-panel');
    const layersList = document.getElementById('layers-list');

    const inspector = document.getElementById('inspector');
    const inspectorSub = document.getElementById('inspector-sub');

    const iName = document.getElementById('i-name');
    const iLayer = document.getElementById('i-layer');
    const iSize  = document.getElementById('i-size');
    const iRot   = document.getElementById('i-rot');
    const iZoom  = document.getElementById('i-zoom');
    const iFit   = document.getElementById('i-fit');
    const iFog   = document.getElementById('i-fog');

    const vName  = document.getElementById('v-name');
    const vLayer = document.getElementById('v-layer');
    const vLocked= document.getElementById('v-locked');
    const vSize  = document.getElementById('v-size');
    const vRot   = document.getElementById('v-rot');
    const vZoom  = document.getElementById('v-zoom');
    const vFit   = document.getElementById('v-fit');
    const vFog   = document.getElementById('v-fog');

    const fogEmitterPill = document.getElementById('i-fog-emitter');

    // ===== Camera =====
    let scale = 1;
    let posX = window.innerWidth/2 - 5000;
    let posY = window.innerHeight/2 - 5000;
    let isPanning=false;
    let startPan={x:0,y:0};
    function updateTransform(){ canvas.style.transform = `translate(${posX}px, ${posY}px) scale(${scale})`; }
    updateTransform();

    // ===== Selection =====
    let selectedToken=null;

    // ===== Networking =====
    let peer, connections=[], hostConnection=null;
    let myId=null;
    let isHost=false;

    const PEER_ICE_CONFIG = {
      iceServers: [
        { urls: "stun:stun.l.google.com:19302" },
        { urls: "stun:stun1.l.google.com:19302" },
        { urls: "stun:global.stun.twilio.com:3478" }
      ]
    };

    // ===== State (host authoritative) =====
    const state = {
      version: 1,
      map: { src:null, locked:false, x:0, y:0 }, // layer 0
      tokens: {}, // id -> token
      fog: {
        enabled: false,
        darkness: 0.90,   // 0..1
        softness: 0.20    // 0..1
      }
    };

    // Layers (host controls)
    const layerState = {
      visible: {}, // layer -> bool
      locked: {}   // layer -> bool
    };
    function ensureLayerDefaults(layer){
      if (layer == null) return;
      const l=Number(layer);
      if (!(l in layerState.visible)) layerState.visible[l]=true;
      if (!(l in layerState.locked)) layerState.locked[l]=false;
    }
    function computeTokenZIndex(layer){
      const base=100;
      const l=Number(layer||1);
      return base + l*10;
    }

    // ===== Storage: scenes + profile =====
    const LS_SCENES_KEY = "ttl_scenes_v1";      // { scenes: {name: sceneObj}, order:[name...] }
    const LS_PROFILE_KEY= "ttl_profile_v1";     // profile obj

    const defaultProfile = ()=>({
      version: 1,
      updatedAt: nowISO(),
      maps: [],
      players: [],
      assets: []
    });

    let profileTab = "maps";
    function setProfileTab(tab){
      profileTab=tab;
      document.getElementById('tab-maps').classList.toggle('active', tab==="maps");
      document.getElementById('tab-players').classList.toggle('active', tab==="players");
      document.getElementById('tab-assets').classList.toggle('active', tab==="assets");
      renderProfileGrid();
    }

    function loadProfile(){
      try{
        const raw=localStorage.getItem(LS_PROFILE_KEY);
        if(!raw) return defaultProfile();
        const obj=JSON.parse(raw);
        if(!obj || typeof obj!=="object") return defaultProfile();
        return { ...defaultProfile(), ...obj };
      }catch(e){
        return defaultProfile();
      }
    }
    function saveProfileObj(p){
      p.updatedAt = nowISO();
      localStorage.setItem(LS_PROFILE_KEY, JSON.stringify(p));
    }
    let profile = loadProfile();

    function loadScenesStore(){
      try{
        const raw=localStorage.getItem(LS_SCENES_KEY);
        if(!raw) return {version:1, order:[], scenes:{}};
        const obj=JSON.parse(raw);
        if(!obj || typeof obj!=="object") return {version:1, order:[], scenes:{}};
        obj.order = obj.order || [];
        obj.scenes = obj.scenes || {};
        return obj;
      }catch(e){
        return {version:1, order:[], scenes:{}};
      }
    }
    function saveScenesStore(store){
      localStorage.setItem(LS_SCENES_KEY, JSON.stringify(store));
    }
    let scenesStore = loadScenesStore();

    // ===== Fog drawing (multiple emitters union) =====
    function resizeFogCanvas(){
      const dpr = window.devicePixelRatio || 1;
      fogCanvas.width = Math.floor(window.innerWidth * dpr);
      fogCanvas.height= Math.floor(window.innerHeight * dpr);
      fogCanvas.style.width = window.innerWidth+"px";
      fogCanvas.style.height= window.innerHeight+"px";
      fogCtx.setTransform(dpr,0,0,dpr,0,0);
      requestFogRedraw();
    }
    window.addEventListener('resize', ()=>{ resizeFogCanvas(); });
    resizeFogCanvas();

    let fogRAF=null;
    function requestFogRedraw(){
      if (fogRAF) return;
      fogRAF=requestAnimationFrame(()=>{
        fogRAF=null;
        drawFog();
        if (!isHost) updatePlayerVisibilityByFog(); // players hide tokens
      });
    }

    function tokenCenterBoardPx(tokenEl){
      const x = parseFloat(tokenEl.style.left) + (parseFloat(tokenEl.style.width)/2);
      const y = parseFloat(tokenEl.style.top)  + (parseFloat(tokenEl.style.height)/2);
      return {x,y};
    }
    function boardToScreen(x,y){
      return {
        sx: posX + x*scale,
        sy: posY + y*scale
      };
    }

    function drawFog(){
      const enabled = !!state.fog.enabled;
      // Host: fog pode ficar desligado visualmente (ele v√™ tudo), mas se enabled, podemos mostrar overlay leve opcional.
      // Player: overlay sempre ON quando enabled.
      const showOverlay = enabled && (!isHost); // somente player v√™ overlay
      fogOverlay.classList.toggle('on', showOverlay);

      // Mesmo que host n√£o veja, a l√≥gica de visibilidade do player depende disso
      // Desenha apenas se for player (ou se quiser ver em debug), aqui desenhamos sempre para simplificar
      fogCtx.clearRect(0,0,window.innerWidth,window.innerHeight);

      if (!enabled){
        return;
      }

      // Preenche com preto
      const alpha = clamp(Number(state.fog.darkness||0.9), 0.1, 0.98);
      fogCtx.globalCompositeOperation = 'source-over';
      fogCtx.fillStyle = `rgba(0,0,0,${alpha})`;
      fogCtx.fillRect(0,0,window.innerWidth,window.innerHeight);

      // Abre buracos com union: destination-out
      fogCtx.globalCompositeOperation = 'destination-out';

      const softness = clamp(Number(state.fog.softness||0.2), 0.02, 0.6);

      // Emitters = tokens com fogEmitter true
      const emitters = [];
      for (const id in state.tokens){
        const t = state.tokens[id];
        if (t && t.fogEmitter === true){
          const el=document.getElementById(`token-${id}`);
          if (!el) continue;
          // se layer invis√≠vel, ainda pode revelar? normalmente n√£o; aqui revelador ignora visibilidade layer pra fog ser consistente
          emitters.push({ id, el, radius: clamp(Number(t.visionRadius||600), 50, 8000) });
        }
      }

      // Se nenhum emitter, tudo escuro para player (overlay total)
      for (const em of emitters){
        const c = tokenCenterBoardPx(em.el);
        const scr = boardToScreen(c.x, c.y);
        const r = em.radius * scale;

        const inner = Math.max(0, r*(1-softness));
        const grad = fogCtx.createRadialGradient(scr.sx, scr.sy, inner, scr.sx, scr.sy, r);
        grad.addColorStop(0, "rgba(0,0,0,1)");
        grad.addColorStop(1, "rgba(0,0,0,0)");
        fogCtx.fillStyle = grad;
        fogCtx.beginPath();
        fogCtx.arc(scr.sx, scr.sy, r, 0, Math.PI*2);
        fogCtx.fill();
      }

      fogCtx.globalCompositeOperation = 'source-over';
    }

    // Player: hide tokens that are outside all vision areas (except map)
    function updatePlayerVisibilityByFog(){
      if (isHost) return;
      const enabled = !!state.fog.enabled;

      const emitterCenters = [];
      if (enabled){
        for (const id in state.tokens){
          const t = state.tokens[id];
          if (t && t.fogEmitter === true){
            const el=document.getElementById(`token-${id}`);
            if (!el) continue;
            const c=tokenCenterBoardPx(el);
            const r=clamp(Number(t.visionRadius||600), 50, 8000);
            emitterCenters.push({x:c.x, y:c.y, r});
          }
        }
      }

      document.querySelectorAll('.token').forEach(el=>{
        const id=el.dataset.uuid;
        const tok=state.tokens[id];
        if (!tok) return;

        // se fog OFF: tudo vis√≠vel
        if (!enabled){
          el.classList.remove('hidden-by-fog');
          return;
        }

        // Se n√£o existe nenhum emitter, tudo some (tokens) pro player
        if (emitterCenters.length === 0){
          el.classList.add('hidden-by-fog');
          return;
        }

        const c=tokenCenterBoardPx(el);
        let visible=false;
        for (const em of emitterCenters){
          const dx=c.x-em.x, dy=c.y-em.y;
          if ((dx*dx+dy*dy) <= (em.r*em.r)){
            visible=true; break;
          }
        }
        if (visible) el.classList.remove('hidden-by-fog');
        else el.classList.add('hidden-by-fog');
      });
    }

    // ===== UI toggles =====
    function toggleHUD(){ document.body.classList.toggle('hud-hidden'); }
    function toggleSidebar(){ sidebar.classList.toggle('open'); }
    function toggleGrid(){ gridLayer.style.display = (gridLayer.style.display === 'none') ? 'block' : 'none'; }
    function toggleNetworkPanel(){ networkPanel.classList.toggle('show'); }

    function toggleLayersPanel(){
      if (!isHost) return alert("Apenas o Host gerencia camadas.");
      layersPanel.classList.toggle('show');
      rebuildLayersPanel();
    }
    function toggleInspector(){
      if (!isHost) return;
      inspector.classList.toggle('show');
      syncInspectorFromSelection();
    }

    function setRoleUI(){
      roleText.textContent = isHost ? "HOST (Mestre)" : "PLAYER";
      hostOnlyScenes.style.display = isHost ? "" : "none";
      hostOnlyProfile.style.display = isHost ? "" : "none";
      hostOnlyMap.style.display = isHost ? "" : "none";
      hostOnlyPlayers.style.display = isHost ? "" : "none";
      hostOnlyAssets.style.display = isHost ? "" : "none";
      hostOnlyClear.style.display = isHost ? "" : "none";

      btnLockAll.style.display = isHost ? "" : "none";
      btnLockMap.style.display = isHost ? "" : "none";
      btnInvite.style.display = isHost ? "" : "none";
      btnD20.style.display = isHost ? "" : "none";
      btnD6.style.display = isHost ? "" : "none";
      btnFog.style.display = isHost ? "" : "none";
      btnLayers.style.display = isHost ? "" : "none";
      btnInspector.style.display = isHost ? "" : "none";
      inspector.style.display = isHost ? "" : "none";
    }

    // ===== Invite =====
    function copyInviteLink(){
      if (!myId) return alert("Aguarde a conex√£o...");
      if (!isHost) return alert("Apenas o Host copia convite.");
      const u = new URL(window.location.href);
      u.searchParams.set('room', myId);
      const invite = u.toString();

      if (navigator.clipboard?.writeText){
        navigator.clipboard.writeText(invite).then(()=>showNotification("Link copiado!")).catch(()=>prompt("Copie:", invite));
      } else prompt("Copie:", invite);
    }

    // ===== Camera controls =====
    viewport.addEventListener('wheel',(e)=>{
      if (e.ctrlKey) return;
      e.preventDefault();
      const zoomSpeed=.15;
      const delta = e.deltaY>0 ? -zoomSpeed : zoomSpeed;
      const newScale = clamp(scale+delta, .05, 4);

      const mx=e.clientX,my=e.clientY;
      const cx=(mx-posX)/scale, cy=(my-posY)/scale;

      scale = newScale;
      posX = mx - cx*scale;
      posY = my - cy*scale;
      updateTransform();
      requestFogRedraw();
    },{passive:false});

    window.addEventListener('mousedown',(e)=>{
      if (e.button===2 || e.button===1 || (e.button===0 && e.altKey)){
        isPanning=true;
        startPan={x:e.clientX-posX,y:e.clientY-posY};
        viewport.style.cursor='grabbing';
      }
    });
    window.addEventListener('mousemove',(e)=>{
      if (isPanning){
        posX=e.clientX-startPan.x;
        posY=e.clientY-startPan.y;
        updateTransform();
        requestFogRedraw();
      }
    });
    window.addEventListener('mouseup',()=>{ isPanning=false; viewport.style.cursor='grab'; });

    // ===== Map palpable with inertia =====
    let mapDragging=false;
    let mapDragStart={mx:0,my:0,x:0,y:0};
    let mapVel={vx:0,vy:0};
    let mapLastMove={t:0,x:0,y:0};
    let mapInertiaRAF=null;

    function setMapOffset(x,y){
      state.map.x = x;
      state.map.y = y;
      mapContainer.style.transform = `translate(${x}px, ${y}px)`;
    }
    function stopMapInertia(){
      if (mapInertiaRAF) cancelAnimationFrame(mapInertiaRAF);
      mapInertiaRAF=null;
    }
    function startMapInertia(){
      stopMapInertia();
      const friction=0.92, minV=0.05;

      const step=()=>{
        mapVel.vx*=friction;
        mapVel.vy*=friction;

        if (Math.abs(mapVel.vx)<minV && Math.abs(mapVel.vy)<minV){
          mapVel.vx=0; mapVel.vy=0;
          stopMapInertia();
          if (isHost){
            const a={type:"MAP_MOVE", x:state.map.x, y:state.map.y};
            applyAction(a,false); broadcastACT(a);
          }
          return;
        }
        setMapOffset(state.map.x + mapVel.vx, state.map.y + mapVel.vy);
        mapInertiaRAF=requestAnimationFrame(step);
      };
      mapInertiaRAF=requestAnimationFrame(step);
    }

    function setMapLockLocal(lock, emit){
      state.map.locked = !!lock;
      mapContainer.classList.toggle('locked', state.map.locked);
      if (state.map.locked){
        btnLockMap.innerHTML="üîí Mapa Fixo"; btnLockMap.classList.add('active');
      } else {
        btnLockMap.innerHTML="üîì Mapa M√≥vel"; btnLockMap.classList.remove('active');
      }
      if (emit && isHost){
        const a={type:"MAP_LOCK", locked:state.map.locked};
        applyAction(a,false); broadcastACT(a);
      }
    }
    function toggleMapLock(){
      if (!isHost) return;
      setMapLockLocal(!state.map.locked,true);
    }

    mapContainer.addEventListener('mousedown',(e)=>{
      if (!isHost) return;
      if (state.map.locked) return;
      const img = mapContainer.querySelector('img');
      if (!img) return;

      if (e.button!==0 || e.altKey) return;
      e.preventDefault();
      e.stopPropagation();

      mapDragging=true;
      mapContainer.classList.add('dragging');
      stopMapInertia();

      mapDragStart={mx:e.clientX,my:e.clientY,x:state.map.x,y:state.map.y};
      mapVel={vx:0,vy:0};
      mapLastMove={t:performance.now(), x:state.map.x, y:state.map.y};

      const onMove=(me)=>{
        if (!mapDragging) return;
        const dx=(me.clientX-mapDragStart.mx)/scale;
        const dy=(me.clientY-mapDragStart.my)/scale;

        const nx=mapDragStart.x+dx;
        const ny=mapDragStart.y+dy;
        setMapOffset(nx,ny);

        const now=performance.now();
        const dt=Math.max(1, now-mapLastMove.t);
        mapVel.vx=(nx-mapLastMove.x)/dt*16;
        mapVel.vy=(ny-mapLastMove.y)/dt*16;
        mapLastMove={t:now,x:nx,y:ny};
      };

      const onUp=()=>{
        mapDragging=false;
        mapContainer.classList.remove('dragging');
        document.removeEventListener('mousemove',onMove);
        document.removeEventListener('mouseup',onUp);

        const a={type:"MAP_MOVE", x:state.map.x, y:state.map.y};
        applyAction(a,false); broadcastACT(a);

        startMapInertia();
      };

      document.addEventListener('mousemove',onMove);
      document.addEventListener('mouseup',onUp);
    });

    function applyMapLocal(src, emit){
      const img=new Image();
      img.onload=()=>{
        mapContainer.innerHTML="";
        mapContainer.appendChild(img);

        // Centraliza visual
        scale = Math.min(window.innerWidth / img.width, window.innerHeight / img.height, 1) * 0.8;
        posX = window.innerWidth/2 - (img.width*scale)/2;
        posY = window.innerHeight/2 - (img.height*scale)/2;
        updateTransform();
        requestFogRedraw();
      };
      img.src=src;

      if (emit && isHost){
        const a={type:"MAP_UPDATE", src};
        applyAction(a,false); broadcastACT(a);
      }
    }

    // ===== Token helpers =====
    function normalizeTokenProps(id, src, type, props){
      const p=props||{};
      const layer = Number(p.layer ?? 1);
      ensureLayerDefaults(layer);
      return {
        id, src, type,
        kind: p.kind ?? "asset",
        name: p.name ?? "",
        layer,
        x: p.x ?? "0px",
        y: p.y ?? "0px",
        w: p.w ?? 180,
        h: p.h ?? 180,
        rotation: p.rotation ?? 0,
        flipped: p.flipped ?? "false",
        innerZoom: p.innerZoom ?? 1,
        locked: p.locked ?? "false",
        fitMode: p.fitMode ?? "contain",
        fogEmitter: !!p.fogEmitter,
        visionRadius: p.visionRadius ?? 600
      };
    }
    function updateImgTransform(token){
      const el = token.querySelector('img') || token.querySelector('iframe');
      if (!el) return;
      if (el.tagName==="IMG") el.style.objectFit = token.dataset.fitMode || "contain";

      const rotation = token.dataset.rotation || 0;
      const flipped = token.dataset.flipped === "true";
      const innerZoom= token.dataset.innerZoom || 1;
      el.style.transform = `scale(${innerZoom}) rotate(${rotation}deg) scaleX(${flipped?-1:1})`;
    }

    function applyLayerVisibilityToDOM(){
      for (const el of document.querySelectorAll('.token')){
        const layer = Number(el.dataset.layer || 1);
        ensureLayerDefaults(layer);
        el.style.display = layerState.visible[layer] ? "" : "none";
      }
      if (!isHost) updatePlayerVisibilityByFog();
    }

    // ===== Tokens: create/add DOM =====
    function hostCreateToken(src, kind){
      if (!isHost) return;

      const id = generateUUID();
      const contentType = "image";

      // layer din√¢mica: se existe token, usa a maior layer atual; sen√£o, layer 1
      const layers = Object.values(state.tokens).map(t=>Number(t.layer||1));
      const baseLayer = layers.length ? Math.max(...layers) : 1;
      ensureLayerDefaults(baseLayer);

      let width = 180, height=180;

      const centerX = (window.innerWidth/2 - posX)/scale;
      const centerY = (window.innerHeight/2 - posY)/scale;

      const props = {
        kind,
        name: "",
        layer: baseLayer,
        x: (centerX - width/2) + "px",
        y: (centerY - height/2) + "px",
        w: width,
        h: height,
        rotation: 0,
        flipped: "false",
        innerZoom: 1,
        locked: "false",
        fitMode: "contain",
        fogEmitter: false,
        visionRadius: 600
      };

      const a = { type:"CREATE_TOKEN", id, src, contentType, props };
      applyAction(a,false); broadcastACT(a);
      rebuildLayersPanel();
      applyLayerVisibilityToDOM();
      requestFogRedraw();
    }

    function addTokenLocal(src, contentType, id, props){
      if (document.getElementById(`token-${id}`)) return;

      const token=document.createElement('div');
      token.id=`token-${id}`;
      token.className="token";
      token.dataset.uuid=id;
      token.dataset.type=contentType;

      const layer = Number(props?.layer ?? 1);
      const kind = props?.kind ?? "asset";
      ensureLayerDefaults(layer);

      token.dataset.layer = String(layer);
      token.dataset.kind = kind;
      token.dataset.name = props?.name ?? "";

      const width = props?.w ? parseInt(props.w) : 180;
      const height= props?.h ? parseInt(props.h) : 180;
      token.style.width = width+"px";
      token.style.height= height+"px";

      token.style.left = props?.x ?? "0px";
      token.style.top  = props?.y ?? "0px";

      token.dataset.sizeW = width;
      token.dataset.sizeH = height;
      token.dataset.rotation = props?.rotation ?? 0;
      token.dataset.flipped  = props?.flipped ?? "false";
      token.dataset.innerZoom= props?.innerZoom ?? 1;
      token.dataset.locked   = props?.locked ?? "false";
      token.dataset.fitMode  = props?.fitMode ?? "contain";
      token.dataset.fogEmitter = (props?.fogEmitter ? "true" : "false");
      token.dataset.visionRadius = props?.visionRadius ?? 600;

      token.style.zIndex = String(computeTokenZIndex(layer));
      token.style.display = layerState.visible[layer] ? "" : "none";

      if (token.dataset.locked==="true"){
        token.classList.add('locked');
        token.style.pointerEvents="none";
      }

      const blocker=document.createElement('div');
      blocker.className="token-blocker";

      const wrapper=document.createElement('div');
      wrapper.className="token-content-wrapper";

      let content;
      if (contentType==="image"){
        content=document.createElement('img');
        content.src=src;
        // dica: melhora ‚Äúportrait‚Äù
        content.decoding = "async";
        content.loading = "lazy";
      } else {
        content=document.createElement('iframe');
        content.src=src;
        content.setAttribute('frameborder','0');
        content.setAttribute('sandbox','allow-scripts allow-same-origin');
      }

      const handle=document.createElement('div');
      handle.className="resize-handle";

      wrapper.appendChild(content);
      token.appendChild(blocker);
      token.appendChild(wrapper);
      token.appendChild(handle);

      canvas.appendChild(token);
      setTimeout(()=>updateImgTransform(token), 0);

      // Select + Drag
      token.addEventListener('mousedown',(e)=>{
        if (e.button!==0 || e.altKey) return;
        if (token.dataset.locked==="true") return;
        const layer = Number(token.dataset.layer||1);
        if (layerState.locked[layer]) return;

        e.stopPropagation();
        selectToken(token);
        startDraggingToken(e, token);
      });

      // Resize handle
      handle.addEventListener('mousedown',(e)=>{
        if (token.dataset.locked==="true") return;
        const layer = Number(token.dataset.layer||1);
        if (layerState.locked[layer]) return;
        if (e.button!==0) return;

        e.stopPropagation(); e.preventDefault();

        const startX=e.clientX;
        const startW=parseInt(token.dataset.sizeW);
        const startH=parseInt(token.dataset.sizeH);
        const ratio=startH/startW;

        let pendingW=startW, pendingH=startH;

        const onMove=(me)=>{
          const deltaW=((me.clientX-startX)/scale)*1.5;
          let w=clamp(startW+deltaW, 40, 2500);
          let h=clamp(Math.round(w*ratio), 40, 2500);

          pendingW=w; pendingH=h;
          token.dataset.sizeW=pendingW;
          token.dataset.sizeH=pendingH;
          token.style.width=pendingW+"px";
          token.style.height=pendingH+"px";
          requestFogRedraw();
        };

        const onUp=()=>{
          document.removeEventListener('mousemove',onMove);
          document.removeEventListener('mouseup',onUp);

          const action={type:"UPDATE_PROP", id:token.dataset.uuid, prop:"size", value:{w:pendingW,h:pendingH}};
          if (isHost){ applyAction(action,false); broadcastACT(action); }
          else sendREQ(action);
        };

        document.addEventListener('mousemove',onMove);
        document.addEventListener('mouseup',onUp);
      });

      // Ctrl+wheel resize
      token.addEventListener('wheel',(e)=>{
        if (!e.ctrlKey) return;
        if (token.dataset.locked==="true") return;
        const layer = Number(token.dataset.layer||1);
        if (layerState.locked[layer]) return;

        e.preventDefault(); e.stopPropagation();
        const delta = e.deltaY>0 ? -25 : 25;

        const w0=parseInt(token.dataset.sizeW), h0=parseInt(token.dataset.sizeH);
        const ratio=h0/w0;
        const w=clamp(w0+delta, 40, 2500);
        const h=clamp(Math.round(w*ratio), 40, 2500);

        const action={type:"UPDATE_PROP", id:token.dataset.uuid, prop:"size", value:{w,h}};
        if (isHost){ applyAction(action,false); broadcastACT(action); }
        else sendREQ(action);
      },{passive:false});
    }

    function selectToken(token){
      if (selectedToken) selectedToken.classList.remove('selected');
      selectedToken = token;
      selectedToken.classList.add('selected');
      syncInspectorFromSelection();
      requestFogRedraw();
    }

    function startDraggingToken(e, token){
      let startX=e.clientX, startY=e.clientY;
      let initialLeft=parseFloat(token.style.left);
      let initialTop=parseFloat(token.style.top);
      let moved=false;

      function onMove(me){
        moved=true;
        let dx=(me.clientX-startX)/scale;
        let dy=(me.clientY-startY)/scale;
        let newX=initialLeft+dx;
        let newY=initialTop+dy;

        if (gridLayer.style.display !== 'none'){
          newX=Math.round(newX/50)*50;
          newY=Math.round(newY/50)*50;
        }
        token.style.left=newX+"px";
        token.style.top=newY+"px";
        requestFogRedraw();
      }
      function onUp(){
        document.removeEventListener('mousemove',onMove);
        document.removeEventListener('mouseup',onUp);
        if (!moved) return;

        const action={type:"MOVE", id:token.dataset.uuid, x:token.style.left, y:token.style.top};
        if (isHost){ applyAction(action,false); broadcastACT(action); }
        else sendREQ(action);
      }
      document.addEventListener('mousemove',onMove);
      document.addEventListener('mouseup',onUp);
    }

    function moveTokenDOM(id,x,y){
      const t=document.getElementById(`token-${id}`);
      if (!t) return;
      t.style.left=x;
      t.style.top=y;
      requestFogRedraw();
    }

    function updateTokenPropDOM(id, prop, value){
      const token=document.getElementById(`token-${id}`);
      if(!token) return;

      if (prop==="name"){
        token.dataset.name = String(value||"");
      }
      else if (prop==="locked"){
        token.dataset.locked = String(value);
        if (String(value)==="true"){
          token.classList.add('locked');
          token.style.pointerEvents="none";
          token.classList.remove('selected');
          if (selectedToken?.dataset.uuid===id) selectedToken=null;
        } else {
          token.classList.remove('locked');
          token.style.pointerEvents="auto";
        }
      } else if (prop==="innerZoom"){
        token.dataset.innerZoom = value;
        updateImgTransform(token);
      } else if (prop==="rotation"){
        token.dataset.rotation = value;
        updateImgTransform(token);
      } else if (prop==="flipped"){
        token.dataset.flipped = value;
        updateImgTransform(token);
      } else if (prop==="fitMode"){
        token.dataset.fitMode = value;
        updateImgTransform(token);
      } else if (prop==="size"){
        token.style.width=value.w+"px";
        token.style.height=value.h+"px";
        token.dataset.sizeW=value.w;
        token.dataset.sizeH=value.h;
      } else if (prop==="layer"){
        const newLayer=Number(value);
        ensureLayerDefaults(newLayer);
        token.dataset.layer=String(newLayer);
        token.style.zIndex=String(computeTokenZIndex(newLayer));
        token.style.display = layerState.visible[newLayer] ? "" : "none";
      } else if (prop==="fogEmitter"){
        token.dataset.fogEmitter = value ? "true" : "false";
      } else if (prop==="visionRadius"){
        token.dataset.visionRadius = Number(value);
      }

      syncInspectorFromSelection();
      requestFogRedraw();
    }

    function removeTokenLocal(id){
      const t=document.getElementById(`token-${id}`);
      if (t) t.remove();
      if (selectedToken?.dataset.uuid===id) selectedToken=null;
      requestFogRedraw();
      syncInspectorFromSelection();
    }

    // ===== Inspector sync =====
    function syncInspectorFromSelection(){
      if (!isHost) return;

      if (!selectedToken){
        inspectorSub.textContent="Selecione um token.";
        vName.textContent="-"; vLayer.textContent="-"; vLocked.textContent="-"; vSize.textContent="-";
        vRot.textContent="-"; vZoom.textContent="-"; vFit.textContent="-"; vFog.textContent="-";
        iName.value=""; iLayer.value=1;
        fogEmitterPill.classList.remove('active');
        return;
      }

      const id=selectedToken.dataset.uuid;
      inspectorSub.textContent=`Selecionado: ${id.slice(-6)} ‚Ä¢ ${selectedToken.dataset.kind}`;

      const name = selectedToken.dataset.name || "";
      const layer = Number(selectedToken.dataset.layer||1);
      const locked= (selectedToken.dataset.locked==="true");
      const w = Number(selectedToken.dataset.sizeW||parseFloat(selectedToken.style.width)||180);
      const rot= Number(selectedToken.dataset.rotation||0);
      const zoom=Number(selectedToken.dataset.innerZoom||1);
      const fit=String(selectedToken.dataset.fitMode||"contain");
      const fog=Number(selectedToken.dataset.visionRadius||600);
      const emitter = (selectedToken.dataset.fogEmitter==="true");

      vName.textContent = name ? name : "(sem nome)";
      vLayer.textContent=String(layer);
      vLocked.textContent=locked ? "TRAVADO" : "LIVRE";
      vSize.textContent=`${Math.round(w)}px`;
      vRot.textContent=`${Math.round(rot)}¬∞`;
      vZoom.textContent=`${zoom.toFixed(2)}x`;
      vFit.textContent=fit;
      vFog.textContent=`${Math.round(fog)}px`;

      iName.value = name;
      iLayer.value = String(layer);
      iSize.value  = String(clamp(w, 40, 2500));
      iRot.value   = String(clamp(rot, 0, 359));
      iZoom.value  = String(clamp(zoom, 0.2, 5));
      iFit.value   = fit;
      iFog.value   = String(clamp(fog, 50, 2500));

      fogEmitterPill.classList.toggle('active', emitter);
    }

    function inspectorApplyProp(prop, value){
      if (!selectedToken || !isHost) return;
      const id=selectedToken.dataset.uuid;
      const action={type:"UPDATE_PROP", id, prop, value};
      applyAction(action,false); broadcastACT(action);
    }

    iName.addEventListener('change',()=>inspectorApplyProp("name", iName.value));
    iLayer.addEventListener('change',()=>inspectorApplyProp("layer", clamp(Number(iLayer.value||1), 1, 50)));
    iRot.addEventListener('input',()=>inspectorApplyProp("rotation", clamp(Number(iRot.value||0), 0, 359)));
    iZoom.addEventListener('input',()=>inspectorApplyProp("innerZoom", clamp(Number(iZoom.value||1), 0.2, 5)));
    iFit.addEventListener('change',()=>inspectorApplyProp("fitMode", iFit.value));
    iFog.addEventListener('input',()=>inspectorApplyProp("visionRadius", clamp(Number(iFog.value||600), 50, 8000)));
    iSize.addEventListener('input',()=>{
      if (!selectedToken || !isHost) return;
      const w = clamp(Number(iSize.value||180), 40, 2500);
      const w0 = Number(selectedToken.dataset.sizeW||w);
      const h0 = Number(selectedToken.dataset.sizeH||w);
      const ratio = (w0>0) ? (h0/w0) : 1;
      const h = clamp(Math.round(w*ratio), 40, 2500);
      inspectorApplyProp("size",{w,h});
    });

    function inspectorToggleLock(){
      if (!selectedToken || !isHost) return;
      const next = selectedToken.dataset.locked==="true" ? "false" : "true";
      inspectorApplyProp("locked", next);
    }
    function inspectorUnlock(){
      if (!selectedToken || !isHost) return;
      inspectorApplyProp("locked","false");
    }
    function inspectorToggleFogEmitter(){
      if (!selectedToken || !isHost) return;
      const next = (selectedToken.dataset.fogEmitter==="true") ? false : true;
      inspectorApplyProp("fogEmitter", next);
    }
    function inspectorBringFront(){
      if (!selectedToken || !isHost) return;
      const l = clamp(Number(selectedToken.dataset.layer||1)+1, 1, 50);
      inspectorApplyProp("layer", l);
      rebuildLayersPanel();
    }
    function inspectorSendBack(){
      if (!selectedToken || !isHost) return;
      const l = clamp(Number(selectedToken.dataset.layer||1)-1, 1, 50);
      inspectorApplyProp("layer", l);
      rebuildLayersPanel();
    }
    function inspectorReset(){
      if (!selectedToken || !isHost) return;
      const id=selectedToken.dataset.uuid;
      const acts=[
        {type:"UPDATE_PROP", id, prop:"innerZoom", value:1},
        {type:"UPDATE_PROP", id, prop:"rotation", value:0},
        {type:"UPDATE_PROP", id, prop:"flipped", value:"false"},
        {type:"UPDATE_PROP", id, prop:"fitMode", value:"contain"},
      ];
      acts.forEach(a=>{ applyAction(a,false); broadcastACT(a); });
    }
    function inspectorDelete(){
      if (!selectedToken || !isHost) return;
      const id=selectedToken.dataset.uuid;
      const a={type:"REMOVE_TOKEN", id};
      applyAction(a,false); broadcastACT(a);
    }

    function inspectorAddToProfile(){
      if (!selectedToken || !isHost) return;
      const id=selectedToken.dataset.uuid;
      const t=state.tokens[id];
      if (!t) return;

      const entry = {
        id: generateUUID(),
        name: (t.name && t.name.trim()) ? t.name.trim() : `${t.kind}-${id.slice(-6)}`,
        kind: t.kind,
        src: t.src,
        type: t.type || "image",
        createdAt: nowISO()
      };

      profile = loadProfile();
      if (t.kind==="map"){
        profile.maps.unshift(entry);
      } else if (t.kind==="player"){
        profile.players.unshift(entry);
      } else {
        profile.assets.unshift(entry);
      }
      saveProfileObj(profile);
      renderProfileGrid();
      showNotification("Salvo no Perfil!");
    }

    // ===== Fog toggle =====
    function toggleFog(){
      if (!isHost) return alert("Apenas o Host controla o Fog.");
      const a = { type:"FOG_SET", prop:"enabled", value: !state.fog.enabled };
      applyAction(a,false); broadcastACT(a);
      showNotification(state.fog.enabled ? "Fog ON" : "Fog OFF");
    }

    // ===== Layers panel =====
    function rebuildLayersPanel(){
      if (!isHost) return;

      const layers = Array.from(new Set(Object.values(state.tokens).map(t=>Number(t.layer||1)))).sort((a,b)=>a-b);
      layersList.innerHTML="";

      // Layer 0 - mapa
      const row0=document.createElement('div');
      row0.className="layer-row";
      row0.innerHTML = `
        <div><b>Layer 0</b> <span class="mini">(Mapa)</span></div>
        <div style="display:flex;gap:10px;flex-wrap:wrap;">
          <div class="pill active" style="pointer-events:none;opacity:.85;">Sempre vis√≠vel</div>
          <div class="pill ${state.map.locked?'active':''}" onclick="toggleMapLock()">Mapa ${state.map.locked?'Trancado':'Livre'}</div>
        </div>
      `;
      layersList.appendChild(row0);

      if (!layers.length){
        const empty=document.createElement('div');
        empty.className="mini";
        empty.style.padding="10px 2px";
        empty.textContent="Nenhuma layer de tokens ainda. Adicione pe√ßas/players para criar.";
        layersList.appendChild(empty);
        return;
      }

      for (const l of layers){
        ensureLayerDefaults(l);
        const row=document.createElement('div');
        row.className="layer-row";

        const left=document.createElement('div');
        left.innerHTML = `<b>Layer ${l}</b> <span class="mini">(tokens)</span>`;

        const actions=document.createElement('div');
        actions.style.display="flex";
        actions.style.gap="10px";
        actions.style.flexWrap="wrap";

        const vis=document.createElement('div');
        vis.className = "pill " + (layerState.visible[l] ? "active" : "");
        vis.textContent = layerState.visible[l] ? "Vis√≠vel" : "Oculta";
        vis.onclick=()=>{
          const a={type:"LAYER_SET", layer:l, prop:"visible", value:!layerState.visible[l]};
          applyAction(a,false); broadcastACT(a);
        };

        const lock=document.createElement('div');
        lock.className = "pill " + (layerState.locked[l] ? "active" : "");
        lock.textContent = layerState.locked[l] ? "Trancada" : "Livre";
        lock.onclick=()=>{
          const a={type:"LAYER_SET", layer:l, prop:"locked", value:!layerState.locked[l]};
          applyAction(a,false); broadcastACT(a);
        };

        actions.appendChild(vis);
        actions.appendChild(lock);

        row.appendChild(left);
        row.appendChild(actions);
        layersList.appendChild(row);
      }
    }

    // ===== Dice =====
    function rollDice(faces){
      if (!isHost) return;
      const res=Math.floor(Math.random()*faces)+1;
      const a={type:"DICE", faces, result:res};
      applyAction(a,false); broadcastACT(a);
    }
    function showDiceLog(faces,res){
      const entry=document.createElement('div');
      entry.className="dice-entry mb-2 border-l-2 border-gold pl-3 opacity-0 transform translate-x-4 transition-all duration-300";
      entry.innerHTML=`<span class="opacity-50 text-[10px] font-bold">D${faces}:</span> <b class="text-white text-lg">${res}</b>`;
      diceLogEntries.prepend(entry);
      setTimeout(()=>entry.classList.remove('opacity-0','translate-x-4'),10);
    }

    // ===== Imports =====
    function isImageUrl(url){
      return (url.match(/\.(jpeg|jpg|gif|png|webp|avif)$/i)!=null) || url.startsWith('data:image');
    }

    function importFromUrl(inputId, type){
      if (!isHost) return alert("Apenas o Host importa.");
      const url=document.getElementById(inputId).value.trim();
      if (!url) return;

      if (type==="map"){
        if (!isImageUrl(url)) return alert("Mapa precisa ser imagem direta.");
        applyMapLocal(url,true);
        document.getElementById(inputId).value="";
        return;
      }

      if (!isImageUrl(url)) return alert("Tokens precisam ser imagens diretas.");
      if (type==="player") hostCreateToken(url,"player");
      else hostCreateToken(url,"asset");

      document.getElementById(inputId).value="";
    }

    function importAsset(event, type){
      if (!isHost) return alert("Apenas o Host importa.");
      const file=event.target.files?.[0];
      if (!file) return;
      const reader=new FileReader();
      reader.onload=(e)=>{
        const dataUrl=e.target.result;
        if (type==="map") applyMapLocal(dataUrl,true);
        else if (type==="player") hostCreateToken(dataUrl,"player");
        else hostCreateToken(dataUrl,"asset");
      };
      reader.readAsDataURL(file);
    }

    // ===== Profile UI =====
    function renderProfileGrid(){
      const grid=document.getElementById('profile-grid');
      grid.innerHTML="";

      profile = loadProfile();
      const list = profile[profileTab] || [];

      if (!list.length){
        const msg=document.createElement('div');
        msg.className="mini";
        msg.style.gridColumn="1/-1";
        msg.style.padding="8px 2px";
        msg.textContent="Vazio. Salve itens no perfil pelo Inspector.";
        grid.appendChild(msg);
        return;
      }

      list.slice(0,60).forEach((item,idx)=>{
        const card=document.createElement('div');
        card.className="lib-card";
        const img=document.createElement('img');
        img.className="lib-thumb";
        img.src=item.src;
        const meta=document.createElement('div');
        meta.className="lib-meta";
        meta.innerHTML = `<b>${item.name||"(sem nome)"}</b><span>${item.kind}</span>`;

        card.appendChild(img);
        card.appendChild(meta);

        card.onclick=()=>{
          if (!isHost) return;

          if (profileTab==="maps"){
            // aplicar como mapa
            applyMapLocal(item.src,true);
            showNotification("Mapa aplicado!");
          } else {
            hostCreateToken(item.src, profileTab==="players" ? "player" : "asset");
            showNotification("Item colocado na mesa!");
          }
        };

        card.oncontextmenu=(ev)=>{
          ev.preventDefault();
          if (!isHost) return;
          if (!confirm(`Remover "${item.name}" do perfil?`)) return;

          profile = loadProfile();
          profile[profileTab].splice(idx,1);
          saveProfileObj(profile);
          renderProfileGrid();
        };

        grid.appendChild(card);
      });
    }

    function exportProfile(){
      if (!isHost) return;
      profile = loadProfile();
      const blob=new Blob([JSON.stringify(profile,null,2)], {type:"application/json"});
      const a=document.createElement('a');
      a.href=URL.createObjectURL(blob);
      a.download="perfil.json";
      a.click();
      URL.revokeObjectURL(a.href);
    }
    function importProfileFile(event){
      if (!isHost) return;
      const file=event.target.files?.[0];
      if(!file) return;
      const reader=new FileReader();
      reader.onload=()=>{
        try{
          const obj=JSON.parse(reader.result);
          if(!obj || typeof obj!=="object") throw new Error("json inv√°lido");
          localStorage.setItem(LS_PROFILE_KEY, JSON.stringify(obj));
          profile = loadProfile();
          renderProfileGrid();
          showNotification("Perfil importado!");
        }catch(e){
          alert("JSON inv√°lido.");
        }
      };
      reader.readAsText(file);
      event.target.value="";
    }

    // ===== Scenes: capture/apply =====
    function captureCurrentScene(name){
      // tokens from state are already normalized; ensure latest from DOM
      // (host actions keep state sync, but ensure sizes/pos)
      const tokens = {};
      document.querySelectorAll('.token').forEach(el=>{
        const id=el.dataset.uuid;
        const t=state.tokens[id];
        if(!t) return;

        tokens[id] = {
          ...t,
          x: el.style.left,
          y: el.style.top,
          w: Number(el.dataset.sizeW || parseInt(el.style.width)||t.w),
          h: Number(el.dataset.sizeH || parseInt(el.style.height)||t.h),
          rotation: Number(el.dataset.rotation||t.rotation||0),
          flipped: String(el.dataset.flipped||t.flipped||"false"),
          innerZoom: Number(el.dataset.innerZoom||t.innerZoom||1),
          locked: String(el.dataset.locked||t.locked||"false"),
          fitMode: String(el.dataset.fitMode||t.fitMode||"contain"),
          fogEmitter: (String(el.dataset.fogEmitter||t.fogEmitter) === "true"),
          visionRadius: Number(el.dataset.visionRadius||t.visionRadius||600),
          layer: Number(el.dataset.layer||t.layer||1),
          name: String(el.dataset.name||t.name||""),
        };
      });

      const scene = {
        version: 1,
        name: name || "Sem nome",
        savedAt: nowISO(),
        map: {...state.map},
        fog: {...state.fog},
        layerState: JSON.parse(JSON.stringify(layerState)),
        tokens
      };
      return scene;
    }

    function applyScene(scene, emitNetwork=true){
      if (!isHost) return;

      // clear DOM tokens + map
      document.querySelectorAll('.token').forEach(t=>t.remove());
      mapContainer.innerHTML="";
      diceLogEntries.querySelectorAll('.dice-entry').forEach(l=>l.remove());
      selectedToken=null;

      // apply layerState
      layerState.visible = scene.layerState?.visible || {};
      layerState.locked  = scene.layerState?.locked  || {};

      // apply state
      state.map = scene.map || {src:null,locked:false,x:0,y:0};
      state.fog = scene.fog || {enabled:false,darkness:0.9,softness:0.2};
      state.tokens = {};

      // map
      if (state.map.src) applyMapLocal(state.map.src,false);
      setMapLockLocal(!!state.map.locked,false);
      setMapOffset(Number(state.map.x||0), Number(state.map.y||0));

      // tokens
      const tokens = scene.tokens || {};
      for (const id in tokens){
        const t = tokens[id];
        ensureLayerDefaults(Number(t.layer||1));
        addTokenLocal(t.src, t.type||"image", id, t);
        state.tokens[id]=normalizeTokenProps(id, t.src, t.type||"image", t);
      }

      btnFog.classList.toggle('active', !!state.fog.enabled);
      applyLayerVisibilityToDOM();
      rebuildLayersPanel();
      requestFogRedraw();
      syncInspectorFromSelection();
      renderSceneList();

      // broadcast SYNC to clients
      if (emitNetwork){
        broadcastSYNC();
      }
      showNotification(`Cena carregada: ${scene.name}`);
    }

    // ===== Scenes UI: save/load =====
    function renderSceneList(){
      if (!isHost) return;
      scenesStore = loadScenesStore();
      const listEl=document.getElementById('scene-list');
      listEl.innerHTML="";

      if (!scenesStore.order.length){
        const msg=document.createElement('div');
        msg.className="mini";
        msg.style.padding="6px 2px";
        msg.textContent="Nenhuma cena salva ainda.";
        listEl.appendChild(msg);
        return;
      }

      scenesStore.order.forEach(name=>{
        const sc=scenesStore.scenes[name];
        if (!sc) return;

        const row=document.createElement('div');
        row.className="scene-row";
        const left=document.createElement('div');
        left.innerHTML = `<b>${name}</b><span>${(sc.savedAt||"").replace("T"," ").slice(0,19)}</span>`;

        const right=document.createElement('div');
        right.style.display="flex";
        right.style.gap="8px";
        right.style.flexWrap="wrap";

        const btnLoad=document.createElement('div');
        btnLoad.className="btn";
        btnLoad.textContent="LOAD";
        btnLoad.onclick=()=>{
          if (!confirm(`Carregar cena "${name}"? (vai substituir a mesa atual)`)) return;
          applyScene(scenesStore.scenes[name], true);
        };

        const btnExp=document.createElement('div');
        btnExp.className="btn";
        btnExp.textContent="EXPORT";
        btnExp.onclick=()=>{
          exportScene(name);
        };

        const btnDel=document.createElement('div');
        btnDel.className="btn";
        btnDel.textContent="DEL";
        btnDel.onclick=()=>{
          if (!confirm(`Apagar cena "${name}" do navegador?`)) return;
          delete scenesStore.scenes[name];
          scenesStore.order = scenesStore.order.filter(n=>n!==name);
          saveScenesStore(scenesStore);
          renderSceneList();
          showNotification("Cena removida.");
        };

        right.appendChild(btnLoad);
        right.appendChild(btnExp);
        right.appendChild(btnDel);

        row.appendChild(left);
        row.appendChild(right);
        listEl.appendChild(row);
      });
    }

    function saveScene(){
      if (!isHost) return;
      const name = (document.getElementById('scene-name').value||"").trim();
      if (!name) return alert("D√™ um nome para a cena.");

      const scene = captureCurrentScene(name);

      scenesStore = loadScenesStore();
      scenesStore.scenes[name] = scene;
      if (!scenesStore.order.includes(name)) scenesStore.order.unshift(name);
      saveScenesStore(scenesStore);
      renderSceneList();
      showNotification("Cena salva!");
    }

    function saveSceneAsNew(){
      if (!isHost) return;
      let name = (document.getElementById('scene-name').value||"").trim();
      if (!name) name="Cena";
      // garante nome √∫nico
      scenesStore=loadScenesStore();
      let base=name, i=1;
      while (scenesStore.scenes[name]){ name = `${base} (${i++})`; }
      document.getElementById('scene-name').value=name;

      const scene = captureCurrentScene(name);
      scenesStore.scenes[name] = scene;
      scenesStore.order.unshift(name);
      saveScenesStore(scenesStore);
      renderSceneList();
      showNotification("Cena salva como nova!");
    }

    function exportScene(name){
      if (!isHost) return;
      scenesStore=loadScenesStore();
      const scene=scenesStore.scenes[name];
      if(!scene) return;
      const blob=new Blob([JSON.stringify(scene,null,2)], {type:"application/json"});
      const a=document.createElement('a');
      a.href=URL.createObjectURL(blob);
      a.download=`scene_${sanitizeFileName(name)}.json`;
      a.click();
      URL.revokeObjectURL(a.href);
    }

    function exportAll(){
      if (!isHost) return;
      scenesStore=loadScenesStore();
      profile=loadProfile();
      const payload={
        version: 1,
        exportedAt: nowISO(),
        scenesStore,
        profile
      };
      const blob=new Blob([JSON.stringify(payload,null,2)], {type:"application/json"});
      const a=document.createElement('a');
      a.href=URL.createObjectURL(blob);
      a.download="tabletop_backup.json";
      a.click();
      URL.revokeObjectURL(a.href);
    }

    function importAllFile(event){
      if (!isHost) return;
      const file=event.target.files?.[0];
      if(!file) return;
      const reader=new FileReader();
      reader.onload=()=>{
        try{
          const obj=JSON.parse(reader.result);
          if(!obj || typeof obj!=="object") throw new Error("inv√°lido");
          if (obj.scenesStore){
            localStorage.setItem(LS_SCENES_KEY, JSON.stringify(obj.scenesStore));
          }
          if (obj.profile){
            localStorage.setItem(LS_PROFILE_KEY, JSON.stringify(obj.profile));
          }
          scenesStore=loadScenesStore();
          profile=loadProfile();
          renderSceneList();
          renderProfileGrid();
          showNotification("Importado!");
        }catch(e){
          alert("JSON inv√°lido.");
        }
      };
      reader.readAsText(file);
      event.target.value="";
    }

    function sanitizeFileName(name){
      return String(name).replace(/[\\/:*?"<>|]+/g,'_').slice(0,80);
    }

    // ===== Host-only clear/unlock =====
    function clearTable(){
      if (!isHost) return;
      if (!confirm("Deseja limpar todos os tokens e o mapa?")) return;
      const a={type:"CLEAR"};
      applyAction(a,false); broadcastACT(a);
    }

    function unlockEverything(){
      if (!isHost) return;
      for (const id of Object.keys(state.tokens)){
        const a={type:"UPDATE_PROP", id, prop:"locked", value:"false"};
        applyAction(a,false); broadcastACT(a);
      }
      for (const l of Object.keys(layerState.locked)){
        const a={type:"LAYER_SET", layer:Number(l), prop:"locked", value:false};
        applyAction(a,false); broadcastACT(a);
      }
      if (state.map.locked) setMapLockLocal(false,true);
      showNotification("Tudo destrancado!");
    }

    // ===== Click outside: deselect =====
    viewport.addEventListener('mousedown',(e)=>{
      if(e.target===viewport || e.target===canvas || e.target===gridLayer){
        if(selectedToken) selectedToken.classList.remove('selected');
        selectedToken=null;
        syncInspectorFromSelection();
      }
    });

    // ===== Keyboard shortcuts =====
    window.addEventListener('keydown',(e)=>{
      if (!selectedToken) return;
      if (selectedToken.dataset.locked==="true") return;
      const layer = Number(selectedToken.dataset.layer||1);
      if (layerState.locked[layer]) return;

      if (e.key==='Delete'){
        if (!isHost) return;
        const id=selectedToken.dataset.uuid;
        const a={type:"REMOVE_TOKEN", id};
        applyAction(a,false); broadcastACT(a);
        selectedToken=null;
      }
    });

    // ===== Network protocol =====
    function sendREQ(action){
      if (isHost){
        applyHostAuthorizedAction(action,{sender:myId});
        return;
      }
      if (hostConnection?.open){
        hostConnection.send({kind:"REQ", sender:myId, action});
      }
    }
    function broadcastACT(action, meta={}){
      if (!isHost) return;
      const msg={kind:"ACT", sender:myId, action, meta};
      for (const c of connections){ if (c.open) c.send(msg); }
    }
    function broadcastSYNC(){
      if (!isHost) return;
      const msg={kind:"SYNC", sender:myId, state, layerState};
      for (const c of connections){ if (c.open) c.send(msg); }
    }
    function sendSYNC(conn){
      if (!isHost) return;
      conn.send({kind:"SYNC", sender:myId, state, layerState});
    }

    function handleNetworkData(data, connPeerId=null){
      if (!data?.kind) return;

      if (data.kind==="SYNC"){
        applyFullSync(data.state, data.layerState);
        return;
      }
      if (data.kind==="ACT"){
        applyAction(data.action,true);
        return;
      }
      if (data.kind==="REQ"){
        if (!isHost) return;
        const sender=data.sender || connPeerId || "unknown";
        applyHostAuthorizedAction(data.action,{sender});
      }
    }

    // Player validation: allow move + limited update props on unlocked tokens/layers
    function validateClientAction(action){
      if (!action?.type) return {ok:false,reason:"A√ß√£o inv√°lida"};
      const allowed = new Set(["MOVE","UPDATE_PROP"]);
      if (!allowed.has(action.type)) return {ok:false,reason:"A√ß√£o n√£o permitida"};

      const id=action.id;
      if (!id || !state.tokens[id]) return {ok:false,reason:"Token inexistente"};
      const tok=state.tokens[id];

      const layer=Number(tok.layer||1);
      ensureLayerDefaults(layer);
      if (!layerState.visible[layer]) return {ok:false,reason:"Layer oculta"};
      if (layerState.locked[layer]) return {ok:false,reason:"Layer trancada"};
      if (String(tok.locked)==="true") return {ok:false,reason:"Token travado"};

      if (action.type==="UPDATE_PROP"){
        // Player N√ÉO altera fogEmitter, visionRadius, layer, locked, name etc.
        const allowedProps = new Set(["rotation","flipped","innerZoom","size","fitMode"]);
        if (!allowedProps.has(action.prop)) return {ok:false,reason:"Prop n√£o permitida"};

        if (action.prop==="innerZoom"){
          const z=Number(action.value);
          if (!Number.isFinite(z) || z<.2 || z>5) return {ok:false,reason:"Zoom inv√°lido"};
        }
        if (action.prop==="size"){
          const w=Number(action.value?.w), h=Number(action.value?.h);
          if(!Number.isFinite(w)||!Number.isFinite(h)) return {ok:false,reason:"Size inv√°lido"};
          if(w<40||w>2500||h<40||h>2500) return {ok:false,reason:"Size fora limite"};
        }
        if (action.prop==="fitMode"){
          if(!["contain","cover"].includes(String(action.value))) return {ok:false,reason:"fit inv√°lido"};
        }
      }
      return {ok:true};
    }

    function applyHostAuthorizedAction(action,{sender}){
      const fromClient = sender && sender !== myId;
      if (fromClient){
        const v=validateClientAction(action);
        if (!v.ok){
          console.warn("REQ negada:", v.reason, action);
          return;
        }
      }
      applyAction(action,false);
      broadcastACT(action,{approvedBy:myId, originalSender:sender});
    }

    // ===== Apply actions =====
    function applyAction(action){
      switch(action.type){
        case "CLEAR":{
          document.querySelectorAll('.token').forEach(t=>t.remove());
          mapContainer.innerHTML="";
          diceLogEntries.querySelectorAll('.dice-entry').forEach(l => l.remove());
          selectedToken=null;
          stopMapInertia();

          state.map={src:null,locked:false,x:0,y:0};
          state.tokens={};
          state.fog.enabled=false;

          setMapLockLocal(false,false);
          setMapOffset(0,0);

          btnFog.classList.remove('active');

          rebuildLayersPanel();
          applyLayerVisibilityToDOM();
          requestFogRedraw();
          syncInspectorFromSelection();
          break;
        }

        case "MAP_UPDATE":{
          state.map.src = action.src;
          applyMapLocal(action.src,false);
          break;
        }
        case "MAP_LOCK":{
          setMapLockLocal(!!action.locked,false);
          break;
        }
        case "MAP_MOVE":{
          setMapOffset(Number(action.x||0), Number(action.y||0));
          break;
        }

        case "CREATE_TOKEN":{
          const {id, src, contentType, props} = action;
          addTokenLocal(src, contentType, id, props);
          state.tokens[id]=normalizeTokenProps(id,src,contentType,props);
          ensureLayerDefaults(Number(props?.layer ?? 1));
          rebuildLayersPanel();
          applyLayerVisibilityToDOM();
          requestFogRedraw();
          break;
        }

        case "REMOVE_TOKEN":{
          removeTokenLocal(action.id);
          delete state.tokens[action.id];
          rebuildLayersPanel();
          applyLayerVisibilityToDOM();
          requestFogRedraw();
          break;
        }

        case "MOVE":{
          moveTokenDOM(action.id, action.x, action.y);
          if (state.tokens[action.id]){
            state.tokens[action.id].x = action.x;
            state.tokens[action.id].y = action.y;
          }
          break;
        }

        case "UPDATE_PROP":{
          updateTokenPropDOM(action.id, action.prop, action.value);
          if (state.tokens[action.id]){
            const t=state.tokens[action.id];
            if (action.prop==="name") t.name=String(action.value||"");
            if (action.prop==="locked") t.locked=String(action.value);
            if (action.prop==="innerZoom") t.innerZoom=action.value;
            if (action.prop==="rotation") t.rotation=action.value;
            if (action.prop==="flipped") t.flipped=action.value;
            if (action.prop==="fitMode") t.fitMode=action.value;
            if (action.prop==="size"){ t.w=action.value.w; t.h=action.value.h; }
            if (action.prop==="layer"){ t.layer=Number(action.value); ensureLayerDefaults(Number(action.value)); }
            if (action.prop==="fogEmitter"){ t.fogEmitter=!!action.value; }
            if (action.prop==="visionRadius"){ t.visionRadius=Number(action.value); }
          }
          rebuildLayersPanel();
          applyLayerVisibilityToDOM();
          requestFogRedraw();
          break;
        }

        case "DICE":{
          showDiceLog(action.faces, action.result);
          break;
        }

        case "LAYER_SET":{
          const l=Number(action.layer);
          ensureLayerDefaults(l);
          if (action.prop==="visible") layerState.visible[l]=!!action.value;
          if (action.prop==="locked") layerState.locked[l]=!!action.value;
          applyLayerVisibilityToDOM();
          rebuildLayersPanel();
          break;
        }

        case "FOG_SET":{
          if (action.prop==="enabled"){
            state.fog.enabled = !!action.value;
            btnFog.classList.toggle('active', state.fog.enabled);
          }
          if (action.prop==="darkness"){
            state.fog.darkness = clamp(Number(action.value), 0.1, 0.98);
          }
          if (action.prop==="softness"){
            state.fog.softness = clamp(Number(action.value), 0.02, 0.6);
          }
          requestFogRedraw();
          break;
        }
      }
    }

    function applyFullSync(s, ls){
      // clear DOM
      document.querySelectorAll('.token').forEach(t=>t.remove());
      mapContainer.innerHTML="";
      diceLogEntries.querySelectorAll('.dice-entry').forEach(l=>l.remove());
      selectedToken=null;
      stopMapInertia();

      // layerState
      layerState.visible = ls?.visible || {};
      layerState.locked  = ls?.locked  || {};

      // state
      state.map = JSON.parse(JSON.stringify(s?.map || {src:null,locked:false,x:0,y:0}));
      state.fog = JSON.parse(JSON.stringify(s?.fog || {enabled:false,darkness:0.9,softness:0.2}));
      state.tokens = {};

      if (state.map.src) applyMapLocal(state.map.src,false);
      setMapLockLocal(!!state.map.locked,false);
      setMapOffset(Number(state.map.x||0), Number(state.map.y||0));

      const tokens = s?.tokens || {};
      for (const id of Object.keys(tokens)){
        const t=tokens[id];
        ensureLayerDefaults(Number(t.layer||1));
        addTokenLocal(t.src, t.type||"image", id, t);
        state.tokens[id]=normalizeTokenProps(id,t.src,t.type||"image",t);
      }

      btnFog.classList.toggle('active', !!state.fog.enabled);

      applyLayerVisibilityToDOM();
      rebuildLayersPanel();
      syncInspectorFromSelection();
      requestFogRedraw();
    }

    // ===== Context menu off =====
    window.addEventListener('contextmenu',(e)=>e.preventDefault());

    // ===== Network init =====
    function initNetwork(){
      const urlParams=new URLSearchParams(window.location.search);
      const roomID=urlParams.get('room');

      peer=new Peer(null,{debug:2, config:PEER_ICE_CONFIG});

      peer.on('open',(id)=>{
        myId=id;

        if (roomID){
          isHost=false;
          setRoleUI();
          statusText.innerText="Conectando ao Host...";
          tinyStatus.textContent="Conectando...";
          tinyRoom.textContent=roomID;
          connectToHost(roomID);
        } else {
          isHost=true;
          setRoleUI();
          statusText.innerText="Online (Host)";
          tinyStatus.textContent="Online (Host)";
          tinyRoom.textContent=id;
          statusDot.classList.add('online');
          toggleNetworkPanel();

          // load UI stores
          renderSceneList();
          renderProfileGrid();
          rebuildLayersPanel();

          peer.on('connection',(conn)=>{
            connections.push(conn);
            setupConnection(conn);
            conn.on('open',()=>setTimeout(()=>sendSYNC(conn),200));
            conn.on('close',()=>{ connections=connections.filter(c=>c!==conn); });
          });
        }

        // players also can render lists? no.
        if (!isHost){
          renderProfileGrid(); // optional empty
        }
      });

      peer.on('error',(err)=>{
        console.error(err);
        statusText.innerText="Erro Rede";
        tinyStatus.textContent="Erro Rede";
        statusDot.classList.remove('online');
      });
    }

    function connectToHost(hostId){
      hostConnection=peer.connect(hostId);
      setupConnection(hostConnection);

      hostConnection.on('open',()=>{
        statusText.innerText="Conectado";
        tinyStatus.textContent="Conectado";
        statusDot.classList.add('online');
      });

      hostConnection.on('close',()=>{
        statusText.innerText="Desconectado";
        tinyStatus.textContent="Desconectado";
        statusDot.classList.remove('online');
        alert("O Host desconectou.");
      });
    }

    function setupConnection(conn){
      conn.on('data',(data)=>handleNetworkData(data, conn.peer));
    }

    // ===== Start =====
    initNetwork();

    // initial render for host when sidebar opens
    // (host render called on peer open)
  </script>

  <script>
    // ===== Remove "token-controls": players still can interact by direct manipulations allowed. =====
    // NOTE: Player actions are only MOVE/UPDATE_PROP for allowed props via REQ.
    // Since we removed token-controls, players can only MOVE and resize via Ctrl+Wheel / handle (if unlocked).
    // Host uses Inspector for all settings.

    // ===== Player optional adjustments (rotation/zoom/fit) =====
    // Without token-controls, players don't have UI for these. That's intended.
    // If you quiser depois: podemos colocar atalhos de teclado pro player (ex: R/E para rotacionar),
    // mas voc√™ pediu "somente inspector", ent√£o mantive assim.
  </script>
</body>
</html>
