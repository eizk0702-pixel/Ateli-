<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>Tabletop Luxury - P2P (Mapa ‚Äúpalp√°vel‚Äù + Camadas + Biblioteca + Paredes/Portas + F√≠sica + Online Melhorado)</title>

  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>

  <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Inter:wght@300;400;600&display=swap" rel="stylesheet">

  <style>
    :root{
      --gold:#c5a059;
      --dark-bg:#0f0f0f;
      --panel-bg:rgba(20,20,20,.9);
      --glass:rgba(255,255,255,.03);
      --status-online:#4ade80;
      --status-offline:#ef4444;
      --wall:#e5e7eb;
      --door:#fbbf24;
      --door-open:#34d399;
      --obstacle-fill:rgba(255,255,255,.06);
    }
    body{margin:0;overflow:hidden;background:var(--dark-bg);font-family:'Inter',sans-serif;color:#e0e0e0;}

    #viewport{width:100vw;height:100vh;overflow:hidden;position:relative;background:radial-gradient(circle,#1a1a1a 0%,#0a0a0a 100%);z-index:1;}
    #canvas-container{width:10000px;height:10000px;position:absolute;top:0;left:0;transform-origin:0 0;cursor:grab;z-index:2;}

    /* MAPA = camada 0 */
    #map-container{
      position:absolute;top:0;left:0;
      z-index:5;
      pointer-events:auto; /* agora √© ‚Äúpalp√°vel‚Äù */
      transform: translate(0px,0px);
      transform-origin: 0 0;
    }
    #map-container.locked{pointer-events:none;}
    #map-container img{
      display:block;max-width:none;
      user-select:none;
      -webkit-user-drag:none;
      cursor: grab;
      filter: drop-shadow(0 0 25px rgba(0,0,0,.45));
    }
    #map-container.dragging img{cursor: grabbing;}

    .grid-layer{
      position:absolute;top:0;left:0;width:100%;height:100%;
      pointer-events:none;
      background-image:
        linear-gradient(to right, rgba(197,160,89,.05) 1px, transparent 1px),
        linear-gradient(to bottom, rgba(197,160,89,.05) 1px, transparent 1px);
      background-size:50px 50px;
      z-index:6;
    }

    /* OBST√ÅCULOS (paredes/portas) */
    #obstacles-layer{
      position:absolute;top:0;left:0;width:100%;height:100%;
      z-index:7;
      pointer-events:none;
    }
    #obstacles-svg{
      position:absolute;top:0;left:0;
      width:10000px;height:10000px;
    }
    #obstacles-layer.editing{pointer-events:auto;}
    #obstacles-hit{
      position:absolute;top:0;left:0;
      width:10000px;height:10000px;
      background:transparent;
      cursor:crosshair;
    }
    .ob-rect{
      fill: var(--obstacle-fill);
      stroke-width:2;
      shape-rendering:geometricPrecision;
    }
    .ob-rect.wall{stroke:var(--wall);}
    .ob-rect.door{stroke:var(--door);}
    .ob-rect.door.open{stroke:var(--door-open);}
    .ob-label{
      font-size:10px;
      fill: rgba(255,255,255,.75);
      user-select:none;
      pointer-events:none;
    }
    .ob-handle{
      fill: rgba(197,160,89,.7);
      stroke: rgba(0,0,0,.3);
      stroke-width:1;
      cursor: pointer;
    }

    /* TOKENS = camadas >= 1 */
    .token{
      position:absolute;
      cursor:move;
      user-select:none;
      display:flex;align-items:center;justify-content:center;
      background:transparent;
      overflow:visible;
      transition:filter .2s ease, outline .2s ease;
    }
    .token.locked{cursor:default!important;pointer-events:none;}
    .token.locked .token-controls,.token.locked .resize-handle{display:none!important;}

    .token-blocker{position:absolute;top:0;left:0;width:100%;height:100%;z-index:50;background:rgba(255,255,255,.001);}
    .token-content-wrapper{width:100%;height:100%;overflow:hidden;display:flex;align-items:center;justify-content:center;pointer-events:none;}

    .token iframe,.token img{
      width:100%;height:100%;border:none;background:transparent;pointer-events:none;
      object-fit:contain; /* evita ‚Äúcortar‚Äù */
      transition:transform .2s ease-out;
    }

    .token.selected:not(.locked){
      filter:drop-shadow(0 0 15px var(--gold));
      outline:2px dashed rgba(197,160,89,.6);
      outline-offset:4px;
    }

    .resize-handle{
      position:absolute;width:16px;height:16px;background:var(--gold);
      border:2px solid #fff;border-radius:4px;display:none;z-index:110;
      cursor:nwse-resize;bottom:-8px;right:-8px;
    }
    .token.selected:not(.locked) .resize-handle{display:block;}

    .token-controls{
      position:absolute;top:-65px;left:50%;transform:translateX(-50%);
      display:none;background:var(--panel-bg);backdrop-filter:blur(12px);
      border:1px solid rgba(197,160,89,.4);border-radius:40px;
      padding:8px 16px;gap:12px;z-index:200;
      box-shadow:0 4px 20px rgba(0,0,0,.5);
      white-space:nowrap;
    }
    .token.selected:not(.locked) .token-controls{display:flex;align-items:center;}
    .token-btn{
      color:#fff;font-size:16px;cursor:pointer;opacity:.85;transition:all .2s;
      display:flex;align-items:center;gap:5px;
    }
    .token-btn:hover{opacity:1;color:var(--gold);transform:scale(1.08);}

    .hud-element{transition:opacity .4s ease, transform .4s ease;}
    .hud-hidden .hud-element{opacity:0!important;pointer-events:none!important;transform:translateY(10px);}

    .sidebar{
      width:300px;background:var(--panel-bg);backdrop-filter:blur(15px);
      height:100vh;position:fixed;left:0;top:0;z-index:1000;
      border-right:1px solid rgba(197,160,89,.2);
      transform:translateX(-100%);
      transition:transform .4s cubic-bezier(.16,1,.3,1);
    }
    .sidebar.open{transform:translateX(0);}
    .toggle-sidebar-btn{
      position:absolute;right:-35px;top:20px;background:var(--panel-bg);
      border:1px solid rgba(197,160,89,.2);border-left:none;
      padding:10px 8px;border-radius:0 8px 8px 0;cursor:pointer;color:var(--gold);
    }

    .controls-top{
      position:fixed;top:20px;left:50%;transform:translateX(-50%);
      display:flex;gap:10px;z-index:1000;background:var(--panel-bg);
      padding:8px;border-radius:40px;border:1px solid rgba(197,160,89,.2);
      backdrop-filter:blur(10px);box-shadow:0 5px 25px rgba(0,0,0,.4);
    }

    .btn-luxury{
      padding:8px 16px;border-radius:20px;font-size:12px;font-weight:600;
      text-transform:uppercase;letter-spacing:1px;transition:all .3s;
      border:1px solid transparent;color:#ccc;background:transparent;
    }
    .btn-luxury:hover,.btn-luxury.active{
      color:var(--gold);background:var(--glass);border-color:rgba(197,160,89,.4);
    }

    .dice-log{
      position:fixed;bottom:25px;right:25px;width:240px;max-height:200px;
      background:var(--panel-bg);border-radius:12px;border:1px solid rgba(197,160,89,.15);
      padding:15px;overflow-y:auto;font-size:13px;z-index:1000;
      box-shadow:0 4px 15px rgba(0,0,0,.3);
    }

    .btn-toggle-hud{
      position:fixed;bottom:25px;left:25px;z-index:2000;background:var(--panel-bg);
      width:45px;height:45px;border-radius:50%;
      display:flex;align-items:center;justify-content:center;
      border:1px solid rgba(197,160,89,.3);cursor:pointer;color:var(--gold);
      box-shadow:0 4px 10px rgba(0,0,0,.4);
    }

    .url-field{
      background:rgba(0,0,0,.3);border:1px solid rgba(197,160,89,.2);color:#fff;
      width:100%;font-size:12px;padding:8px;margin-bottom:10px;outline:none;border-radius:6px;
    }
    .url-field:focus{border-color:var(--gold);background:rgba(0,0,0,.5);}

    h2,h3{font-family:'Cinzel',serif;letter-spacing:1px;color:var(--gold);}

    .network-status{
      position:fixed;top:80px;right:20px;display:flex;align-items:center;gap:10px;
      background:var(--panel-bg);padding:8px 16px;border-radius:20px;
      border:1px solid rgba(197,160,89,.2);font-size:11px;z-index:1000;
      backdrop-filter:blur(10px);
      opacity:0;pointer-events:none;transform:translateY(-10px);transition:all .3s;
    }
    .network-status.show{opacity:1;pointer-events:auto;transform:translateY(0);}

    .status-dot{width:8px;height:8px;border-radius:50%;background:var(--status-offline);box-shadow:0 0 5px currentColor;}
    .status-dot.online{background:var(--status-online);}

    .lock-manager{
      position:fixed;top:20px;right:20px;z-index:1000;display:flex;flex-direction:column;gap:10px;
    }

    #notification{
      position:fixed;top:50%;left:50%;transform:translate(-50%,-50%) scale(.9);
      background:rgba(0,0,0,.9);border:1px solid var(--gold);
      padding:20px 40px;border-radius:10px;z-index:9999;color:var(--gold);
      font-family:'Cinzel',serif;opacity:0;pointer-events:none;transition:all .3s;
    }
    #notification.active{opacity:1;transform:translate(-50%,-50%) scale(1);}

    #role-badge{
      position:fixed;top:140px;right:20px;z-index:1100;background:var(--panel-bg);
      border:1px solid rgba(197,160,89,.2);border-radius:999px;padding:6px 12px;
      font-size:11px;backdrop-filter:blur(10px);opacity:.95;
    }
    #role-badge b{color:var(--gold);}

    /* BIBLIOTECA (Assets/Players/Mapas) */
    .library-panel{
      position:fixed;top:170px;right:20px;z-index:1200;width:380px;max-height:560px;
      background:var(--panel-bg);border:1px solid rgba(197,160,89,.2);
      border-radius:16px;padding:12px;backdrop-filter:blur(10px);
      box-shadow:0 10px 30px rgba(0,0,0,.45);overflow:hidden;display:none;
    }
    .library-panel.show{display:block;}

    .library-tabs{display:flex;gap:8px;margin-bottom:10px;}
    .library-tab{
      flex:1;padding:8px 10px;border-radius:12px;border:1px solid rgba(197,160,89,.25);
      background:rgba(255,255,255,.03);font-size:11px;text-transform:uppercase;letter-spacing:.6px;
      cursor:pointer;color:#ccc;text-align:center;
    }
    .library-tab.active{color:var(--gold);border-color:rgba(197,160,89,.55);background:rgba(255,255,255,.05);}

    .library-search{
      width:100%;margin-bottom:10px;padding:8px 10px;border-radius:10px;
      border:1px solid rgba(197,160,89,.2);background:rgba(0,0,0,.35);color:#fff;font-size:12px;outline:none;
    }

    .library-grid{
      overflow:auto;max-height:390px;padding-right:6px;
      display:grid;grid-template-columns:repeat(3,1fr);gap:10px;
    }

    .asset-card{
      border:1px solid rgba(197,160,89,.18);background:rgba(255,255,255,.03);
      border-radius:14px;padding:8px;display:flex;flex-direction:column;gap:8px;
    }
    .asset-thumb{
      width:100%;aspect-ratio:1/1;border-radius:12px;overflow:hidden;border:1px solid rgba(255,255,255,.06);
      background:rgba(0,0,0,.35);display:flex;align-items:center;justify-content:center;
    }
    .asset-thumb img{width:100%;height:100%;object-fit:cover;}
    .asset-actions{display:flex;gap:6px;}
    .asset-actions button{
      flex:1;padding:6px 8px;border-radius:10px;border:1px solid rgba(197,160,89,.25);
      background:rgba(255,255,255,.03);color:#ddd;font-size:10px;cursor:pointer;
    }
    .asset-actions button:hover{color:var(--gold);border-color:rgba(197,160,89,.55);background:rgba(255,255,255,.05);}

    /* GERENCIADOR DE CAMADAS */
    .layers-panel{
      position:fixed;top:230px;left:50%;transform:translateX(-50%);
      z-index:1200;min-width:360px;max-width:520px;
      background:var(--panel-bg);border:1px solid rgba(197,160,89,.2);
      border-radius:16px;padding:12px;backdrop-filter:blur(10px);
      box-shadow:0 10px 30px rgba(0,0,0,.45);
      display:none;
    }
    .layers-panel.show{display:block;}
    .layer-row{display:flex;align-items:center;justify-content:space-between;gap:10px;padding:8px 10px;border-radius:12px;background:rgba(255,255,255,.03);border:1px solid rgba(197,160,89,.12);margin-bottom:8px;}
    .layer-row b{color:var(--gold);}
    .layer-actions{display:flex;gap:8px;align-items:center;}
    .pill{
      font-size:10px;padding:5px 10px;border-radius:999px;border:1px solid rgba(197,160,89,.25);cursor:pointer;
      background:rgba(255,255,255,.03);color:#ddd;
    }
    .pill.active{color:var(--gold);border-color:rgba(197,160,89,.55);background:rgba(255,255,255,.05);}

    /* Painel Paredes/Portas */
    .ob-panel{
      position:fixed;top:230px;right:20px;z-index:1300;width:360px;max-height:520px;
      background:var(--panel-bg);border:1px solid rgba(197,160,89,.2);
      border-radius:16px;padding:12px;backdrop-filter:blur(10px);
      box-shadow:0 10px 30px rgba(0,0,0,.45);
      display:none;
    }
    .ob-panel.show{display:block;}
    .ob-mode-row{display:flex;gap:8px;margin-bottom:10px;}
    .ob-mode-btn{
      flex:1;padding:8px 10px;border-radius:12px;border:1px solid rgba(197,160,89,.25);
      background:rgba(255,255,255,.03);font-size:11px;text-transform:uppercase;letter-spacing:.6px;
      cursor:pointer;color:#ccc;text-align:center;
    }
    .ob-mode-btn.active{color:var(--gold);border-color:rgba(197,160,89,.55);background:rgba(255,255,255,.05);}
    .ob-list{max-height:290px;overflow:auto;padding-right:6px;display:flex;flex-direction:column;gap:8px;}
    .ob-item{display:flex;align-items:center;justify-content:space-between;gap:8px;padding:8px 10px;border-radius:12px;background:rgba(255,255,255,.03);border:1px solid rgba(197,160,89,.12);}
    .ob-item small{opacity:.75;}
    .ob-actions{display:flex;gap:6px;}
    .ob-actions button{
      padding:6px 8px;border-radius:10px;border:1px solid rgba(197,160,89,.25);
      background:rgba(255,255,255,.03);color:#ddd;font-size:10px;cursor:pointer;
    }
    .ob-actions button:hover{color:var(--gold);border-color:rgba(197,160,89,.55);background:rgba(255,255,255,.05);}

    /* Loading do mapa */
    #map-loading{
      position:fixed;left:50%;top:50%;
      transform:translate(-50%,-50%);
      z-index:9000;
      background:rgba(0,0,0,.85);
      border:1px solid rgba(197,160,89,.45);
      color:var(--gold);
      padding:14px 18px;
      border-radius:14px;
      display:none;
      backdrop-filter:blur(10px);
      font-family:'Cinzel',serif;
      letter-spacing:.5px;
    }
    #map-loading.show{display:block;}
  </style>
</head>

<body>
  <div id="map-loading">Carregando mapa...</div>
  <div id="notification">OK</div>
  <div id="role-badge">Modo: <b id="role-text">...</b></div>

  <div class="btn-toggle-hud" onclick="toggleHUD()" title="Esconder/Mostrar Interface">üëÅÔ∏è</div>

  <div id="hud-root">
    <div class="controls-top hud-element">
      <button class="btn-luxury" id="btn-d20" onclick="rollDice(20)">D20</button>
      <button class="btn-luxury" id="btn-d6" onclick="rollDice(6)">D6</button>
      <button class="btn-luxury" onclick="toggleGrid()">Grelha</button>
      <button class="btn-luxury" id="btn-lock-all" onclick="unlockEverything()">üîì Destrancar</button>
      <button class="btn-luxury" id="btn-save-scene" onclick="openScenePanel()">üíæ Cena</button>
      <button class="btn-luxury" id="btn-library" onclick="toggleLibrary()">üì¶ Biblioteca</button>
      <button class="btn-luxury" id="btn-layers" onclick="toggleLayersPanel()">üß± Camadas</button>
      <button class="btn-luxury" id="btn-obstacles" onclick="toggleObstaclesPanel()">üöß Paredes</button>
      <button class="btn-luxury" onclick="toggleNetworkPanel()">üåê Rede</button>
    </div>

    <div class="lock-manager hud-element">
      <button class="btn-luxury bg-black/40 border-gold/20" id="btn-lock-map" onclick="toggleMapLock()">üîì Mapa M√≥vel</button>
    </div>

    <div class="network-status" id="network-panel">
      <div id="status-dot" class="status-dot"></div>
      <span id="status-text">Offline</span>
      <div class="h-4 w-px bg-white/20 mx-2"></div>
      <button class="btn-luxury py-0 px-2 text-[10px]" onclick="copyInviteLink()" id="btn-invite">üîó Copiar Convite</button>
      <button class="btn-luxury py-0 px-2 text-[10px]" onclick="forceResync()" id="btn-resync">üîÑ Sync</button>
    </div>

    <!-- Painel de Cenas -->
    <div class="network-status" id="scene-panel" style="top: 120px;">
      <span style="color: var(--gold); font-weight:700;">Cenas</span>
      <div class="h-4 w-px bg-white/20 mx-2"></div>

      <label class="btn-luxury py-0 px-2 text-[10px] cursor-pointer" style="display:flex;align-items:center;gap:6px;">
        <input type="checkbox" id="embed-remote" checked> Embutir URLs
      </label>

      <label class="btn-luxury py-0 px-2 text-[10px] cursor-pointer" style="display:flex;align-items:center;gap:6px;">
        <input type="checkbox" id="compress-images" checked> Comprimir
      </label>

      <select id="max-dim" class="url-field" style="margin:0; padding:6px; width:95px;">
        <option value="1024">1024px</option>
        <option value="1536">1536px</option>
        <option value="2048" selected>2048px</option>
        <option value="3072">3072px</option>
        <option value="4096">4096px</option>
      </select>

      <input id="quality" type="range" min="0.4" max="0.95" step="0.05" value="0.75" style="width:90px;">
      <span id="quality-label" style="font-size:10px;opacity:.8;">Q 0.75</span>

      <span id="scene-size" style="font-size:10px;opacity:.8; margin-left:6px;">~ -</span>

      <div class="h-4 w-px bg-white/20 mx-2"></div>

      <button class="btn-luxury py-0 px-2 text-[10px]" onclick="saveSceneToFile()">Salvar .JSON</button>
      <label class="btn-luxury py-0 px-2 text-[10px] cursor-pointer">
        Carregar .JSON
        <input type="file" id="scene-file" accept="application/json" style="display:none" onchange="loadSceneFromFile(event)">
      </label>
    </div>

    <!-- Biblioteca / Perfil -->
    <div class="library-panel" id="library-panel">
      <div style="display:flex; align-items:center; justify-content:space-between; gap:10px; margin-bottom:10px;">
        <div style="color: var(--gold); font-weight:700; font-family:'Cinzel',serif;">Biblioteca</div>
        <div style="display:flex; gap:8px;">
          <button class="btn-luxury py-0 px-2 text-[10px]" onclick="saveProfileToFile()">Salvar Perfil</button>
          <label class="btn-luxury py-0 px-2 text-[10px] cursor-pointer">
            Carregar Perfil
            <input type="file" id="profile-file" accept="application/json" style="display:none" onchange="loadProfileFromFile(event)">
          </label>
        </div>
      </div>

      <div class="library-tabs">
        <div class="library-tab active" id="tab-maps" onclick="setLibraryTab('maps')">Mapas</div>
        <div class="library-tab" id="tab-players" onclick="setLibraryTab('players')">Players</div>
        <div class="library-tab" id="tab-assets" onclick="setLibraryTab('assets')">Assets</div>
      </div>

      <input class="library-search" id="library-search" placeholder="Buscar..." oninput="renderLibrary()">
      <div class="library-grid" id="library-grid"></div>

      <div style="display:flex; justify-content:space-between; align-items:center; margin-top:10px; font-size:10px; opacity:.8;">
        <span id="library-count">0 itens</span>
        <button class="btn-luxury py-0 px-2 text-[10px]" onclick="clearLibrary()">Limpar Biblioteca</button>
      </div>
    </div>

    <!-- Camadas -->
    <div class="layers-panel" id="layers-panel">
      <div style="display:flex;align-items:center;justify-content:space-between;gap:10px;margin-bottom:10px;">
        <div style="color: var(--gold); font-weight:700; font-family:'Cinzel',serif;">Camadas (Layer 0 = Mapa)</div>
        <button class="btn-luxury py-0 px-2 text-[10px]" onclick="rebuildLayersPanel()">Atualizar</button>
      </div>
      <div id="layers-list"></div>
      <div style="font-size:10px;opacity:.75; margin-top:10px;">
        Dica: tokens t√™m ‚Äúlayer‚Äù e ‚Äúkind‚Äù. Player s√≥ move o que est√° destravado e em camada vis√≠vel.
      </div>
    </div>

    <!-- Paredes/Portas -->
    <div class="ob-panel" id="ob-panel">
      <div style="display:flex;align-items:center;justify-content:space-between;gap:10px;margin-bottom:10px;">
        <div style="color: var(--gold); font-weight:700; font-family:'Cinzel',serif;">Paredes & Portas</div>
        <button class="btn-luxury py-0 px-2 text-[10px]" onclick="renderObstaclesList()">Atualizar</button>
      </div>

      <div class="ob-mode-row">
        <div class="ob-mode-btn active" id="ob-mode-wall" onclick="setObMode('wall')">Parede</div>
        <div class="ob-mode-btn" id="ob-mode-door" onclick="setObMode('door')">Porta</div>
        <div class="ob-mode-btn" id="ob-mode-select" onclick="setObMode('select')">Selecionar</div>
      </div>

      <div style="display:flex; gap:8px; margin-bottom:10px;">
        <button class="btn-luxury py-0 px-2 text-[10px]" onclick="toggleObstacleEditing()">‚úèÔ∏è Editar</button>
        <button class="btn-luxury py-0 px-2 text-[10px]" onclick="clearObstacles()">üßπ Limpar</button>
        <button class="btn-luxury py-0 px-2 text-[10px]" onclick="toggleObstacleSnap()">üß≤ Snap</button>
      </div>

      <div style="font-size:10px;opacity:.75; margin-bottom:10px;">
        Como usar: ative <b>Editar</b>, clique e arraste no mapa para criar um ret√¢ngulo. <b>Porta</b> pode ser <b>abrir/fechar</b>.
        F√≠sica: tokens n√£o atravessam paredes/portas fechadas (host e players).
      </div>

      <div class="ob-list" id="ob-list"></div>

      <div style="font-size:10px;opacity:.75; margin-top:10px;">
        Dica: segure <b>Shift</b> pra for√ßar ‚ÄúPorta‚Äù durante desenho.
      </div>
    </div>

    <div class="sidebar hud-element" id="sidebar">
      <div class="toggle-sidebar-btn" onclick="toggleSidebar()">‚ò∞</div>
      <div class="p-6 overflow-y-auto h-full">
        <h2 class="text-xl font-bold mb-6 border-b border-gold/30 pb-3">Atelier P2P</h2>

        <!-- MAPA (Host) -->
        <div class="mb-8" id="host-only-map">
          <h3 class="text-xs font-semibold uppercase mb-4 opacity-70">Mapa (Layer 0)</h3>
          <div class="bg-black/40 p-4 border border-dashed border-gold/30 rounded-xl">
            <input type="file" id="map-file" accept="image/*" class="hidden" onchange="importAsset(event, 'map')">
            <label for="map-file" class="btn-luxury block text-center mb-3 cursor-pointer bg-white/5">Ficheiro Local</label>
            <input type="text" id="map-url" class="url-field" placeholder="https://link-do-mapa.jpg">
            <button class="btn-luxury w-full border border-gold/30" onclick="importFromUrl('map-url', 'map')">Definir Mapa</button>
          </div>
          <p class="text-[10px] opacity-50 mt-3 leading-relaxed italic">
            Agora o mapa √© arrast√°vel com in√©rcia. Trave para evitar mover.
          </p>
        </div>

        <!-- PLAYERS (Host) -->
        <div class="mb-8" id="host-only-players">
          <h3 class="text-xs font-semibold uppercase mb-4 opacity-70">Players (tokens)</h3>
          <div class="bg-black/40 p-4 border border-dashed border-gold/30 rounded-xl">
            <input type="file" id="player-file" accept="image/*" class="hidden" onchange="importAsset(event, 'player')">
            <label for="player-file" class="btn-luxury block text-center mb-3 cursor-pointer bg-white/5">Ficheiro Local</label>
            <input type="text" id="player-url" class="url-field" placeholder="URL Imagem...">
            <button class="btn-luxury w-full border border-gold/30" onclick="importFromUrl('player-url', 'player')">Adicionar Player</button>
          </div>
          <p class="text-[10px] opacity-50 mt-3 leading-relaxed italic">
            Players entram por padr√£o em layer 3.
          </p>
        </div>

        <!-- ASSETS (Host) -->
        <div class="mb-8" id="host-only-assets">
          <h3 class="text-xs font-semibold uppercase mb-4 opacity-70">Assets (tudo que n√£o √© player nem mapa)</h3>
          <div class="bg-black/40 p-4 border border-dashed border-gold/30 rounded-xl">
            <input type="file" id="asset-file" accept="image/*" class="hidden" onchange="importAsset(event, 'asset')">
            <label for="asset-file" class="btn-luxury block text-center mb-3 cursor-pointer bg-white/5">Ficheiro Local</label>
            <input type="text" id="asset-url" class="url-field" placeholder="URL Imagem...">
            <button class="btn-luxury w-full border border-gold/30" onclick="importFromUrl('asset-url', 'asset')">Adicionar Asset</button>
          </div>
          <p class="text-[10px] opacity-50 mt-3 leading-relaxed italic">
            Assets entram por padr√£o em layer 2.
          </p>
        </div>

        <div class="mt-auto pt-6 border-t border-gold/20" id="host-only-clear">
          <button class="btn-luxury w-full text-red-500 border-red-900/30 hover:bg-red-900/20" onclick="clearTable()">Limpar Mesa</button>
        </div>

        <div class="mt-6 text-[10px] opacity-50 leading-relaxed">
          <div><b>Status:</b> <span id="tiny-status">iniciando...</span></div>
          <div><b>Sala:</b> <span id="tiny-room">-</span></div>
        </div>
      </div>
    </div>

    <div class="dice-log hud-element" id="dice-log">
      <div id="dice-entries">
        <div class="text-[11px] opacity-40 mb-3 uppercase tracking-tighter">Hist√≥rico</div>
      </div>
    </div>
  </div>

  <div id="viewport">
    <div id="canvas-container">
      <div id="map-container" class="map-layer"></div>
      <div id="grid-layer" class="grid-layer"></div>

      <!-- Obst√°culos -->
      <div id="obstacles-layer">
        <svg id="obstacles-svg" xmlns="http://www.w3.org/2000/svg"></svg>
        <div id="obstacles-hit"></div>
      </div>
    </div>
  </div>

  <script>
    /********************************************************************
     * ‚úÖ NOVO (pedido)
     * - Mapear paredes e portas (host desenha ret√¢ngulos)
     * - F√≠sica: tokens n√£o atravessam paredes/portas fechadas
     * - Online melhorado: HELLO/ACK + RESYNC + SYNC ‚Äúmais robusto‚Äù
     * - Mant√©m TODAS as mec√¢nicas existentes (mapa palp√°vel, camadas, biblioteca, cenas, etc.)
     ********************************************************************/

    // ===== UTIL =====
    const generateUUID = () => Date.now().toString(36) + Math.random().toString(36).slice(2);

    function showNotification(msg){
      const n=document.getElementById('notification');
      n.innerText=msg;
      n.classList.add('active');
      setTimeout(()=>n.classList.remove('active'),2000);
    }

    function clamp(n,min,max){ return Math.max(min, Math.min(max,n)); }

    // ===== ELEMENTOS =====
    const canvas = document.getElementById('canvas-container');
    const viewport = document.getElementById('viewport');
    const mapContainer = document.getElementById('map-container');
    const gridLayer = document.getElementById('grid-layer');
    const sidebar = document.getElementById('sidebar');
    const diceLogEntries = document.getElementById('dice-entries');

    const statusDot = document.getElementById('status-dot');
    const statusText = document.getElementById('status-text');
    const networkPanel = document.getElementById('network-panel');
    const scenePanel = document.getElementById('scene-panel');

    const roleText = document.getElementById('role-text');
    const tinyStatus = document.getElementById('tiny-status');
    const tinyRoom = document.getElementById('tiny-room');

    const hostOnlyMap = document.getElementById('host-only-map');
    const hostOnlyPlayers = document.getElementById('host-only-players');
    const hostOnlyAssets = document.getElementById('host-only-assets');
    const hostOnlyClear = document.getElementById('host-only-clear');

    const btnLockAll = document.getElementById('btn-lock-all');
    const btnLockMap = document.getElementById('btn-lock-map');
    const btnInvite = document.getElementById('btn-invite');
    const btnD20 = document.getElementById('btn-d20');
    const btnD6 = document.getElementById('btn-d6');
    const btnSaveScene = document.getElementById('btn-save-scene');
    const btnLibrary = document.getElementById('btn-library');
    const btnLayers = document.getElementById('btn-layers');
    const btnObstacles = document.getElementById('btn-obstacles');

    const mapLoading = document.getElementById('map-loading');

    // Biblioteca
    const libraryPanel = document.getElementById('library-panel');
    const libraryGrid = document.getElementById('library-grid');
    const librarySearch = document.getElementById('library-search');
    const libraryCount = document.getElementById('library-count');
    let libraryTab = "maps";
    const library = { maps: [], players: [], assets: [] };

    // Camadas
    const layersPanel = document.getElementById('layers-panel');
    const layersList = document.getElementById('layers-list');

    // Obst√°culos
    const obPanel = document.getElementById('ob-panel');
    const obList = document.getElementById('ob-list');
    const obstaclesLayer = document.getElementById('obstacles-layer');
    const obstaclesSvg = document.getElementById('obstacles-svg');
    const obstaclesHit = document.getElementById('obstacles-hit');

    let obEditing = false;
    let obMode = "wall"; // wall | door | select
    let obSnap = true;

    // ===== CAMERA =====
    let scale = 1;
    let posX = window.innerWidth/2 - 5000;
    let posY = window.innerHeight/2 - 5000;
    let isPanning = false;
    let startPan = {x:0,y:0};

    function updateTransform(){
      canvas.style.transform = `translate(${posX}px, ${posY}px) scale(${scale})`;
    }
    updateTransform();

    // ===== SELE√á√ÉO =====
    let selectedToken = null;

    // ===== REDE =====
    let peer, connections = [], hostConnection = null;
    let myId = null;
    let isHost = false;

    // Online melhorado: heartbeats e resync
    let lastHostSeenAt = 0;
    let heartbeatTimer = null;
    let resyncTimer = null;

    const PEER_ICE_CONFIG = {
      iceServers: [
        { urls: "stun:stun.l.google.com:19302" },
        { urls: "stun:stun1.l.google.com:19302" },
        { urls: "stun:global.stun.twilio.com:3478" }
      ]
    };

    // ===== SISTEMA DE CAMADAS =====
    const layerState = {
      visible: {}, // layer -> bool
      locked: {},  // layer -> bool
    };

    function ensureLayerDefaults(layer){
      if (layer == null) return;
      if (!(layer in layerState.visible)) layerState.visible[layer] = true;
      if (!(layer in layerState.locked)) layerState.locked[layer] = false;
    }

    function computeTokenZIndex(layer){
      const base = 100;
      const l = Number(layer || 1);
      return base + (l * 10);
    }

    function applyLayerVisibilityToDOM(){
      document.querySelectorAll('.token').forEach(t=>{
        const layer = Number(t.dataset.layer || 1);
        ensureLayerDefaults(layer);
        const vis = !!layerState.visible[layer];
        t.style.display = vis ? "" : "none";
      });
    }

    function toggleLayersPanel(){
      if (!isHost) return alert("Apenas o Host gerencia camadas.");
      layersPanel.classList.toggle('show');
      rebuildLayersPanel();
    }

    function rebuildLayersPanel(){
      if (!isHost) return;

      const layers = new Set();
      Object.values(state.tokens).forEach(t => layers.add(Number(t.layer || 1)));
      const maxLayer = layers.size ? Math.max(...Array.from(layers)) : 3;

      layersList.innerHTML = "";

      for (let l=1; l<=Math.max(maxLayer,3); l++){
        ensureLayerDefaults(l);

        const row = document.createElement('div');
        row.className = "layer-row";

        const left = document.createElement('div');
        left.innerHTML = `<b>Layer ${l}</b> <span style="font-size:10px;opacity:.7;">(tokens)</span>`;

        const actions = document.createElement('div');
        actions.className = "layer-actions";

        const vis = document.createElement('div');
        vis.className = "pill " + (layerState.visible[l] ? "active" : "");
        vis.innerText = layerState.visible[l] ? "Vis√≠vel" : "Oculta";
        vis.onclick = () => {
          layerState.visible[l] = !layerState.visible[l];
          const action = { type:"LAYER_SET", layer:l, prop:"visible", value: layerState.visible[l] };
          applyAction(action,false);
          broadcastACT(action);
          rebuildLayersPanel();
          applyLayerVisibilityToDOM();
        };

        const lock = document.createElement('div');
        lock.className = "pill " + (layerState.locked[l] ? "active" : "");
        lock.innerText = layerState.locked[l] ? "Trancada" : "Livre";
        lock.onclick = () => {
          layerState.locked[l] = !layerState.locked[l];
          const action = { type:"LAYER_SET", layer:l, prop:"locked", value: layerState.locked[l] };
          applyAction(action,false);
          broadcastACT(action);
          rebuildLayersPanel();
        };

        actions.appendChild(vis);
        actions.appendChild(lock);

        row.appendChild(left);
        row.appendChild(actions);
        layersList.appendChild(row);
      }
    }

    // ===== ESTADO (Host autoritativo) =====
    const state = {
      map: { src:null, locked:false, x:0, y:0 },
      tokens: {},
      obstacles: [] // {id, kind:"wall"|"door", x,y,w,h, open:false}
    };

    // ===== UI =====
    function toggleHUD(){ document.body.classList.toggle('hud-hidden'); }
    function toggleSidebar(){ sidebar.classList.toggle('open'); }
    function toggleGrid(){ gridLayer.style.display = (gridLayer.style.display === 'none') ? 'block' : 'none'; }
    function toggleNetworkPanel(){ networkPanel.classList.toggle('show'); }

    function setRoleUI(){
      roleText.textContent = isHost ? "HOST (Mestre)" : "PLAYER";

      hostOnlyMap.style.display = isHost ? "" : "none";
      hostOnlyPlayers.style.display = isHost ? "" : "none";
      hostOnlyAssets.style.display = isHost ? "" : "none";
      hostOnlyClear.style.display = isHost ? "" : "none";

      btnLockAll.style.display = isHost ? "" : "none";
      btnLockMap.style.display = isHost ? "" : "none";
      btnInvite.style.display = isHost ? "" : "none";
      btnD20.style.display = isHost ? "" : "none";
      btnD6.style.display = isHost ? "" : "none";
      btnSaveScene.style.display = isHost ? "" : "none";
      btnLibrary.style.display = isHost ? "" : "none";
      btnLayers.style.display = isHost ? "" : "none";
      btnObstacles.style.display = isHost ? "" : "none";

      scenePanel.style.display = isHost ? "" : "none";
      layersPanel.style.display = isHost ? "" : "none";
      libraryPanel.style.display = isHost ? "" : "none";
      obPanel.style.display = isHost ? "" : "none";

      // Player pode abrir o painel de rede e clicar resync
      document.getElementById('btn-resync').style.display = isHost ? "" : "";
    }

    // ===== Convite =====
    function copyInviteLink(){
      if (!myId) return alert("Aguarde a conex√£o...");
      if (!isHost) return alert("Apenas o Host copia convite.");
      const u = new URL(window.location.href);
      u.searchParams.set('room', myId);
      const invite = u.toString();

      if (navigator.clipboard?.writeText){
        navigator.clipboard.writeText(invite).then(()=>showNotification("Link copiado!")).catch(()=>prompt("Copie:", invite));
      } else prompt("Copie:", invite);
    }

    // ===== PAN/ZOOM viewport =====
    viewport.addEventListener('wheel',(e)=>{
      if (e.ctrlKey) return;
      e.preventDefault();
      const zoomSpeed=.15;
      const delta = e.deltaY>0 ? -zoomSpeed : zoomSpeed;
      const newScale = Math.min(Math.max(.05, scale+delta), 4);

      const mx=e.clientX,my=e.clientY;
      const cx=(mx-posX)/scale, cy=(my-posY)/scale;

      scale = newScale;
      posX = mx - cx*scale;
      posY = my - cy*scale;
      updateTransform();
    },{passive:false});

    window.addEventListener('mousedown',(e)=>{
      if (e.button===2 || e.button===1 || (e.button===0 && e.altKey)){
        isPanning=true;
        startPan={x:e.clientX-posX,y:e.clientY-posY};
        viewport.style.cursor='grabbing';
      }
    });
    window.addEventListener('mousemove',(e)=>{
      if (isPanning){
        posX=e.clientX-startPan.x;
        posY=e.clientY-startPan.y;
        updateTransform();
      }
    });
    window.addEventListener('mouseup',()=>{ isPanning=false; viewport.style.cursor='grab'; });

    // ===== MAPA ‚ÄúPALP√ÅVEL‚Äù COM IN√âRCIA =====
    let mapDragging=false;
    let mapDragStart={mx:0,my:0,x:0,y:0};
    let mapVel={vx:0,vy:0};
    let mapLastMove={t:0,x:0,y:0};
    let mapInertiaRAF=null;

    function setMapLockLocal(lock, emit){
      state.map.locked = !!lock;
      if (state.map.locked) mapContainer.classList.add('locked');
      else mapContainer.classList.remove('locked');

      if (state.map.locked) {
        btnLockMap.innerHTML="üîí Mapa Fixo"; btnLockMap.classList.add('active');
      } else {
        btnLockMap.innerHTML="üîì Mapa M√≥vel"; btnLockMap.classList.remove('active');
      }

      if (emit){
        if (!isHost) return;
        const action = { type:"MAP_LOCK", locked: state.map.locked };
        applyAction(action,false);
        broadcastACT(action);
      }
    }

    function toggleMapLock(){
      if (!isHost) return;
      setMapLockLocal(!state.map.locked, true);
    }

    function setMapOffset(x, y){
      state.map.x = x;
      state.map.y = y;
      mapContainer.style.transform = `translate(${x}px, ${y}px)`;
    }

    function stopMapInertia(){
      if (mapInertiaRAF) cancelAnimationFrame(mapInertiaRAF);
      mapInertiaRAF = null;
    }

    function startMapInertia(){
      stopMapInertia();
      const friction = 0.92;
      const minV = 0.05;

      const step = () => {
        mapVel.vx *= friction;
        mapVel.vy *= friction;

        if (Math.abs(mapVel.vx) < minV && Math.abs(mapVel.vy) < minV) {
          mapVel.vx = 0; mapVel.vy = 0;
          stopMapInertia();

          if (isHost){
            const action = { type:"MAP_MOVE", x: state.map.x, y: state.map.y };
            applyAction(action,false);
            broadcastACT(action);
          }
          return;
        }

        setMapOffset(state.map.x + mapVel.vx, state.map.y + mapVel.vy);

        mapInertiaRAF = requestAnimationFrame(step);
      };

      mapInertiaRAF = requestAnimationFrame(step);
    }

    function setupMapDrag(){
      mapContainer.addEventListener('mousedown', (e)=>{
        if (!isHost) return;
        if (state.map.locked) return;
        const img = mapContainer.querySelector('img');
        if (!img) return;

        if (e.button !== 0 || e.altKey) return;
        e.preventDefault();
        e.stopPropagation();

        mapDragging = true;
        mapContainer.classList.add('dragging');
        stopMapInertia();

        mapDragStart = { mx:e.clientX, my:e.clientY, x:state.map.x, y:state.map.y };
        mapVel = { vx:0, vy:0 };
        mapLastMove = { t: performance.now(), x: state.map.x, y: state.map.y };

        const onMove = (me) => {
          if (!mapDragging) return;

          const dx = (me.clientX - mapDragStart.mx) / scale;
          const dy = (me.clientY - mapDragStart.my) / scale;

          const nx = mapDragStart.x + dx;
          const ny = mapDragStart.y + dy;
          setMapOffset(nx, ny);

          const now = performance.now();
          const dt = Math.max(1, now - mapLastMove.t);
          mapVel.vx = (nx - mapLastMove.x) / dt * 16;
          mapVel.vy = (ny - mapLastMove.y) / dt * 16;
          mapLastMove = { t: now, x: nx, y: ny };
        };

        const onUp = () => {
          mapDragging = false;
          mapContainer.classList.remove('dragging');
          document.removeEventListener('mousemove', onMove);
          document.removeEventListener('mouseup', onUp);

          startMapInertia();

          const action = { type:"MAP_MOVE", x: state.map.x, y: state.map.y };
          applyAction(action,false);
          broadcastACT(action);
        };

        document.addEventListener('mousemove', onMove);
        document.addEventListener('mouseup', onUp);
      });
    }
    setupMapDrag();

    function showMapLoading(on){
      mapLoading.classList.toggle('show', !!on);
    }

    function applyMapLocal(src, emit){
      showMapLoading(true);

      const img = new Image();
      img.onload = () => {
        mapContainer.innerHTML = "";
        mapContainer.appendChild(img);

        scale = Math.min(window.innerWidth / img.width, window.innerHeight / img.height, 1) * 0.8;
        posX = window.innerWidth/2 - (img.width * scale)/2;
        posY = window.innerHeight/2 - (img.height * scale)/2;
        updateTransform();

        setMapOffset(state.map.x || 0, state.map.y || 0);
        showMapLoading(false);

        // For√ßa um repaint leve (ajuda alguns browsers a ‚Äúmostrar‚Äù tudo imediatamente)
        requestAnimationFrame(()=>{ canvas.style.willChange = "transform"; });
        setTimeout(()=>{ canvas.style.willChange = ""; }, 120);
      };
      img.onerror = () => {
        showMapLoading(false);
        alert("Falha ao carregar o mapa. Verifique o link / CORS / imagem direta.");
      };
      img.src = src;

      if (emit){
        if (!isHost) return;
        // manda SET at√¥mico pra reduzir ‚Äúsumir at√© mexer‚Äù
        const action = { type:"MAP_SET", src, locked: !!state.map.locked, x: state.map.x, y: state.map.y };
        applyAction(action,false);
        broadcastACT(action);
      }
    }

    // ===== TOKENS =====
    function normalizeTokenProps(id, src, type, props){
      const p = props || {};
      const layer = Number(p.layer ?? 2);
      ensureLayerDefaults(layer);
      return {
        id,
        src,
        type,
        kind: p.kind ?? "asset",
        layer,
        x: p.x ?? "0px",
        y: p.y ?? "0px",
        w: p.w ?? 140,
        h: p.h ?? 140,
        rotation: p.rotation ?? 0,
        flipped: p.flipped ?? "false",
        innerZoom: p.innerZoom ?? 1,
        locked: p.locked ?? "false",
        fitMode: p.fitMode ?? "contain"
      };
    }

    function hostCreateToken(src, contentType, kind){
      if (!isHost) return;

      const id = generateUUID();

      const isImg = contentType === "image";
      let width = isImg ? 160 : 400;
      let height = isImg ? 160 : 225;

      const layerDefault = (kind === "player") ? 3 : 2;

      const centerX = (window.innerWidth/2 - posX)/scale;
      const centerY = (window.innerHeight/2 - posY)/scale;

      const props = {
        kind,
        layer: layerDefault,
        x: (centerX - width/2) + "px",
        y: (centerY - height/2) + "px",
        w: width,
        h: height,
        rotation: 0,
        flipped: "false",
        innerZoom: 1,
        locked: "false",
        fitMode: "contain"
      };

      const action = { type:"CREATE_TOKEN", id, src, contentType, props };
      applyAction(action,false);
      broadcastACT(action);

      rebuildLayersPanel();
      applyLayerVisibilityToDOM();
      updateSceneSizeEstimate();
    }

    function addTokenLocal(src, contentType, id, props){
      if (document.getElementById(`token-${id}`)) return;

      const token = document.createElement('div');
      token.id = `token-${id}`;
      token.className = "token";
      token.dataset.uuid = id;
      token.dataset.type = contentType;

      const layer = Number(props?.layer ?? 2);
      const kind = props?.kind ?? "asset";
      ensureLayerDefaults(layer);

      token.dataset.layer = String(layer);
      token.dataset.kind = kind;

      token.style.zIndex = String(computeTokenZIndex(layer));

      const width = props?.w ? parseInt(props.w) : (contentType==="web"?400:160);
      const height = props?.h ? parseInt(props.h) : (contentType==="web"?225:160);
      token.style.width = width + "px";
      token.style.height = height + "px";

      const x = props?.x ?? "0px";
      const y = props?.y ?? "0px";
      token.style.left = x;
      token.style.top = y;

      token.dataset.sizeW = width;
      token.dataset.sizeH = height;
      token.dataset.rotation = props?.rotation ?? 0;
      token.dataset.flipped = props?.flipped ?? "false";
      token.dataset.innerZoom = props?.innerZoom ?? 1;
      token.dataset.locked = props?.locked ?? "false";
      token.dataset.fitMode = props?.fitMode ?? "contain";

      if (token.dataset.locked === "true"){
        token.classList.add('locked');
        token.style.pointerEvents = "none";
      }

      const blocker = document.createElement('div');
      blocker.className = "token-blocker";

      const wrapper = document.createElement('div');
      wrapper.className = "token-content-wrapper";

      let content;
      if (contentType === "image"){
        content = document.createElement('img');
        content.src = src;
        // melhora: quando carrega, for√ßa reflow leve pra aparecer sem ‚Äúmexer‚Äù
        content.onload = () => requestAnimationFrame(()=>{ token.style.transform = "translateZ(0)"; setTimeout(()=>token.style.transform="", 50); });
      } else {
        content = document.createElement('iframe');
        content.src = src;
        content.setAttribute('frameborder','0');
        content.setAttribute('sandbox','allow-scripts allow-same-origin');
      }

      const handle = document.createElement('div');
      handle.className = "resize-handle";

      const controls = document.createElement('div');
      controls.className = "token-controls";
      controls.innerHTML = `
        <span class="token-btn" title="Layer -" onclick="layerToken(event, -1)">üß±‚ûñ</span>
        <span class="token-btn" title="Layer +" onclick="layerToken(event, 1)">üß±‚ûï</span>
        <span class="token-btn" title="Tamanho -" onclick="scaleToken(event, -40)">üìè‚ûñ</span>
        <span class="token-btn" title="Tamanho +" onclick="scaleToken(event, 40)">üìè‚ûï</span>
        <span class="token-btn" title="Zoom Interno -" onclick="zoomInnerToken(event, -0.1)">‚ûñ</span>
        <span class="token-btn" title="Zoom Interno +" onclick="zoomInnerToken(event, 0.1)">‚ûï</span>
        <span class="token-btn" title="Fit" onclick="fitToken(event)">üß©</span>
        <span class="token-btn" title="Reset" onclick="resetToken(event)">‚ôªÔ∏è</span>
        <span class="token-btn" title="Espelhar (F)" onclick="flipToken(this.closest('.token'))">‚ÜîÔ∏è</span>
        <span class="token-btn" title="Girar 45¬∞" onclick="rotateToken(event, 45)">üîÑ</span>
        <span class="token-btn" title="Trancar" onclick="lockToken(event)">üîí</span>
        <span class="token-btn text-red-400" title="Eliminar" onclick="deleteToken(event)">üóëÔ∏è</span>
      `;

      wrapper.appendChild(content);
      token.appendChild(blocker);
      token.appendChild(wrapper);
      token.appendChild(handle);
      token.appendChild(controls);
      canvas.appendChild(token);

      setTimeout(()=>updateImgTransform(token),10);

      const vis = !!layerState.visible[layer];
      token.style.display = vis ? "" : "none";

      // resize via ctrl+wheel
      token.addEventListener('wheel',(e)=>{
        if (!e.ctrlKey) return;
        if (token.dataset.locked === "true") return;
        if (layerState.locked[Number(token.dataset.layer||2)]) return;

        e.preventDefault(); e.stopPropagation();
        const delta = e.deltaY>0 ? -20 : 20;

        const startW = parseInt(token.dataset.sizeW);
        const startH = parseInt(token.dataset.sizeH);
        const ratio = startH/startW;
        const newW = Math.max(40, Math.min(startW + delta, 2500));
        const newH = Math.max(40, Math.min(newW * ratio, 2500));

        const action = { type:"UPDATE_PROP", id: token.dataset.uuid, prop:"size", value:{w:newW,h:newH} };
        if (isHost){ applyAction(action,false); broadcastACT(action); }
        else sendREQ(action);

        updateSceneSizeEstimate();
      },{passive:false});

      // resize handle drag
      handle.addEventListener('mousedown',(e)=>{
        if (token.dataset.locked === "true") return;
        if (layerState.locked[Number(token.dataset.layer||2)]) return;
        if (e.button!==0) return;

        e.stopPropagation(); e.preventDefault();
        const startX=e.clientX;
        const startW=parseInt(token.dataset.sizeW);
        const startH=parseInt(token.dataset.sizeH);
        const ratio=startH/startW;

        let pendingW=startW, pendingH=startH;

        function onMove(me){
          const deltaW=((me.clientX-startX)/scale)*1.5;
          let w=Math.max(40, Math.min(startW+deltaW, 2500));
          let h=Math.max(40, Math.min(w*ratio, 2500));
          pendingW=Math.round(w); pendingH=Math.round(h);
          token.dataset.sizeW=pendingW; token.dataset.sizeH=pendingH;
          token.style.width=pendingW+"px"; token.style.height=pendingH+"px";
        }
        function onUp(){
          document.removeEventListener('mousemove',onMove);
          document.removeEventListener('mouseup',onUp);
          const action={ type:"UPDATE_PROP", id:token.dataset.uuid, prop:"size", value:{w:pendingW,h:pendingH} };
          if (isHost){ applyAction(action,false); broadcastACT(action); }
          else sendREQ(action);
          updateSceneSizeEstimate();
        }
        document.addEventListener('mousemove',onMove);
        document.addEventListener('mouseup',onUp);
      });

      // drag token (com f√≠sica)
      token.addEventListener('mousedown',(e)=>{
        if (e.button!==0 || e.altKey) return;
        if (token.dataset.locked==="true") return;
        if (layerState.locked[Number(token.dataset.layer||2)]) return;
        e.stopPropagation();
        selectToken(token);
        startDraggingToken(e, token);
      });
    }

    function updateImgTransform(token){
      const el = token.querySelector('img') || token.querySelector('iframe');
      if (!el) return;

      if (el.tagName === "IMG"){
        el.style.objectFit = token.dataset.fitMode || "contain";
      }
      const rotation = token.dataset.rotation || 0;
      const flipped = token.dataset.flipped === "true";
      const innerZoom = token.dataset.innerZoom || 1;
      el.style.transform = `scale(${innerZoom}) rotate(${rotation}deg) scaleX(${flipped?-1:1})`;
    }

    function selectToken(token){
      if (selectedToken) selectedToken.classList.remove('selected');
      selectedToken = token;
      selectedToken.classList.add('selected');
    }

    // ===== F√çSICA / COLIS√ÉO (tokens vs paredes/portas fechadas) =====
    function getSolidObstacles(){
      // portas abertas N√ÉO colidem
      return (state.obstacles || []).filter(o=>{
        if (o.kind === "door") return !o.open;
        return true;
      });
    }

    function rectsOverlap(a,b){
      return !(a.x+a.w <= b.x || a.x >= b.x+b.w || a.y+a.h <= b.y || a.y >= b.y+b.h);
    }

    function resolveRectCollision(movingRect, solidRects){
      // empurra para fora usando menor sobreposi√ß√£o, iterativo pra m√∫ltiplas colis√µes
      let r = {...movingRect};
      const maxIters = 8;

      for (let iter=0; iter<maxIters; iter++){
        let collided = false;

        for (const o of solidRects){
          const b = {x:o.x, y:o.y, w:o.w, h:o.h};
          if (!rectsOverlap(r,b)) continue;

          collided = true;

          const left = (r.x + r.w) - b.x;
          const right = (b.x + b.w) - r.x;
          const top = (r.y + r.h) - b.y;
          const bottom = (b.y + b.h) - r.y;

          const minX = Math.min(left, right);
          const minY = Math.min(top, bottom);

          if (minX < minY){
            // resolve X
            if (left < right) r.x -= left;
            else r.x += right;
          } else {
            // resolve Y
            if (top < bottom) r.y -= top;
            else r.y += bottom;
          }
        }

        if (!collided) break;
      }

      return r;
    }

    function startDraggingToken(e, token){
      let startX=e.clientX, startY=e.clientY;
      let initialLeft=parseFloat(token.style.left);
      let initialTop=parseFloat(token.style.top);
      let moved=false;

      const w = parseInt(token.dataset.sizeW);
      const h = parseInt(token.dataset.sizeH);

      function onMove(me){
        moved=true;
        let dx=(me.clientX-startX)/scale;
        let dy=(me.clientY-startY)/scale;

        let newX=initialLeft+dx;
        let newY=initialTop+dy;

        if (gridLayer.style.display !== 'none'){
          newX=Math.round(newX/50)*50;
          newY=Math.round(newY/50)*50;
        }

        // F√≠sica: impede atravessar obst√°culos s√≥lidos
        const moving = {x:newX, y:newY, w, h};
        const solids = getSolidObstacles();
        if (solids.length){
          const resolved = resolveRectCollision(moving, solids);
          newX = resolved.x;
          newY = resolved.y;
        }

        token.style.left=newX+"px";
        token.style.top=newY+"px";
      }

      function onUp(){
        document.removeEventListener('mousemove',onMove);
        document.removeEventListener('mouseup',onUp);
        if (!moved) return;

        const id=token.dataset.uuid;
        const action={ type:"MOVE", id, x:token.style.left, y:token.style.top };

        if (isHost){ applyAction(action,false); broadcastACT(action); }
        else sendREQ(action);

        updateSceneSizeEstimate();
      }

      document.addEventListener('mousemove',onMove);
      document.addEventListener('mouseup',onUp);
    }

    function moveTokenDOM(id,x,y){
      const t=document.getElementById(`token-${id}`);
      if (!t) return;
      t.style.left=x; t.style.top=y;
    }

    function updateTokenPropDOM(id, prop, value){
      const token=document.getElementById(`token-${id}`);
      if (!token) return;

      if (prop==="locked"){
        token.dataset.locked = String(value);
        if (String(value)==="true"){
          token.classList.add('locked');
          token.style.pointerEvents="none";
          token.classList.remove('selected');
          if (selectedToken && selectedToken.dataset.uuid===id) selectedToken=null;
        } else {
          token.classList.remove('locked');
          token.style.pointerEvents="auto";
        }
      } else if (prop==="innerZoom"){
        token.dataset.innerZoom=value; updateImgTransform(token);
      } else if (prop==="rotation"){
        token.dataset.rotation=value; updateImgTransform(token);
      } else if (prop==="flipped"){
        token.dataset.flipped=value; updateImgTransform(token);
      } else if (prop==="fitMode"){
        token.dataset.fitMode=value; updateImgTransform(token);
      } else if (prop==="size"){
        token.style.width=value.w+"px";
        token.style.height=value.h+"px";
        token.dataset.sizeW=value.w;
        token.dataset.sizeH=value.h;
      } else if (prop==="layer"){
        const newLayer = Number(value);
        ensureLayerDefaults(newLayer);
        token.dataset.layer = String(newLayer);
        token.style.zIndex = String(computeTokenZIndex(newLayer));
        const vis = !!layerState.visible[newLayer];
        token.style.display = vis ? "" : "none";
      }

      updateSceneSizeEstimate();
    }

    function removeTokenLocal(id){
      const t=document.getElementById(`token-${id}`);
      if (t) t.remove();
      if (selectedToken && selectedToken.dataset.uuid===id) selectedToken=null;
    }

    // ===== A√á√ïES DE TOKEN (UI) =====
    window.lockToken = (e)=>{
      e.stopPropagation();
      const token=e.target.closest('.token');
      if (!token) return;
      if (!isHost) return;
      const id=token.dataset.uuid;
      const action={ type:"UPDATE_PROP", id, prop:"locked", value:"true" };
      applyAction(action,false); broadcastACT(action);
      updateSceneSizeEstimate();
    };

    window.deleteToken = (e)=>{
      e.stopPropagation();
      const token=e.target.closest('.token');
      if (!token) return;
      if (!isHost) return;
      const id=token.dataset.uuid;
      const action={ type:"REMOVE_TOKEN", id };
      applyAction(action,false); broadcastACT(action);
      updateSceneSizeEstimate();
    };

    window.zoomInnerToken = (e, delta)=>{
      e.stopPropagation();
      const token=e.target.closest('.token'); if (!token) return;
      if (token.dataset.locked==="true") return;
      if (layerState.locked[Number(token.dataset.layer||2)]) return;

      let z=parseFloat(token.dataset.innerZoom||1);
      z=Math.max(.2, Math.min(5, z+delta));

      const action={ type:"UPDATE_PROP", id:token.dataset.uuid, prop:"innerZoom", value:z };
      if (isHost){ applyAction(action,false); broadcastACT(action); }
      else sendREQ(action);
      updateSceneSizeEstimate();
    };

    window.flipToken = (token)=>{
      if (!token) return;
      if (token.dataset.locked==="true") return;
      if (layerState.locked[Number(token.dataset.layer||2)]) return;

      const newVal = token.dataset.flipped==="false" ? "true" : "false";
      const action={ type:"UPDATE_PROP", id:token.dataset.uuid, prop:"flipped", value:newVal };
      if (isHost){ applyAction(action,false); broadcastACT(action); }
      else sendREQ(action);
      updateSceneSizeEstimate();
    };

    window.rotateToken = (e, deg)=>{
      e.stopPropagation();
      const token=e.target.closest('.token'); if (!token) return;
      if (token.dataset.locked==="true") return;
      if (layerState.locked[Number(token.dataset.layer||2)]) return;

      const newVal = (parseInt(token.dataset.rotation||0)+deg)%360;
      const action={ type:"UPDATE_PROP", id:token.dataset.uuid, prop:"rotation", value:newVal };
      if (isHost){ applyAction(action,false); broadcastACT(action); }
      else sendREQ(action);
      updateSceneSizeEstimate();
    };

    window.fitToken = (e)=>{
      e.stopPropagation();
      const token=e.target.closest('.token'); if (!token) return;
      if (token.dataset.locked==="true") return;
      if (layerState.locked[Number(token.dataset.layer||2)]) return;

      const id=token.dataset.uuid;
      const a1={ type:"UPDATE_PROP", id, prop:"innerZoom", value:1 };
      const a2={ type:"UPDATE_PROP", id, prop:"fitMode", value:"contain" };
      if (isHost){ applyAction(a1,false); broadcastACT(a1); applyAction(a2,false); broadcastACT(a2); }
      else { sendREQ(a1); sendREQ(a2); }
    };

    window.resetToken = (e)=>{
      e.stopPropagation();
      const token=e.target.closest('.token'); if (!token) return;
      if (token.dataset.locked==="true") return;
      if (layerState.locked[Number(token.dataset.layer||2)]) return;

      const id=token.dataset.uuid;
      const acts=[
        { type:"UPDATE_PROP", id, prop:"innerZoom", value:1 },
        { type:"UPDATE_PROP", id, prop:"rotation", value:0 },
        { type:"UPDATE_PROP", id, prop:"flipped", value:"false" },
        { type:"UPDATE_PROP", id, prop:"fitMode", value:"contain" }
      ];
      if (isHost) acts.forEach(a=>{ applyAction(a,false); broadcastACT(a); });
      else acts.forEach(a=>sendREQ(a));
    };

    window.scaleToken = (e, deltaW)=>{
      e.stopPropagation();
      const token=e.target.closest('.token'); if (!token) return;
      if (token.dataset.locked==="true") return;
      if (layerState.locked[Number(token.dataset.layer||2)]) return;

      const w0=parseInt(token.dataset.sizeW), h0=parseInt(token.dataset.sizeH);
      const ratio=h0/w0;
      let w=Math.max(40, Math.min(2500, w0+deltaW));
      let h=Math.max(40, Math.min(2500, Math.round(w*ratio)));

      const action={ type:"UPDATE_PROP", id:token.dataset.uuid, prop:"size", value:{w,h} };
      if (isHost){ applyAction(action,false); broadcastACT(action); }
      else sendREQ(action);
      updateSceneSizeEstimate();
    };

    window.layerToken = (e, delta)=>{
      e.stopPropagation();
      const token=e.target.closest('.token'); if (!token) return;
      if (token.dataset.locked==="true") return;

      const cur = Number(token.dataset.layer||2);
      const next = Math.max(1, cur + delta);
      ensureLayerDefaults(next);

      const action={ type:"UPDATE_PROP", id:token.dataset.uuid, prop:"layer", value: next };
      if (isHost){ applyAction(action,false); broadcastACT(action); rebuildLayersPanel(); applyLayerVisibilityToDOM(); }
      else sendREQ(action);
      updateSceneSizeEstimate();
    };

    // ===== Keyboard =====
    window.addEventListener('keydown',(e)=>{
      if (!selectedToken) return;
      if (selectedToken.dataset.locked==="true") return;
      if (layerState.locked[Number(selectedToken.dataset.layer||2)]) return;

      if (e.key.toLowerCase()==='f') flipToken(selectedToken);
      if (e.key==='Delete'){
        if (!isHost) return;
        const id=selectedToken.dataset.uuid;
        const action={ type:"REMOVE_TOKEN", id };
        applyAction(action,false); broadcastACT(action);
        selectedToken=null;
        updateSceneSizeEstimate();
      }
    });

    viewport.addEventListener('mousedown',(e)=>{
      if (e.target===viewport || e.target===canvas || e.target===gridLayer){
        if (selectedToken) selectedToken.classList.remove('selected');
        selectedToken=null;
      }
    });

    // ===== DADOS / LOG =====
    function rollDice(faces){
      if (!isHost) return;
      const res=Math.floor(Math.random()*faces)+1;
      const action={ type:"DICE", faces, result:res };
      applyAction(action,false); broadcastACT(action);
    }
    function showDiceLog(faces,res){
      const entry=document.createElement('div');
      entry.className="dice-entry mb-2 border-l-2 border-gold pl-3 opacity-0 transform translate-x-4 transition-all duration-300";
      entry.innerHTML=`<span class="opacity-50 text-[10px] font-bold">D${faces}:</span> <b class="text-white text-lg">${res}</b>`;
      diceLogEntries.prepend(entry);
      setTimeout(()=>entry.classList.remove('opacity-0','translate-x-4'),10);
    }

    // ===== IMPORT =====
    function isImageUrl(url){
      return (url.match(/\.(jpeg|jpg|gif|png|webp|avif)$/i)!=null) || url.startsWith('data:image');
    }

    function importFromUrl(inputId, type){
      if (!isHost) return alert("Apenas o Host importa.");
      const url=document.getElementById(inputId).value.trim();
      if (!url) return;

      if (type==="map"){
        if (!isImageUrl(url)) return alert("Mapa precisa ser imagem direta.");
        state.map.src = url;
        applyMapLocal(url,true);
        addToLibrary("maps", url);
        document.getElementById(inputId).value="";
        updateSceneSizeEstimate();
        return;
      }

      if (!isImageUrl(url)) return alert("Tokens/Assets precisam ser imagens diretas.");

      if (type==="player"){
        hostCreateToken(url,"image","player");
        addToLibrary("players", url);
      } else if (type==="asset"){
        hostCreateToken(url,"image","asset");
        addToLibrary("assets", url);
      }
      document.getElementById(inputId).value="";
      rebuildLayersPanel();
      applyLayerVisibilityToDOM();
      updateSceneSizeEstimate();
    }

    function importAsset(event, type){
      if (!isHost) return alert("Apenas o Host importa.");
      const file=event.target.files?.[0];
      if (!file) return;

      const reader=new FileReader();
      reader.onload=(e)=>{
        const dataUrl=e.target.result;

        if (type==="map"){
          state.map.src = dataUrl;
          applyMapLocal(dataUrl,true);
          addToLibrary("maps", dataUrl, "mapa-local");
        } else if (type==="player"){
          hostCreateToken(dataUrl,"image","player");
          addToLibrary("players", dataUrl, "player-local");
        } else if (type==="asset"){
          hostCreateToken(dataUrl,"image","asset");
          addToLibrary("assets", dataUrl, "asset-local");
        }

        rebuildLayersPanel();
        applyLayerVisibilityToDOM();
        updateSceneSizeEstimate();
      };
      reader.readAsDataURL(file);
    }

    // ===== BIBLIOTECA =====
    function toggleLibrary(){
      if (!isHost) return alert("Apenas o Host usa Biblioteca/Perfil.");
      libraryPanel.classList.toggle('show');
      renderLibrary();
    }

    function setLibraryTab(tab){
      libraryTab=tab;
      document.getElementById('tab-maps').classList.toggle('active', tab==='maps');
      document.getElementById('tab-players').classList.toggle('active', tab==='players');
      document.getElementById('tab-assets').classList.toggle('active', tab==='assets');
      renderLibrary();
    }

    function normalizeNameFromSrc(src, fallback){
      if (!src) return fallback || "asset";
      if (src.startsWith("data:image")) return fallback || "local";
      try{
        const u=new URL(src);
        const last=u.pathname.split("/").pop() || fallback || "img";
        return decodeURIComponent(last).slice(0,40);
      }catch{
        return fallback || "asset";
      }
    }

    function addToLibrary(kind, src, name=null){
      if (!isHost) return;
      if (!src) return;
      const list = library[kind];
      if (!Array.isArray(list)) return;
      if (list.some(x=>x.src===src)) return;

      list.unshift({
        id: generateUUID(),
        name: name || normalizeNameFromSrc(src, kind==="maps"?"mapa":kind),
        src
      });
      renderLibrary();
    }

    function renderLibrary(){
      if (!isHost) return;
      const term=(librarySearch.value||"").toLowerCase().trim();
      const list = library[libraryTab] || [];
      const filtered = term ? list.filter(x=>(x.name||"").toLowerCase().includes(term)) : list;

      libraryGrid.innerHTML="";
      filtered.forEach(item=>{
        const card=document.createElement('div');
        card.className="asset-card";

        const thumb=document.createElement('div');
        thumb.className="asset-thumb";
        const img=document.createElement('img');
        img.src=item.src;
        img.alt=item.name||"asset";
        thumb.appendChild(img);

        const title=document.createElement('div');
        title.style.fontSize="10px";
        title.style.opacity=".85";
        title.style.whiteSpace="nowrap";
        title.style.overflow="hidden";
        title.style.textOverflow="ellipsis";
        title.textContent=item.name||"asset";

        const actions=document.createElement('div');
        actions.className="asset-actions";

        const use=document.createElement('button');
        use.textContent = (libraryTab==="maps") ? "Usar" : "Add";
        use.onclick=()=>{
          if (libraryTab==="maps"){
            state.map.src = item.src;
            applyMapLocal(item.src,true);
          } else if (libraryTab==="players"){
            hostCreateToken(item.src,"image","player");
          } else if (libraryTab==="assets"){
            hostCreateToken(item.src,"image","asset");
          }
          rebuildLayersPanel();
          applyLayerVisibilityToDOM();
          updateSceneSizeEstimate();
        };

        const del=document.createElement('button');
        del.textContent="Remover";
        del.onclick=()=>removeFromLibrary(item.id);

        actions.appendChild(use);
        actions.appendChild(del);

        card.appendChild(thumb);
        card.appendChild(title);
        card.appendChild(actions);

        libraryGrid.appendChild(card);
      });

      const count=(library[libraryTab]||[]).length;
      libraryCount.textContent = `${count} itens`;
    }

    function removeFromLibrary(id){
      if (!isHost) return;
      for (const k of ["maps","players","assets"]){
        library[k] = (library[k]||[]).filter(x=>x.id!==id);
      }
      renderLibrary();
    }

    function clearLibrary(){
      if (!isHost) return;
      if (!confirm("Limpar toda a Biblioteca?")) return;
      library.maps=[]; library.players=[]; library.assets=[];
      renderLibrary();
    }

    function saveProfileToFile(){
      if (!isHost) return;
      const payload={ version:2, savedAt:new Date().toISOString(), library };
      const json=JSON.stringify(payload);
      const blob=new Blob([json],{type:"application/json"});

      const a=document.createElement('a');
      a.href=URL.createObjectURL(blob);
      a.download=`perfil-${new Date().toISOString().replace(/[:.]/g,'-')}.json`;
      document.body.appendChild(a);
      a.click();
      a.remove();
      setTimeout(()=>URL.revokeObjectURL(a.href),1500);
      showNotification("Perfil salvo!");
    }

    function loadProfileFromFile(event){
      if (!isHost) return;
      const file=event.target.files?.[0];
      if (!file) return;
      const r=new FileReader();
      r.onload=()=>{
        try{
          const payload=JSON.parse(String(r.result||"{}"));
          if (!payload?.library) throw 0;
          library.maps=Array.isArray(payload.library.maps)?payload.library.maps:[];
          library.players=Array.isArray(payload.library.players)?payload.library.players:[];
          library.assets=Array.isArray(payload.library.assets)?payload.library.assets:[];
          showNotification("Perfil carregado!");
          renderLibrary();
        }catch{
          alert("perfil.json inv√°lido.");
        }
        event.target.value="";
      };
      r.readAsText(file);
    }

    // ===== PAREDES / PORTAS =====
    function toggleObstaclesPanel(){
      if (!isHost) return alert("Apenas o Host mapeia paredes/portas.");
      obPanel.classList.toggle('show');
      renderObstaclesList();
    }

    function setObMode(mode){
      obMode = mode;
      document.getElementById('ob-mode-wall').classList.toggle('active', mode==="wall");
      document.getElementById('ob-mode-door').classList.toggle('active', mode==="door");
      document.getElementById('ob-mode-select').classList.toggle('active', mode==="select");
    }

    function toggleObstacleSnap(){
      obSnap = !obSnap;
      showNotification(obSnap ? "Snap ON" : "Snap OFF");
    }

    function toggleObstacleEditing(){
      if (!isHost) return;
      obEditing = !obEditing;
      obstaclesLayer.classList.toggle('editing', obEditing);
      showNotification(obEditing ? "Modo Edi√ß√£o ON" : "Modo Edi√ß√£o OFF");
    }

    function clearObstacles(){
      if (!isHost) return;
      if (!confirm("Limpar todas as paredes/portas?")) return;
      const action = { type:"OB_CLEAR" };
      applyAction(action,false);
      broadcastACT(action);
      renderObstacles();
      renderObstaclesList();
      updateSceneSizeEstimate();
    }

    function addObstacle(kind, x,y,w,h){
      const ob = {
        id: generateUUID(),
        kind,
        x, y, w, h,
        open: (kind==="door") ? false : false
      };
      const action = { type:"OB_ADD", ob };
      applyAction(action,false);
      broadcastACT(action);
      renderObstacles();
      renderObstaclesList();
      updateSceneSizeEstimate();
    }

    function removeObstacle(id){
      if (!isHost) return;
      const action = { type:"OB_REMOVE", id };
      applyAction(action,false);
      broadcastACT(action);
      renderObstacles();
      renderObstaclesList();
      updateSceneSizeEstimate();
    }

    function toggleDoor(id){
      const ob = (state.obstacles||[]).find(o=>o.id===id);
      if (!ob || ob.kind!=="door") return;
      const action = { type:"OB_TOGGLE", id };
      if (isHost){
        applyAction(action,false);
        broadcastACT(action);
      } else {
        // player pode solicitar abrir/fechar porta? (se quiser travar, comenta abaixo)
        sendREQ(action);
      }
      renderObstacles();
      renderObstaclesList();
      updateSceneSizeEstimate();
    }

    function renderObstacles(){
      obstaclesSvg.innerHTML = "";
      const list = state.obstacles || [];

      for (const o of list){
        const rect = document.createElementNS("http://www.w3.org/2000/svg","rect");
        rect.setAttribute("x", o.x);
        rect.setAttribute("y", o.y);
        rect.setAttribute("width", o.w);
        rect.setAttribute("height", o.h);

        rect.classList.add("ob-rect");
        rect.classList.add(o.kind === "door" ? "door" : "wall");
        if (o.kind === "door" && o.open) rect.classList.add("open");

        // Clique em porta (select ou edi√ß√£o) -> toggle
        rect.style.pointerEvents = "auto";
        rect.addEventListener('mousedown', (e)=>{
          if (!obEditing && !isHost) return;
          if (o.kind === "door"){
            if (obMode==="select" || obEditing) {
              e.stopPropagation(); e.preventDefault();
              toggleDoor(o.id);
            }
          }
        });

        // click direito host remove no select
        rect.addEventListener('contextmenu',(e)=>{
          e.preventDefault();
          if (!isHost) return;
          if (obMode!=="select") return;
          removeObstacle(o.id);
        });

        obstaclesSvg.appendChild(rect);

        const label = document.createElementNS("http://www.w3.org/2000/svg","text");
        label.setAttribute("x", o.x + 6);
        label.setAttribute("y", o.y + 14);
        label.classList.add("ob-label");
        label.textContent = o.kind === "door" ? (o.open ? "Porta (aberta)" : "Porta (fechada)") : "Parede";
        obstaclesSvg.appendChild(label);
      }
    }

    function renderObstaclesList(){
      if (!isHost) return;
      obList.innerHTML = "";
      const list = state.obstacles || [];

      if (!list.length){
        const empty = document.createElement('div');
        empty.style.opacity = ".7";
        empty.style.fontSize = "11px";
        empty.style.padding = "8px 4px";
        empty.textContent = "Nenhuma parede/porta criada.";
        obList.appendChild(empty);
        return;
      }

      list.slice().reverse().forEach(o=>{
        const item = document.createElement('div');
        item.className = "ob-item";

        const left = document.createElement('div');
        left.innerHTML = `<b style="color:var(--gold)">${o.kind==="door" ? "Porta" : "Parede"}</b>
          <div><small>${Math.round(o.x)},${Math.round(o.y)} ¬∑ ${Math.round(o.w)}x${Math.round(o.h)}</small></div>`;

        const actions = document.createElement('div');
        actions.className = "ob-actions";

        if (o.kind==="door"){
          const t = document.createElement('button');
          t.textContent = o.open ? "Fechar" : "Abrir";
          t.onclick = ()=>toggleDoor(o.id);
          actions.appendChild(t);
        }

        const del = document.createElement('button');
        del.textContent = "Remover";
        del.onclick = ()=>removeObstacle(o.id);
        actions.appendChild(del);

        item.appendChild(left);
        item.appendChild(actions);
        obList.appendChild(item);
      });
    }

    // desenhar ret√¢ngulo no canvas (host)
    let drawActive = false;
    let drawStart = {x:0,y:0};
    let drawPreview = null;

    function screenToCanvas(e){
      // converte posi√ß√£o da tela para coordenadas do canvas-container (sem map offset, pois obst√°culos s√£o no canvas)
      const cx = (e.clientX - posX)/scale;
      const cy = (e.clientY - posY)/scale;
      return {x:cx, y:cy};
    }

    function snap(v, step=50){
      return Math.round(v/step)*step;
    }

    function ensurePreview(){
      if (drawPreview) return drawPreview;
      drawPreview = document.createElementNS("http://www.w3.org/2000/svg","rect");
      drawPreview.classList.add("ob-rect");
      drawPreview.setAttribute("fill","rgba(197,160,89,.12)");
      drawPreview.setAttribute("stroke","rgba(197,160,89,.9)");
      drawPreview.setAttribute("stroke-dasharray","6 4");
      obstaclesSvg.appendChild(drawPreview);
      return drawPreview;
    }

    function removePreview(){
      if (drawPreview){
        drawPreview.remove();
        drawPreview = null;
      }
    }

    obstaclesHit.addEventListener('mousedown',(e)=>{
      if (!isHost) return;
      if (!obEditing) return;
      if (e.button!==0) return;

      // se modo select, n√£o desenha
      if (obMode === "select") return;

      e.preventDefault(); e.stopPropagation();

      const pt = screenToCanvas(e);
      const sx = obSnap ? snap(pt.x) : pt.x;
      const sy = obSnap ? snap(pt.y) : pt.y;

      drawActive = true;
      drawStart = {x:sx, y:sy};

      const prev = ensurePreview();
      prev.setAttribute("x", sx);
      prev.setAttribute("y", sy);
      prev.setAttribute("width", 1);
      prev.setAttribute("height", 1);
    });

    window.addEventListener('mousemove',(e)=>{
      if (!drawActive) return;
      const pt = screenToCanvas(e);
      const ex = obSnap ? snap(pt.x) : pt.x;
      const ey = obSnap ? snap(pt.y) : pt.y;

      const x = Math.min(drawStart.x, ex);
      const y = Math.min(drawStart.y, ey);
      const w = Math.max(1, Math.abs(ex - drawStart.x));
      const h = Math.max(1, Math.abs(ey - drawStart.y));

      const prev = ensurePreview();
      prev.setAttribute("x", x);
      prev.setAttribute("y", y);
      prev.setAttribute("width", w);
      prev.setAttribute("height", h);
    });

    window.addEventListener('mouseup',(e)=>{
      if (!drawActive) return;
      drawActive = false;

      const prev = drawPreview;
      if (!prev){ return; }

      const x = parseFloat(prev.getAttribute("x"));
      const y = parseFloat(prev.getAttribute("y"));
      const w = parseFloat(prev.getAttribute("width"));
      const h = parseFloat(prev.getAttribute("height"));

      removePreview();

      // m√≠nimo pra evitar ‚Äúcliques‚Äù
      if (w < 20 || h < 20) return;

      const forcedDoor = e.shiftKey;
      const kind = forcedDoor ? "door" : (obMode === "door" ? "door" : "wall");
      addObstacle(kind, x,y,w,h);
    });

    // ===== CENAS (SAVE/LOAD) =====
    function openScenePanel(){
      if (!isHost) return alert("Apenas o Host.");
      scenePanel.classList.toggle('show');
      updateQualityLabel();
      updateSceneSizeEstimate();
    }

    function byteLengthOfString(str){ return new Blob([str]).size; }
    function prettyBytes(bytes){
      const units=["B","KB","MB","GB"];
      let i=0,num=bytes;
      while(num>=1024 && i<units.length-1){ num/=1024; i++; }
      return `${num.toFixed(i===0?0:2)} ${units[i]}`;
    }

    function updateQualityLabel(){
      const q=document.getElementById('quality');
      const label=document.getElementById('quality-label');
      if (q && label) label.textContent=`Q ${Number(q.value).toFixed(2)}`;
    }

    function estimatePayloadSizeBytes(payload){
      try{ return byteLengthOfString(JSON.stringify(payload)); }
      catch{ return 0; }
    }

    function updateSceneSizeEstimate(){
      if (!isHost) return;
      const payload={
        version:5,
        savedAt:new Date().toISOString(),
        map: state.map,
        tokens: state.tokens,
        layerState,
        obstacles: state.obstacles
      };
      const bytes=estimatePayloadSizeBytes(payload);
      document.getElementById('scene-size').textContent = `~ ${prettyBytes(bytes)}`;
    }

    function blobToDataURL(blob){
      return new Promise((resolve,reject)=>{
        const r=new FileReader();
        r.onload=()=>resolve(r.result);
        r.onerror=reject;
        r.readAsDataURL(blob);
      });
    }

    async function tryFetchAsBlob(url){
      try{
        const resp=await fetch(url,{mode:"cors"});
        if(!resp.ok) throw 0;
        return await resp.blob();
      }catch{ return null; }
    }

    async function tryFetchAsDataURL(url){
      const blob=await tryFetchAsBlob(url);
      if(!blob) return null;
      if(!blob.type.startsWith("image/")) return null;
      return await blobToDataURL(blob);
    }

    async function compressBlobToWebP(blob, maxDim, quality){
      try{
        const bmp=await createImageBitmap(blob);
        const w=bmp.width,h=bmp.height;
        const s=Math.min(1, maxDim/Math.max(w,h));
        const nw=Math.max(1,Math.round(w*s));
        const nh=Math.max(1,Math.round(h*s));
        const c=document.createElement('canvas');
        c.width=nw; c.height=nh;
        const ctx=c.getContext('2d',{alpha:true});
        ctx.drawImage(bmp,0,0,nw,nh);
        const outBlob=await new Promise(res=>c.toBlob(res,"image/webp",quality));
        if(!outBlob) return null;
        return await blobToDataURL(outBlob);
      }catch{ return null; }
    }

    async function compressDataURLToWebP(dataUrl, maxDim, quality){
      try{
        const resp=await fetch(dataUrl);
        const blob=await resp.blob();
        if(!blob.type.startsWith("image/")) return null;
        return await compressBlobToWebP(blob,maxDim,quality);
      }catch{ return null; }
    }

    async function compressImageSrcIfPossible(src, maxDim, quality){
      if (typeof src==="string" && src.startsWith("http")){
        const blob=await tryFetchAsBlob(src);
        if(!blob || !blob.type.startsWith("image/")) return src;
        const webp=await compressBlobToWebP(blob,maxDim,quality);
        return webp || src;
      }
      if (typeof src==="string" && src.startsWith("data:image")){
        const webp=await compressDataURLToWebP(src,maxDim,quality);
        return webp || src;
      }
      return src;
    }

    async function buildScenePayloadSelfContained(){
      if (!isHost) return null;

      const embedRemote = !!document.getElementById('embed-remote')?.checked;
      const compress = !!document.getElementById('compress-images')?.checked;
      const maxDim = parseInt(document.getElementById('max-dim')?.value || "2048", 10);
      const quality = parseFloat(document.getElementById('quality')?.value || "0.75");

      const payload = {
        version:5,
        savedAt:new Date().toISOString(),
        map: JSON.parse(JSON.stringify(state.map)),
        tokens: JSON.parse(JSON.stringify(state.tokens)),
        layerState: JSON.parse(JSON.stringify(layerState)),
        obstacles: JSON.parse(JSON.stringify(state.obstacles))
      };

      if (payload.map?.src){
        if (embedRemote && payload.map.src.startsWith("http")){
          const du = await tryFetchAsDataURL(payload.map.src);
          if (du) payload.map.src = du;
        }
        if (compress && (payload.map.src.startsWith("http") || payload.map.src.startsWith("data:image"))){
          payload.map.src = await compressImageSrcIfPossible(payload.map.src, maxDim, quality);
        }
      }

      for (const id of Object.keys(payload.tokens)){
        const t = payload.tokens[id];
        if (!t?.src) continue;

        if (embedRemote && typeof t.src==="string" && t.src.startsWith("http")){
          const du = await tryFetchAsDataURL(t.src);
          if (du) t.src = du;
        }
        if (compress && t.type==="image"){
          t.src = await compressImageSrcIfPossible(t.src, maxDim, quality);
        }
      }

      return payload;
    }

    async function saveSceneToFile(){
      if (!isHost) return alert("Apenas o Host.");
      showNotification("Salvando...");
      const payload = await buildScenePayloadSelfContained();
      if (!payload) return;

      const json=JSON.stringify(payload);
      const blob=new Blob([json],{type:"application/json"});

      const a=document.createElement('a');
      a.href=URL.createObjectURL(blob);
      a.download=`cena-${new Date().toISOString().replace(/[:.]/g,'-')}.json`;
      document.body.appendChild(a);
      a.click();
      a.remove();
      setTimeout(()=>URL.revokeObjectURL(a.href),1500);

      showNotification(`Cena salva (${prettyBytes(blob.size)})!`);
      updateSceneSizeEstimate();
    }

    function hostLoadScenePayload(payload){
      if (!isHost) return;
      if (!payload || typeof payload!=="object") return alert("Cena inv√°lida.");

      const clear = { type:"CLEAR" };
      applyAction(clear,false); broadcastACT(clear);

      if (payload.layerState){
        layerState.visible = payload.layerState.visible || {};
        layerState.locked = payload.layerState.locked || {};
      }

      // obst√°culos
      state.obstacles = Array.isArray(payload.obstacles) ? payload.obstacles : [];
      const obSync = { type:"OB_BULK_SET", obstacles: state.obstacles };
      applyAction(obSync,false); broadcastACT(obSync);

      const map = payload.map || {src:null,locked:false,x:0,y:0};
      if (map.src){
        const a = { type:"MAP_SET", src: map.src, locked: !!map.locked, x: Number(map.x||0), y: Number(map.y||0) };
        applyAction(a,false); broadcastACT(a);
      } else {
        const lockA = { type:"MAP_LOCK", locked: !!map.locked };
        applyAction(lockA,false); broadcastACT(lockA);
        const moveA = { type:"MAP_MOVE", x: Number(map.x||0), y: Number(map.y||0) };
        applyAction(moveA,false); broadcastACT(moveA);
      }

      const tokens = payload.tokens || {};
      for (const id of Object.keys(tokens)){
        const t = tokens[id];
        if (!t?.src || !t.type) continue;
        ensureLayerDefaults(Number(t.layer||2));
        const create = {
          type:"CREATE_TOKEN",
          id,
          src: t.src,
          contentType: t.type,
          props: {
            kind: t.kind || "asset",
            layer: Number(t.layer||2),
            x: t.x, y: t.y, w: t.w, h: t.h,
            rotation: t.rotation, flipped: t.flipped,
            innerZoom: t.innerZoom, locked: t.locked,
            fitMode: t.fitMode || "contain"
          }
        };
        applyAction(create,false); broadcastACT(create);
      }

      applyLayerVisibilityToDOM();
      rebuildLayersPanel();
      renderObstacles();
      renderObstaclesList();
      showNotification("Cena carregada!");
      updateSceneSizeEstimate();
    }

    function loadSceneFromFile(event){
      if (!isHost) return;
      const file=event.target.files?.[0];
      if (!file) return;
      const r=new FileReader();
      r.onload=()=>{
        try{
          const payload=JSON.parse(String(r.result||"{}"));
          hostLoadScenePayload(payload);
        }catch{ alert("JSON inv√°lido."); }
        event.target.value="";
      };
      r.readAsText(file);
    }

    // ===== CLEAR / UNLOCK =====
    function clearTable(emit=true){
      if (!isHost) return;
      if (emit && !confirm("Deseja limpar todos os tokens e o mapa?")) return;
      const action={ type:"CLEAR" };
      applyAction(action,false); broadcastACT(action);
      updateSceneSizeEstimate();
    }

    function unlockEverything(){
      if (!isHost) return;
      document.querySelectorAll('.token.locked').forEach(t=>{
        const id=t.dataset.uuid;
        const action={ type:"UPDATE_PROP", id, prop:"locked", value:"false" };
        applyAction(action,false); broadcastACT(action);
      });
      if (state.map.locked) setMapLockLocal(false,true);
      updateSceneSizeEstimate();
    }

    // ===== PROTOCOLO REDE (Host autoritativo) =====
    function sendREQ(action){
      if (isHost){
        applyHostAuthorizedAction(action,{sender:myId});
        return;
      }
      if (hostConnection?.open){
        hostConnection.send({kind:"REQ", sender:myId, action});
      }
    }

    function broadcastACT(action, meta={}){
      if (!isHost) return;
      const msg={kind:"ACT", sender:myId, action, meta};
      connections.forEach(c=>{ if(c.open) c.send(msg); });
    }

    function sendSYNC(conn){
      if (!isHost) return;
      conn.send({kind:"SYNC", sender:myId, state, layerState});
    }

    function forceResync(){
      if (isHost){
        // host: reenviar SYNC pra todos
        connections.forEach(c=>{ if(c.open) sendSYNC(c); });
        showNotification("SYNC reenviado!");
        return;
      }
      if (hostConnection?.open){
        hostConnection.send({kind:"NEED_SYNC", sender:myId});
        showNotification("Pedindo SYNC...");
      }
    }

    function handleNetworkData(data, connPeerId=null){
      if (!data?.kind) return;

      if (data.kind==="SYNC"){
        lastHostSeenAt = Date.now();
        applyFullSync(data.state, data.layerState);
        // confirma recebimento (ajuda host a reenviar se necess√°rio)
        if (!isHost && hostConnection?.open){
          hostConnection.send({kind:"ACK_SYNC", sender:myId});
        }
        return;
      }

      if (data.kind==="ACT"){
        lastHostSeenAt = Date.now();
        applyAction(data.action,true);
        return;
      }

      if (data.kind==="REQ"){
        if (!isHost) return;
        const sender=data.sender || connPeerId || "unknown";
        applyHostAuthorizedAction(data.action,{sender});
        return;
      }

      // NOVO: handshake e resync
      if (data.kind==="HELLO"){
        if (!isHost) return;
        // envia SYNC ap√≥s um pequeno atraso pra reduzir ‚Äú√†s vezes n√£o aparece‚Äù
        const conn = connections.find(c=>c.peer===data.sender) || null;
        if (conn?.open){
          setTimeout(()=>sendSYNC(conn), 120);
        }
        return;
      }

      if (data.kind==="NEED_SYNC"){
        if (!isHost) return;
        const conn = connections.find(c=>c.peer===data.sender) || null;
        if (conn?.open){
          sendSYNC(conn);
        }
        return;
      }

      if (data.kind==="PING"){
        if (isHost){
          // host responde com PONG
          const conn = connections.find(c=>c.peer===data.sender) || null;
          conn?.open && conn.send({kind:"PONG", sender:myId});
        }
        return;
      }

      if (data.kind==="PONG"){
        lastHostSeenAt = Date.now();
        return;
      }

      if (data.kind==="ACK_SYNC"){
        // opcional: poderia marcar ‚Äúok‚Äù
        return;
      }
    }

    // ===== VALIDA√á√ÉO (player) =====
    function validateClientAction(action){
      if (!action?.type) return {ok:false,reason:"A√ß√£o inv√°lida"};

      // allow: MOVE, UPDATE_PROP, OB_TOGGLE (opcional)
      const allowed = new Set(["MOVE","UPDATE_PROP","OB_TOGGLE"]);
      if (!allowed.has(action.type)) return {ok:false,reason:"A√ß√£o n√£o permitida"};

      if (action.type==="OB_TOGGLE"){
        // permitir players abrirem portas? (se n√£o quiser, bloqueia aqui)
        const ob = (state.obstacles||[]).find(o=>o.id===action.id);
        if (!ob || ob.kind!=="door") return {ok:false,reason:"Porta inv√°lida"};
        return {ok:true};
      }

      const id=action.id;
      if (!id || !state.tokens[id]) return {ok:false,reason:"Token inexistente"};

      const tok=state.tokens[id];
      const layer = Number(tok.layer||2);
      ensureLayerDefaults(layer);

      if (!layerState.visible[layer]) return {ok:false,reason:"Layer oculta"};
      if (layerState.locked[layer]) return {ok:false,reason:"Layer trancada"};
      if (String(tok.locked)==="true") return {ok:false,reason:"Token travado"};

      if (action.type==="UPDATE_PROP"){
        const allowedProps = new Set(["rotation","flipped","innerZoom","size","fitMode","layer"]);
        if (!allowedProps.has(action.prop)) return {ok:false,reason:"Prop n√£o permitida"};

        if (action.prop==="innerZoom"){
          const z=Number(action.value);
          if (!Number.isFinite(z) || z<.2 || z>5) return {ok:false,reason:"Zoom inv√°lido"};
        }
        if (action.prop==="size"){
          const w=Number(action.value?.w), h=Number(action.value?.h);
          if(!Number.isFinite(w)||!Number.isFinite(h)) return {ok:false,reason:"Size inv√°lido"};
          if(w<40||w>2500||h<40||h>2500) return {ok:false,reason:"Size fora limite"};
        }
        if (action.prop==="fitMode"){
          const m=String(action.value);
          if(!["contain","cover"].includes(m)) return {ok:false,reason:"fit inv√°lido"};
        }
        if (action.prop==="layer"){
          const l=Number(action.value);
          if(!Number.isFinite(l)||l<1||l>50) return {ok:false,reason:"Layer inv√°lida"};
        }
      }

      // f√≠sica server-side: garante que MOVE n√£o atravesse obst√°culos
      if (action.type==="MOVE"){
        const x=parseFloat(action.x||"0");
        const y=parseFloat(action.y||"0");
        const w=Number(tok.w||140);
        const h=Number(tok.h||140);

        const solids = getSolidObstacles();
        if (solids.length){
          const resolved = resolveRectCollision({x,y,w,h}, solids);
          action.x = resolved.x + "px";
          action.y = resolved.y + "px";
        }
      }

      return {ok:true};
    }

    function applyHostAuthorizedAction(action,{sender}){
      const fromClient = sender && sender !== myId;
      if (fromClient){
        const v=validateClientAction(action);
        if (!v.ok){ console.warn("REQ negada:", v.reason, action); return; }
      }
      applyAction(action,false);
      broadcastACT(action,{approvedBy:myId, originalSender:sender});
    }

    // ===== APPLY ACTION =====
    function applyAction(action, fromNetwork){
      switch(action.type){
        case "CLEAR":{
          document.querySelectorAll('.token').forEach(t=>t.remove());
          mapContainer.innerHTML="";
          document.querySelectorAll('.dice-entry').forEach(l=>l.remove());
          selectedToken=null;
          stopMapInertia();
          mapDragging=false;

          state.map={src:null,locked:false,x:0,y:0};
          state.tokens={};
          state.obstacles=[];

          setMapLockLocal(false,false);
          setMapOffset(0,0);

          renderObstacles();
          renderObstaclesList();
          rebuildLayersPanel();
          applyLayerVisibilityToDOM();
          break;
        }

        case "MAP_SET":{
          // at√¥mico: src + locked + pos
          state.map.src = action.src ?? null;
          if (typeof action.locked !== "undefined") state.map.locked = !!action.locked;
          if (typeof action.x !== "undefined") state.map.x = Number(action.x||0);
          if (typeof action.y !== "undefined") state.map.y = Number(action.y||0);

          if (state.map.src) applyMapLocal(state.map.src,false);
          setMapLockLocal(!!state.map.locked,false);
          setMapOffset(Number(state.map.x||0), Number(state.map.y||0));
          break;
        }

        case "MAP_UPDATE":{
          state.map.src = action.src;
          applyMapLocal(action.src,false);
          break;
        }

        case "MAP_LOCK":{
          setMapLockLocal(!!action.locked,false);
          break;
        }

        case "MAP_MOVE":{
          const x=Number(action.x||0), y=Number(action.y||0);
          setMapOffset(x,y);
          break;
        }

        case "CREATE_TOKEN":{
          const {id, src, contentType, props} = action;
          addTokenLocal(src, contentType, id, props);
          state.tokens[id]=normalizeTokenProps(id,src,contentType,props);
          rebuildLayersPanel();
          applyLayerVisibilityToDOM();
          break;
        }

        case "REMOVE_TOKEN":{
          const {id}=action;
          removeTokenLocal(id);
          delete state.tokens[id];
          rebuildLayersPanel();
          applyLayerVisibilityToDOM();
          break;
        }

        case "MOVE":{
          const {id,x,y}=action;
          moveTokenDOM(id,x,y);
          if (state.tokens[id]){ state.tokens[id].x=x; state.tokens[id].y=y; }
          break;
        }

        case "UPDATE_PROP":{
          const {id,prop,value}=action;
          updateTokenPropDOM(id,prop,value);
          if (state.tokens[id]){
            if (prop==="locked") state.tokens[id].locked=String(value);
            if (prop==="innerZoom") state.tokens[id].innerZoom=value;
            if (prop==="rotation") state.tokens[id].rotation=value;
            if (prop==="flipped") state.tokens[id].flipped=value;
            if (prop==="fitMode") state.tokens[id].fitMode=value;
            if (prop==="size"){ state.tokens[id].w=value.w; state.tokens[id].h=value.h; }
            if (prop==="layer"){
              state.tokens[id].layer=Number(value);
              ensureLayerDefaults(Number(value));
            }
          }
          rebuildLayersPanel();
          applyLayerVisibilityToDOM();
          break;
        }

        case "DICE":{
          showDiceLog(action.faces, action.result);
          break;
        }

        case "LAYER_SET":{
          const l=Number(action.layer);
          ensureLayerDefaults(l);
          if (action.prop==="visible") layerState.visible[l]=!!action.value;
          if (action.prop==="locked") layerState.locked[l]=!!action.value;
          applyLayerVisibilityToDOM();
          rebuildLayersPanel();
          break;
        }

        // Obst√°culos
        case "OB_ADD":{
          const ob = action.ob;
          if (!ob?.id) break;
          state.obstacles = Array.isArray(state.obstacles) ? state.obstacles : [];
          state.obstacles.push({
            id: ob.id,
            kind: ob.kind==="door" ? "door" : "wall",
            x: Number(ob.x||0), y: Number(ob.y||0),
            w: Number(ob.w||50), h: Number(ob.h||50),
            open: !!ob.open
          });
          renderObstacles();
          break;
        }

        case "OB_REMOVE":{
          state.obstacles = (state.obstacles||[]).filter(o=>o.id!==action.id);
          renderObstacles();
          break;
        }

        case "OB_CLEAR":{
          state.obstacles = [];
          renderObstacles();
          break;
        }

        case "OB_TOGGLE":{
          const id = action.id;
          const ob = (state.obstacles||[]).find(o=>o.id===id);
          if (ob && ob.kind==="door"){
            ob.open = !ob.open;
          }
          renderObstacles();
          break;
        }

        case "OB_BULK_SET":{
          state.obstacles = Array.isArray(action.obstacles) ? action.obstacles : [];
          renderObstacles();
          break;
        }
      }
      if (isHost) updateSceneSizeEstimate();
    }

    function applyFullSync(s, ls){
      // limpa DOM
      document.querySelectorAll('.token').forEach(t=>t.remove());
      mapContainer.innerHTML="";
      document.querySelectorAll('.dice-entry').forEach(l=>l.remove());
      selectedToken=null;
      stopMapInertia();

      // aplica layerState
      layerState.visible = ls?.visible || {};
      layerState.locked = ls?.locked || {};

      // aplica estado
      if (s?.map){
        state.map = JSON.parse(JSON.stringify(s.map));
        if (state.map.src) applyMapLocal(state.map.src,false);
        setMapLockLocal(!!state.map.locked,false);
        setMapOffset(Number(state.map.x||0), Number(state.map.y||0));
      }

      // obst√°culos
      state.obstacles = Array.isArray(s?.obstacles) ? JSON.parse(JSON.stringify(s.obstacles)) : [];
      renderObstacles();

      state.tokens = {};
      const tokens = s?.tokens || {};
      for (const id of Object.keys(tokens)){
        const t=tokens[id];
        ensureLayerDefaults(Number(t.layer||2));
        addTokenLocal(t.src, t.type, id, t);
        state.tokens[id]=JSON.parse(JSON.stringify(t));
      }

      applyLayerVisibilityToDOM();
      rebuildLayersPanel();
      updateSceneSizeEstimate();

      // seguran√ßa: se por algum motivo n√£o renderizou, tenta re-render ap√≥s curto delay
      setTimeout(()=>{
        renderObstacles();
        applyLayerVisibilityToDOM();
      }, 180);
    }

    // ===== PeerJS setup =====
    function initNetwork(){
      const urlParams=new URLSearchParams(window.location.search);
      const roomID=urlParams.get('room');

      peer=new Peer(null,{debug:2, config:PEER_ICE_CONFIG});

      peer.on('open',(id)=>{
        myId=id;

        if (roomID){
          isHost=false;
          setRoleUI();
          statusText.innerText="Conectando ao Host...";
          tinyStatus.textContent="Conectando...";
          tinyRoom.textContent=roomID;
          connectToHost(roomID);
        } else {
          isHost=true;
          setRoleUI();
          statusText.innerText="Online (Host)";
          tinyStatus.textContent="Online (Host)";
          tinyRoom.textContent=id;
          statusDot.classList.add('online');
          toggleNetworkPanel();

          peer.on('connection',(conn)=>{
            connections.push(conn);
            setupConnection(conn);

            conn.on('open',()=>{
              // envia SYNC e tamb√©m agenda um refor√ßo
              sendSYNC(conn);
              setTimeout(()=>sendSYNC(conn), 250);
            });

            conn.on('close',()=>{connections=connections.filter(c=>c!==conn);});
          });
        }

        startHeartbeat();
      });

      peer.on('error',(err)=>{
        console.error(err);
        statusText.innerText="Erro Rede";
        tinyStatus.textContent="Erro Rede";
        statusDot.classList.remove('online');
      });
    }

    function connectToHost(hostId){
      hostConnection=peer.connect(hostId);
      setupConnection(hostConnection);

      hostConnection.on('open',()=>{
        statusText.innerText="Conectado";
        tinyStatus.textContent="Conectado";
        statusDot.classList.add('online');

        // NOVO: handshake
        hostConnection.send({kind:"HELLO", sender:myId});

        // resync de seguran√ßa (caso mensagens iniciais se percam)
        setTimeout(()=>forceResync(), 600);
        setTimeout(()=>forceResync(), 1400);
      });

      hostConnection.on('close',()=>{
        statusText.innerText="Desconectado";
        tinyStatus.textContent="Desconectado";
        statusDot.classList.remove('online');
        alert("O Host desconectou.");
      });
    }

    function setupConnection(conn){
      conn.on('data',(data)=>handleNetworkData(data, conn.peer));
    }

    function startHeartbeat(){
      if (heartbeatTimer) clearInterval(heartbeatTimer);
      if (resyncTimer) clearInterval(resyncTimer);

      // ping/pong simples pra detectar host ‚Äútravado‚Äù
      heartbeatTimer = setInterval(()=>{
        if (isHost){
          // host: manda ACT "noop" ? n√£o precisa, mas pode pingar clientes
          // aqui s√≥ mant√©m ‚Äúonline‚Äù
        } else {
          if (hostConnection?.open){
            hostConnection.send({kind:"PING", sender:myId});
          }
        }
      }, 2000);

      // se ficar muito tempo sem host, tenta resync
      resyncTimer = setInterval(()=>{
        if (isHost) return;
        const now = Date.now();
        if (!lastHostSeenAt) lastHostSeenAt = now;
        const silentMs = now - lastHostSeenAt;

        // se passou 6s sem ver host, pede sync
        if (silentMs > 6000){
          forceResync();
          lastHostSeenAt = now; // evita spam
        }

        // tamb√©m: se tokens no DOM < tokens do estado, pede sync
        const domTokens = document.querySelectorAll('.token').length;
        const stTokens = Object.keys(state.tokens||{}).length;
        if (stTokens && domTokens < stTokens){
          forceResync();
        }
      }, 3500);
    }

    // ===== Scene UI hooks =====
    function initUI(){
      const q=document.getElementById('quality');
      q?.addEventListener('input',updateQualityLabel);
      q?.addEventListener('change',updateSceneSizeEstimate);
      document.getElementById('max-dim')?.addEventListener('change',updateSceneSizeEstimate);
      document.getElementById('compress-images')?.addEventListener('change',updateSceneSizeEstimate);
      document.getElementById('embed-remote')?.addEventListener('change',updateSceneSizeEstimate);
      updateQualityLabel();
      updateSceneSizeEstimate();

      // Obst√°culos inicia render
      renderObstacles();
    }

    // ===== Context menu off =====
    window.addEventListener('contextmenu',(e)=>e.preventDefault());

    // ===== Start =====
    initNetwork();
    initUI();
  </script>
</body>
</html>

