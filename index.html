<!doctype html>
<html lang="pt-br">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Mesa Atelier</title>
  <meta name="theme-color" content="#0b0f1a" />

  <style>
    :root{
      --bg:#0b0f1a;
      --bg2:#070a12;
      --panel:rgba(18, 24, 40, .82);
      --panel2:rgba(12, 16, 28, .82);
      --card:rgba(0,0,0,.22);
      --text:#eaf0ff;
      --muted:#aab6d6;
      --muted2:#7f8ab0;
      --line:rgba(255,255,255,.10);
      --line2:rgba(255,255,255,.16);
      --accent:#6a5cff;
      --accent2:#38d996;
      --warn:#ffcc66;
      --danger:#ff4d6d;
      --shadow: 0 22px 80px rgba(0,0,0,.55);
      --shadow2: 0 12px 40px rgba(0,0,0,.45);
      --radius:18px;
      --radius2:14px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }

    *{ box-sizing:border-box; }
    html, body{ height:100%; }
    body{
      margin:0;
      color:var(--text);
      font-family:var(--sans);
      overflow:hidden;
      background:
        radial-gradient(1200px 900px at 15% 10%, rgba(106,92,255,.18), transparent 60%),
        radial-gradient(900px 700px at 85% 28%, rgba(56,217,150,.10), transparent 55%),
        radial-gradient(900px 700px at 60% 95%, rgba(255,204,102,.06), transparent 55%),
        linear-gradient(180deg, var(--bg), var(--bg2));
    }

    /* App layout */
    .app{
      height:100%;
      display:grid;
      grid-template-columns: 380px 1fr;
      gap:12px;
      padding:12px;
    }

    /* Sidebar */
    .side{
      border:1px solid var(--line);
      border-radius: var(--radius);
      background: linear-gradient(180deg, rgba(18,24,40,.88), rgba(10,14,24,.86));
      box-shadow: var(--shadow);
      overflow:hidden;
      display:flex;
      flex-direction:column;
      min-width: 320px;
    }

    .sideTop{
      padding:14px 14px 10px;
      border-bottom:1px solid var(--line);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }

    .brand{
      display:flex;
      flex-direction:column;
      gap:4px;
      min-width:0;
    }
    .brand .title{
      font-size:15px;
      font-weight:900;
      letter-spacing:.4px;
      line-height:1.1;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .brand .sub{
      font-family:var(--mono);
      font-size:11px;
      color:var(--muted);
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      opacity:.95;
    }

    .sideActions{ display:flex; gap:8px; }
    .iconBtn{
      width:36px; height:36px;
      display:inline-flex;
      align-items:center; justify-content:center;
      border-radius: 12px;
      border:1px solid var(--line);
      background: rgba(0,0,0,.18);
      cursor:pointer;
      user-select:none;
      transition: transform .08s ease, border-color .08s ease, background .08s ease;
    }
    .iconBtn:hover{ transform: translateY(-1px); border-color: var(--line2); }
    .iconBtn svg{ width:18px; height:18px; opacity:.9; }

    .sideScroll{
      padding:12px;
      overflow:auto;
      flex:1;
    }

    .section{
      border:1px solid var(--line);
      background: rgba(0,0,0,.16);
      border-radius: var(--radius);
      margin-bottom:12px;
      overflow:hidden;
    }

    .secHead{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding:12px 12px;
      border-bottom:1px solid var(--line);
      background: rgba(0,0,0,.12);
      cursor:pointer;
      user-select:none;
    }
    .secHead .left{
      display:flex;
      align-items:center;
      gap:10px;
      min-width:0;
    }
    .chip{
      font-family:var(--mono);
      font-size:10px;
      padding:3px 8px;
      border-radius:999px;
      border:1px solid var(--line);
      background: rgba(0,0,0,.18);
      color: var(--muted);
      white-space:nowrap;
    }
    .secTitle{
      font-size:13px;
      font-weight:900;
      letter-spacing:.2px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .chev{
      width:18px;height:18px;opacity:.75;
      transition: transform .12s ease;
      flex:0 0 auto;
    }
    .section.closed .chev{ transform: rotate(-90deg); }
    .secBody{ padding:12px; }
    .section.closed .secBody{ display:none; }

    .hint{
      color: var(--muted);
      font-size:12px;
      line-height:1.45;
      margin-top:8px;
    }

    .row{ display:flex; gap:10px; flex-wrap:wrap; }
    .col{ flex:1; min-width: 140px; }

    label{
      display:block;
      font-size:11px;
      color: var(--muted);
      margin: 10px 0 6px;
      letter-spacing:.2px;
    }
    input[type="text"], input[type="number"], textarea, select{
      width:100%;
      padding:10px 10px;
      border-radius: 12px;
      border:1px solid var(--line);
      background: rgba(0,0,0,.22);
      color: var(--text);
      outline:none;
      transition: border-color .08s ease;
    }
    input[type="text"]:focus, input[type="number"]:focus, textarea:focus, select:focus{
      border-color: rgba(106,92,255,.55);
    }
    input[type="range"]{ width:100%; }
    textarea{ min-height: 120px; resize: vertical; }

    .btns{ display:flex; gap:10px; flex-wrap:wrap; margin-top:10px; }
    button{
      border:1px solid var(--line);
      background: rgba(0,0,0,.20);
      color: var(--text);
      border-radius: 12px;
      padding:10px 12px;
      cursor:pointer;
      font-weight:800;
      font-size:12px;
      transition: transform .08s ease, border-color .08s ease, background .08s ease;
      user-select:none;
      white-space:nowrap;
    }
    button:hover{ transform: translateY(-1px); border-color: var(--line2); }
    button.primary{ border-color: rgba(106,92,255,.55); background: rgba(106,92,255,.18); }
    button.ok{ border-color: rgba(56,217,150,.55); background: rgba(56,217,150,.14); }
    button.warn{ border-color: rgba(255,204,102,.55); background: rgba(255,204,102,.12); }
    button.danger{ border-color: rgba(255,77,109,.55); background: rgba(255,77,109,.12); }
    button.ghost{ background: transparent; }

    .divider{ height:1px; background: var(--line); margin:12px 0; }

    .seg{
      display:flex;
      border:1px solid var(--line);
      background: rgba(0,0,0,.18);
      border-radius: 14px;
      overflow:hidden;
    }
    .seg button{
      border:none;
      border-right:1px solid var(--line);
      background: transparent;
      border-radius:0;
      padding:10px 10px;
      flex:1;
      font-size:12px;
      font-weight:900;
      color: var(--muted);
      transform:none;
    }
    .seg button:last-child{ border-right:none; }
    .seg button.active{
      background: rgba(106,92,255,.18);
      color: var(--text);
    }

    .switchRow{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding:10px 10px;
      border:1px solid var(--line);
      border-radius: 14px;
      background: rgba(0,0,0,.18);
      margin-top:10px;
    }
    .switchRow .text{
      min-width:0;
    }
    .switchRow .text .t{
      font-size:12px;
      font-weight:900;
      letter-spacing:.2px;
    }
    .switchRow .text .s{
      margin-top:2px;
      font-size:11px;
      color: var(--muted);
      font-family: var(--mono);
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      max-width: 220px;
    }
    .toggle{
      width:44px; height:26px;
      border-radius: 999px;
      border:1px solid var(--line);
      background: rgba(0,0,0,.25);
      position:relative;
      cursor:pointer;
      flex:0 0 auto;
    }
    .toggle::after{
      content:"";
      position:absolute;
      left:3px; top:3px;
      width:20px; height:20px;
      border-radius: 999px;
      background: rgba(255,255,255,.85);
      transition: transform .12s ease, background .12s ease;
      box-shadow: 0 8px 18px rgba(0,0,0,.35);
    }
    .toggle.on{
      border-color: rgba(56,217,150,.55);
      background: rgba(56,217,150,.14);
    }
    .toggle.on::after{ transform: translateX(18px); background: rgba(56,217,150,.92); }

    .kbd{
      font-family:var(--mono);
      font-size:11px;
      color: var(--text);
      border:1px solid var(--line);
      padding:2px 6px;
      border-radius: 8px;
      background: rgba(0,0,0,.22);
    }

    /* Library grid */
    .grid{
      display:grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap:10px;
      margin-top:10px;
    }
    .thumb{
      border:1px solid var(--line);
      background: rgba(0,0,0,.18);
      border-radius: 14px;
      overflow:hidden;
      cursor:pointer;
      user-select:none;
      transition: transform .08s ease, border-color .08s ease;
      position:relative;
    }
    .thumb:hover{ transform: translateY(-1px); border-color: var(--line2); }
    .thumb img{
      width:100%;
      height:92px;
      object-fit:cover;
      display:block;
    }
    .thumb .cap{
      padding:8px 8px;
      font-size:11px;
      color: var(--muted);
      font-family: var(--mono);
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .thumb .badge{
      position:absolute;
      top:8px; left:8px;
      background: rgba(0,0,0,.55);
      border:1px solid rgba(255,255,255,.18);
      color: var(--text);
      font-size:10px;
      padding:3px 8px;
      border-radius: 999px;
      font-family: var(--mono);
      backdrop-filter: blur(6px);
    }

    /* Token list */
    .list{
      display:flex;
      flex-direction:column;
      gap:8px;
      margin-top:10px;
    }
    .item{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding:10px 10px;
      border-radius: 14px;
      border:1px solid var(--line);
      background: rgba(0,0,0,.16);
    }
    .item .meta{ min-width:0; display:flex; align-items:center; gap:10px; }
    .mini{
      width:34px; height:34px;
      border-radius: 12px;
      border:1px solid rgba(255,255,255,.16);
      background: rgba(0,0,0,.18);
      overflow:hidden;
      flex:0 0 auto;
      display:flex;
      align-items:center;
      justify-content:center;
    }
    .mini img{ width:100%; height:100%; object-fit:cover; display:block; }
    .item .meta .name{
      font-size:12px;
      font-weight:900;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      max-width: 220px;
    }
    .item .meta .sub{
      font-family:var(--mono);
      font-size:10px;
      color: var(--muted);
      margin-top:2px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .item .actions{ display:flex; gap:8px; }
    .tiny{
      padding:8px 10px;
      border-radius: 999px;
      font-size:11px;
      font-weight:900;
    }

    /* Stage */
    .stage{
      position:relative;
      border:1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
      background:
        radial-gradient(1400px 900px at 15% 15%, rgba(106,92,255,.10), transparent 60%),
        radial-gradient(900px 700px at 85% 30%, rgba(56,217,150,.07), transparent 55%),
        linear-gradient(180deg, rgba(18,24,40,.55), rgba(10,14,24,.58));
    }

    /* Top HUD */
    .hud{
      position:absolute;
      top:10px; left:10px; right:10px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      z-index:60;
      pointer-events:none;
    }
    .hudGroup{ display:flex; gap:8px; flex-wrap:wrap; }
    .hudPill{
      pointer-events:none;
      font-family:var(--mono);
      font-size:11px;
      color: var(--muted);
      background: rgba(0,0,0,.30);
      border:1px solid var(--line);
      padding:8px 10px;
      border-radius: 999px;
      backdrop-filter: blur(6px);
      white-space:nowrap;
    }
    .hudPill strong{ color: var(--text); font-weight:900; }
    .hudPill .dot{
      display:inline-block;
      width:8px;height:8px;border-radius:99px;
      background: var(--accent2);
      box-shadow:0 0 0 3px rgba(56,217,150,.18);
      margin-right:8px;
      vertical-align: -1px;
    }

    /* Tool bar */
    .toolBar{
      position:absolute;
      bottom:12px;
      left:50%;
      transform: translateX(-50%);
      z-index:70;
      background: rgba(0,0,0,.32);
      border:1px solid var(--line);
      border-radius: 18px;
      padding:8px;
      display:flex;
      gap:8px;
      backdrop-filter: blur(8px);
      box-shadow: var(--shadow2);
    }
    .toolBtn{
      width:42px; height:42px;
      border-radius: 14px;
      border:1px solid var(--line);
      background: rgba(0,0,0,.16);
      display:flex;
      align-items:center;
      justify-content:center;
      cursor:pointer;
      user-select:none;
      transition: transform .08s ease, border-color .08s ease, background .08s ease;
    }
    .toolBtn:hover{ transform: translateY(-1px); border-color: var(--line2); }
    .toolBtn.active{
      border-color: rgba(106,92,255,.65);
      background: rgba(106,92,255,.18);
    }
    .toolBtn svg{ width:18px; height:18px; opacity:.95; }

    /* Board */
    #board{
      position:absolute;
      left:0; top:0;
      transform-origin: 0 0;
      will-change: transform;
    }
    #mapLayer, #gridLayer, #tokenLayer, #fogLayer{
      position:absolute;
      left:0; top:0;
    }
    #mapImg{
      display:block;
      user-select:none;
      -webkit-user-drag:none;
      pointer-events:none;
      border-radius: 0;
    }
    canvas{ display:block; }
    #gridCanvas{ pointer-events:none; opacity:.92; }
    #fogCanvas{ pointer-events:none; } /* paint via stage, always */

    /* Tokens on board */
    .token{
      position:absolute;
      width: 64px;
      height: 64px;
      border-radius: 999px;
      border: 2px solid rgba(255,255,255,.30);
      background: rgba(0,0,0,.25);
      box-shadow: 0 14px 30px rgba(0,0,0,.35);
      transform-origin: 50% 50%;
      cursor: grab;
      user-select:none;
      touch-action:none;
      overflow:hidden;
      display:flex;
      align-items:center;
      justify-content:center;
    }
    .token:active{ cursor: grabbing; }
    .token.selected{
      border-color: rgba(106,92,255,.90);
      box-shadow: 0 0 0 4px rgba(106,92,255,.22), 0 14px 30px rgba(0,0,0,.35);
    }
    .token img{
      width:100%;
      height:100%;
      object-fit:cover;
      pointer-events:none;
      user-select:none;
      -webkit-user-drag:none;
    }
    .token .label{
      position:absolute;
      bottom:-18px;
      left:50%;
      transform: translateX(-50%);
      padding:4px 8px;
      border-radius: 999px;
      font-size: 11px;
      font-weight:900;
      color: var(--text);
      background: rgba(0,0,0,.45);
      border:1px solid rgba(255,255,255,.16);
      white-space:nowrap;
      max-width: 180px;
      overflow:hidden;
      text-overflow:ellipsis;
      pointer-events:none;
      font-family:var(--mono);
      backdrop-filter: blur(6px);
    }

    /* Overlay for ruler / cursor */
    #overlay{
      position:absolute;
      inset:0;
      pointer-events:none;
      z-index:80;
    }

    /* Toast */
    .toastWrap{
      position:absolute;
      top:64px; right:14px;
      z-index:120;
      display:flex;
      flex-direction:column;
      gap:8px;
      pointer-events:none;
    }
    .toast{
      pointer-events:none;
      background: rgba(0,0,0,.40);
      border:1px solid var(--line);
      border-radius: 14px;
      padding:10px 12px;
      color: var(--text);
      font-size:12px;
      backdrop-filter: blur(8px);
      box-shadow: var(--shadow2);
      max-width: 340px;
    }
    .toast .small{ color: var(--muted); font-family: var(--mono); font-size: 11px; margin-top: 3px; }

    /* Help modal */
    .modal{
      position:fixed;
      inset:0;
      background: rgba(0,0,0,.55);
      display:none;
      align-items:center;
      justify-content:center;
      z-index:200;
      padding:16px;
    }
    .modal.on{ display:flex; }
    .modalCard{
      width:min(920px, 100%);
      max-height: min(86vh, 760px);
      overflow:auto;
      border-radius: 20px;
      border:1px solid var(--line);
      background: linear-gradient(180deg, rgba(18,24,40,.92), rgba(10,14,24,.92));
      box-shadow: var(--shadow);
      padding:16px;
    }
    .modalTop{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      padding-bottom:10px;
      border-bottom:1px solid var(--line);
      margin-bottom:12px;
    }
    .modalTop .h{
      font-weight:1000;
      letter-spacing:.3px;
    }
    .modalGrid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:12px;
    }
    .callout{
      border:1px solid var(--line);
      background: rgba(0,0,0,.18);
      border-radius: 16px;
      padding:12px;
    }
    .callout h4{ margin:0 0 8px 0; font-size:13px; font-weight:1000; }
    .callout p{ margin:0; color: var(--muted); font-size:12px; line-height:1.45; }
    .callout ul{ margin:8px 0 0 18px; color: var(--muted); font-size:12px; line-height:1.55; }
    .callout li{ margin:4px 0; }

    @media (max-width: 1120px){
      .app{ grid-template-columns: 1fr; }
      .side{ order:2; }
      .stage{ order:1; min-height: 52vh; }
      .modalGrid{ grid-template-columns: 1fr; }
      .grid{ grid-template-columns: repeat(4, minmax(0,1fr)); }
    }
    @media (max-width: 640px){
      .grid{ grid-template-columns: repeat(2, minmax(0,1fr)); }
      .toolBar{ bottom:10px; }
    }
  </style>
</head>

<body>
  <div class="app">
    <aside class="side">
      <div class="sideTop">
        <div class="brand">
          <div class="title">Mesa Atelier</div>
          <div class="sub">VTT local · 1 arquivo · mapa · tokens · fog · dados</div>
        </div>

        <div class="sideActions">
          <div class="iconBtn" id="btnHelp" title="Guia rápido">
            <svg viewBox="0 0 24 24" fill="none"><path d="M12 18h.01M9.5 9.75a2.5 2.5 0 1 1 3.8 2.15c-.95.55-1.3 1-1.3 2.1v.5" stroke="currentColor" stroke-width="2" stroke-linecap="round"/><path d="M12 22c5.52 0 10-4.48 10-10S17.52 2 12 2 2 6.48 2 12s4.48 10 10 10Z" stroke="currentColor" stroke-width="2"/></svg>
          </div>
          <div class="iconBtn" id="btnExportTop" title="Exportar cena (JSON)">
            <svg viewBox="0 0 24 24" fill="none"><path d="M12 3v10m0 0 4-4m-4 4-4-4" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M4 15v4a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-4" stroke="currentColor" stroke-width="2" stroke-linecap="round"/></svg>
          </div>
          <div class="iconBtn" id="btnSaveTop" title="Salvar local (localStorage)">
            <svg viewBox="0 0 24 24" fill="none"><path d="M17 21H7a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h8l4 4v12a2 2 0 0 1-2 2Z" stroke="currentColor" stroke-width="2"/><path d="M7 21v-8h10v8" stroke="currentColor" stroke-width="2"/><path d="M9 7h6" stroke="currentColor" stroke-width="2" stroke-linecap="round"/></svg>
          </div>
        </div>
      </div>

      <div class="sideScroll">
        <!-- MAPA -->
        <div class="section" id="secMap">
          <div class="secHead" data-toggle>
            <div class="left">
              <div class="secTitle">Mapa</div>
              <div class="chip" id="chipMap">sem mapa</div>
            </div>
            <svg class="chev" viewBox="0 0 24 24" fill="none"><path d="m9 18 6-6-6-6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
          </div>
          <div class="secBody">
            <label>Carregar imagem do mapa</label>
            <input id="mapFile" type="file" accept="image/*" />
            <div class="btns">
              <button class="primary" id="btnLoadMap">Carregar</button>
              <button class="ghost" id="btnClearMap">Remover</button>
              <button class="warn" id="btnFit">Enquadrar</button>
            </div>

            <div class="divider"></div>

            <div class="row">
              <div class="col">
                <label>Largura (px)</label>
                <input id="mapW" type="number" min="200" step="10" />
              </div>
              <div class="col">
                <label>Altura (px)</label>
                <input id="mapH" type="number" min="200" step="10" />
              </div>
            </div>
            <div class="btns">
              <button id="btnApplyMapSize">Aplicar tamanho</button>
            </div>

            <div class="hint">
              Se você colocar mapa gigante, o export vai virar um JSON do tamanho da sua autoestima depois de 3h debugando.
            </div>
          </div>
        </div>

        <!-- TOKENS -->
        <div class="section" id="secTokens">
          <div class="secHead" data-toggle>
            <div class="left">
              <div class="secTitle">Tokens</div>
              <div class="chip" id="chipTokens">0 na mesa</div>
            </div>
            <svg class="chev" viewBox="0 0 24 24" fill="none"><path d="m9 18 6-6-6-6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
          </div>
          <div class="secBody">
            <label>Adicionar imagens à biblioteca</label>
            <input id="tokenFile" type="file" accept="image/*" multiple />
            <div class="btns">
              <button class="primary" id="btnAddTokenImgs">Adicionar</button>
            </div>

            <div class="row">
              <div class="col">
                <label>Nome padrão ao spawn</label>
                <input id="newTokenName" type="text" placeholder="Ex: Agente / Monstro / NPC" />
              </div>
              <div class="col">
                <label>Tamanho (px)</label>
                <input id="newTokenSize" type="number" min="24" step="4" value="64" />
              </div>
            </div>

            <div class="row">
              <div class="col">
                <label>Cor (token simples)</label>
                <input id="newTokenColor" type="text" value="rgba(106,92,255,.35)" />
              </div>
              <div class="col">
                <label>Shape</label>
                <select id="newTokenShape">
                  <option value="circle">Círculo</option>
                  <option value="square">Quadrado</option>
                </select>
              </div>
            </div>

            <div class="btns">
              <button class="ok" id="btnSpawnColor">Criar token simples</button>
              <button id="btnSpawnFromLibrary">Spawn (1º da biblioteca)</button>
            </div>

            <div class="divider"></div>

            <label>Biblioteca (clique para spawn)</label>
            <div id="libraryGrid" class="grid"></div>

            <div class="divider"></div>

            <label>Tokens na mesa</label>
            <input id="tokenSearch" type="text" placeholder="Buscar token na mesa..." />
            <div id="tableTokens" class="list"></div>
          </div>
        </div>

        <!-- TOKEN INSPECTOR -->
        <div class="section" id="secInspector">
          <div class="secHead" data-toggle>
            <div class="left">
              <div class="secTitle">Token selecionado</div>
              <div class="chip" id="chipSel">nenhum</div>
            </div>
            <svg class="chev" viewBox="0 0 24 24" fill="none"><path d="m9 18 6-6-6-6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
          </div>
          <div class="secBody">
            <div id="noSelection" class="hint">Selecione um token no mapa para editar aqui.</div>

            <div id="tokenEditor" style="display:none">
              <div class="row" style="align-items:center">
                <div class="mini" id="selPreview"></div>
                <div style="min-width:0">
                  <div style="font-weight:1000; font-size:12px" id="selTitle">Token</div>
                  <div style="font-family:var(--mono); color:var(--muted); font-size:10px" id="selId">id</div>
                </div>
              </div>

              <label>Nome</label>
              <input id="tokName" type="text" />

              <div class="row">
                <div class="col">
                  <label>X</label>
                  <input id="tokX" type="number" step="1" />
                </div>
                <div class="col">
                  <label>Y</label>
                  <input id="tokY" type="number" step="1" />
                </div>
              </div>

              <div class="row">
                <div class="col">
                  <label>Tamanho (px)</label>
                  <input id="tokSize" type="number" min="16" step="2" />
                </div>
                <div class="col">
                  <label>Rotação (graus)</label>
                  <input id="tokRot" type="number" step="1" />
                </div>
              </div>

              <div class="row">
                <div class="col">
                  <label>Shape</label>
                  <select id="tokShape">
                    <option value="circle">Círculo</option>
                    <option value="square">Quadrado</option>
                  </select>
                </div>
                <div class="col">
                  <label>Cor (se não tiver imagem)</label>
                  <input id="tokColor" type="text" />
                </div>
              </div>

              <div class="btns">
                <button id="btnCenterOnToken">Centralizar</button>
                <button class="danger" id="btnDeleteToken">Deletar</button>
              </div>

              <div class="hint">
                • Arrastar move<br/>
                • <span class="kbd">Del</span> apaga<br/>
                • <span class="kbd">Shift</span> move sem snap<br/>
              </div>
            </div>
          </div>
        </div>

        <!-- FERRAMENTAS -->
        <div class="section" id="secTools">
          <div class="secHead" data-toggle>
            <div class="left">
              <div class="secTitle">Ferramentas</div>
              <div class="chip" id="chipTool">selecionar</div>
            </div>
            <svg class="chev" viewBox="0 0 24 24" fill="none"><path d="m9 18 6-6-6-6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
          </div>
          <div class="secBody">
            <div class="hint" style="margin-top:0">
              Toolbar no rodapé é a forma “correta” de trocar ferramenta. Aqui é só espelho pra você não se perder.
            </div>

            <div class="switchRow">
              <div class="text">
                <div class="t">Grid</div>
                <div class="s"><span class="kbd">G</span> alterna</div>
              </div>
              <div class="toggle on" id="tgGrid"></div>
            </div>

            <div class="row">
              <div class="col">
                <label>Grid (px por quadrado)</label>
                <input id="gridSize" type="number" min="10" step="2" value="64" />
              </div>
              <div class="col">
                <label>Cor do grid</label>
                <input id="gridColor" type="text" value="rgba(255,255,255,0.12)" />
              </div>
            </div>

            <div class="switchRow">
              <div class="text">
                <div class="t">Snap no grid</div>
                <div class="s"><span class="kbd">Shift</span> ignora</div>
              </div>
              <div class="toggle on" id="tgSnap"></div>
            </div>

            <div class="btns">
              <button id="btnApplyGrid">Aplicar grid</button>
            </div>

            <div class="divider"></div>

            <div class="switchRow">
              <div class="text">
                <div class="t">Fog of War</div>
                <div class="s"><span class="kbd">F</span> alterna</div>
              </div>
              <div class="toggle on" id="tgFog"></div>
            </div>

            <div class="row">
              <div class="col">
                <label>Opacidade (visual)</label>
                <input id="fogOpacity" type="range" min="0" max="100" value="92" />
              </div>
              <div class="col">
                <label>Pincel</label>
                <input id="fogBrush" type="range" min="6" max="200" value="44" />
              </div>
            </div>

            <div class="btns">
              <button class="warn" id="btnFillFog">Cobrir tudo</button>
              <button id="btnClearFog">Revelar tudo</button>
            </div>

            <div class="divider"></div>

            <div class="hint">
              Atalhos úteis: <span class="kbd">Espaço</span> + arrastar (pan) · <span class="kbd">M</span> (régua) · roda do mouse (zoom)
            </div>
          </div>
        </div>

        <!-- DADOS -->
        <div class="section" id="secDice">
          <div class="secHead" data-toggle>
            <div class="left">
              <div class="secTitle">Dados</div>
              <div class="chip">1d20+5</div>
            </div>
            <svg class="chev" viewBox="0 0 24 24" fill="none"><path d="m9 18 6-6-6-6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
          </div>
          <div class="secBody">
            <label>Expressão</label>
            <input id="diceExpr" type="text" placeholder="Ex: 1d20+5, 2d6+1d4+3, d8" />
            <div class="btns">
              <button class="primary" id="btnRoll">Rolar</button>
              <button id="btnClearRolls">Limpar</button>
            </div>
            <div id="rolls" class="list"></div>
          </div>
        </div>

        <!-- INICIATIVA -->
        <div class="section" id="secIni">
          <div class="secHead" data-toggle>
            <div class="left">
              <div class="secTitle">Iniciativa</div>
              <div class="chip" id="chipIni">vazia</div>
            </div>
            <svg class="chev" viewBox="0 0 24 24" fill="none"><path d="m9 18 6-6-6-6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
          </div>
          <div class="secBody">
            <div class="row">
              <div class="col">
                <label>Nome</label>
                <input id="iniName" type="text" placeholder="Ex: Agente / Monstro" />
              </div>
              <div class="col">
                <label>Valor</label>
                <input id="iniVal" type="number" step="1" placeholder="Ex: 15" />
              </div>
            </div>
            <div class="btns">
              <button class="primary" id="btnAddIni">Adicionar</button>
              <button id="btnSortIni">Ordenar</button>
              <button class="ok" id="btnNextTurn">Próximo turno</button>
              <button class="danger" id="btnClearIni">Limpar</button>
            </div>
            <div id="iniList" class="list"></div>
          </div>
        </div>

        <!-- NOTAS -->
        <div class="section" id="secNotes">
          <div class="secHead" data-toggle>
            <div class="left">
              <div class="secTitle">Notas</div>
              <div class="chip">persistem no save</div>
            </div>
            <svg class="chev" viewBox="0 0 24 24" fill="none"><path d="m9 18 6-6-6-6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
          </div>
          <div class="secBody">
            <textarea id="notes" placeholder="Pistas, NPCs, nomes ridículos, planos que vão dar errado..."></textarea>
            <div class="btns">
              <button class="warn" id="btnSaveNotes">Salvar notas</button>
              <button id="btnClearNotes">Limpar</button>
            </div>
          </div>
        </div>

        <!-- SALVAR/CARREGAR -->
        <div class="section" id="secSave">
          <div class="secHead" data-toggle>
            <div class="left">
              <div class="secTitle">Salvar / Carregar</div>
              <div class="chip">JSON / local</div>
            </div>
            <svg class="chev" viewBox="0 0 24 24" fill="none"><path d="m9 18 6-6-6-6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
          </div>
          <div class="secBody">
            <label>Importar cena (JSON)</label>
            <input id="importFile" type="file" accept="application/json" />
            <div class="btns">
              <button class="primary" id="btnImport">Importar</button>
              <button class="ok" id="btnExport">Exportar</button>
            </div>

            <div class="divider"></div>

            <div class="btns">
              <button class="ok" id="btnSaveLocal">Salvar local</button>
              <button id="btnLoadLocal">Carregar local</button>
              <button class="danger" id="btnResetAll">Reset geral</button>
            </div>

            <div class="hint">
              Export salva tudo (inclusive imagens/fog em base64). LocalStorage pode falhar se ficar grande demais.
            </div>
          </div>
        </div>

      </div>
    </aside>

    <main class="stage" id="stage">
      <div class="hud">
        <div class="hudGroup">
          <div class="hudPill"><span class="dot"></span><strong>Pronto</strong> <span id="hudMode">selecionar</span></div>
          <div class="hudPill"><strong>Zoom</strong> <span id="hudZoom">100%</span></div>
          <div class="hudPill"><strong>Grid</strong> <span id="hudGrid">64px</span></div>
          <div class="hudPill"><strong>Tokens</strong> <span id="hudTokens">0</span></div>
        </div>
        <div class="hudGroup">
          <div class="hudPill"><strong>Mouse</strong> roda=zoom · <span class="kbd">Espaço</span>+arrasta=pan</div>
        </div>
      </div>

      <div class="toastWrap" id="toastWrap"></div>

      <canvas id="overlay"></canvas>

      <div id="board">
        <div id="mapLayer"><img id="mapImg" alt="Mapa" /></div>
        <div id="gridLayer"><canvas id="gridCanvas"></canvas></div>
        <div id="tokenLayer"></div>
        <div id="fogLayer"><canvas id="fogCanvas"></canvas></div>
      </div>

      <!-- Toolbar -->
      <div class="toolBar" id="toolBar">
        <div class="toolBtn active" data-tool="select" title="Selecionar (V)">
          <svg viewBox="0 0 24 24" fill="none"><path d="M7 3l12 7-7 2-2 7-3-16Z" stroke="currentColor" stroke-width="2" stroke-linejoin="round"/></svg>
        </div>
        <div class="toolBtn" data-tool="pan" title="Pan (H)  •  Espaço também funciona">
          <svg viewBox="0 0 24 24" fill="none"><path d="M12 3v18M3 12h18" stroke="currentColor" stroke-width="2" stroke-linecap="round"/><path d="M7 7l-4 5 4 5M17 7l4 5-4 5" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
        </div>
        <div class="toolBtn" data-tool="measure" title="Régua (M)">
          <svg viewBox="0 0 24 24" fill="none"><path d="M4 20 20 4" stroke="currentColor" stroke-width="2" stroke-linecap="round"/><path d="M7 17l-1-1m4-4-1-1m4-4-1-1m4-4-1-1" stroke="currentColor" stroke-width="2" stroke-linecap="round"/></svg>
        </div>
        <div class="toolBtn" data-tool="fog_reveal" title="Fog: Revelar (E)">
          <svg viewBox="0 0 24 24" fill="none"><path d="M2 12s4-7 10-7 10 7 10 7-4 7-10 7S2 12 2 12Z" stroke="currentColor" stroke-width="2"/><path d="M12 15a3 3 0 1 0 0-6 3 3 0 0 0 0 6Z" stroke="currentColor" stroke-width="2"/></svg>
        </div>
        <div class="toolBtn" data-tool="fog_cover" title="Fog: Cobrir (C)">
          <svg viewBox="0 0 24 24" fill="none"><path d="M3 12s4-7 9-7 9 7 9 7-4 7-9 7-9-7-9-7Z" stroke="currentColor" stroke-width="2"/><path d="M4 4l16 16" stroke="currentColor" stroke-width="2" stroke-linecap="round"/></svg>
        </div>
        <div class="toolBtn" data-tool="fit" title="Enquadrar (Z)">
          <svg viewBox="0 0 24 24" fill="none"><path d="M7 3H3v4M17 3h4v4M7 21H3v-4M17 21h4v-4" stroke="currentColor" stroke-width="2" stroke-linecap="round"/><path d="M8 8h8v8H8V8Z" stroke="currentColor" stroke-width="2"/></svg>
        </div>
      </div>
    </main>
  </div>

  <!-- Help Modal -->
  <div class="modal" id="helpModal">
    <div class="modalCard">
      <div class="modalTop">
        <div class="h">Guia rápido (Mesa Atelier)</div>
        <button id="btnCloseHelp" class="ghost">Fechar</button>
      </div>

      <div class="modalGrid">
        <div class="callout">
          <h4>1) Fluxo básico</h4>
          <p>Carregue um mapa, adicione tokens à biblioteca e dê spawn. Use o Fog para controlar visão. Export para salvar sessão.</p>
          <ul>
            <li><b>Mapa</b> → Carregar → Enquadrar</li>
            <li><b>Tokens</b> → Adicionar imagens → clique na miniatura (spawn)</li>
            <li><b>Ferramentas</b> → Fog revelar/cobrir → pinte no mapa</li>
          </ul>
        </div>

        <div class="callout">
          <h4>Atalhos que importam</h4>
          <ul>
            <li><span class="kbd">Espaço</span> + arrastar: pan</li>
            <li>Roda do mouse: zoom</li>
            <li><span class="kbd">M</span>: régua</li>
            <li><span class="kbd">G</span>: liga/desliga grid</li>
            <li><span class="kbd">F</span>: liga/desliga fog</li>
            <li><span class="kbd">Shift</span>: ignora snap (move livre)</li>
            <li><span class="kbd">Del</span>: apaga token selecionado</li>
          </ul>
        </div>

        <div class="callout">
          <h4>Ferramentas (toolbar)</h4>
          <p>Use a barra no rodapé. Ela evita “modo escondido”.</p>
          <ul>
            <li><b>Selecionar</b>: mover/selecionar token</li>
            <li><b>Pan</b>: arrastar mesa (sem precisar segurar espaço)</li>
            <li><b>Régua</b>: clique e arraste para medir</li>
            <li><b>Fog</b>: revelar/cobrir pintando</li>
          </ul>
        </div>

        <div class="callout">
          <h4>Salvar do jeito certo</h4>
          <p><b>Exportar</b> gera um JSON completo. <b>Salvar local</b> é conveniente, mas pode falhar se ficar grande.</p>
          <ul>
            <li>Para sessões longas, use <b>Export</b>.</li>
            <li>Para teste rápido, <b>Salvar local</b>.</li>
          </ul>
        </div>
      </div>

      <div class="divider"></div>
      <div class="hint">
        Se algo der errado, provavelmente foi o universo te lembrando que tudo é frágil e temporário. Ou você esqueceu de apertar “Aplicar grid”. Difícil saber.
      </div>
    </div>
  </div>

<script>
(() => {
  const $ = (q, root=document) => root.querySelector(q);
  const $$ = (q, root=document) => Array.from(root.querySelectorAll(q));

  // ---------- State ----------
  const DEFAULT_MAP = { w: 1600, h: 900, src: "" };
  const state = {
    version: 2,
    project: "Mesa Atelier",
    tool: "select", // select | pan | measure | fog_reveal | fog_cover
    view: { panX: 60, panY: 60, scale: 1 },
    map: { ...DEFAULT_MAP },
    grid: { size: 64, show: true, snap: true, color: "rgba(255,255,255,0.12)" },
    fog: { enabled: true, opacity: 0.92, brush: 44 },
    tokens: [],
    tokenLibrary: [], // {id,name,src}
    selectedTokenId: null,
    notes: "",
    rolls: [],
    initiative: { list: [], turnIndex: 0 },
    measure: { dragging: false, a: null, b: null },
    input: { spaceDown:false, isPanning:false, panStart:null, tokenDrag:null, fogPainting:false, fogLast:null }
  };

  // ---------- Elements ----------
  const stage = $("#stage");
  const board = $("#board");
  const mapImg = $("#mapImg");
  const gridCanvas = $("#gridCanvas");
  const fogCanvas = $("#fogCanvas");
  const overlay = $("#overlay");
  const tokenLayer = $("#tokenLayer");
  const toastWrap = $("#toastWrap");

  // HUD
  const hudZoom = $("#hudZoom");
  const hudGrid = $("#hudGrid");
  const hudTokens = $("#hudTokens");
  const hudMode = $("#hudMode");

  // Chips
  const chipMap = $("#chipMap");
  const chipTokens = $("#chipTokens");
  const chipSel = $("#chipSel");
  const chipTool = $("#chipTool");
  const chipIni = $("#chipIni");

  // Sections collapse
  $$("[data-toggle]").forEach(h => {
    h.addEventListener("click", () => {
      const sec = h.closest(".section");
      sec.classList.toggle("closed");
    });
  });

  // Sidebar actions
  const btnHelp = $("#btnHelp");
  const helpModal = $("#helpModal");
  const btnCloseHelp = $("#btnCloseHelp");
  const btnExportTop = $("#btnExportTop");
  const btnSaveTop = $("#btnSaveTop");

  // Map controls
  const mapFile = $("#mapFile");
  const btnLoadMap = $("#btnLoadMap");
  const btnClearMap = $("#btnClearMap");
  const mapW = $("#mapW");
  const mapH = $("#mapH");
  const btnApplyMapSize = $("#btnApplyMapSize");
  const btnFit = $("#btnFit");

  // Token library + spawn
  const tokenFile = $("#tokenFile");
  const btnAddTokenImgs = $("#btnAddTokenImgs");
  const libraryGrid = $("#libraryGrid");
  const newTokenName = $("#newTokenName");
  const newTokenSize = $("#newTokenSize");
  const newTokenColor = $("#newTokenColor");
  const newTokenShape = $("#newTokenShape");
  const btnSpawnColor = $("#btnSpawnColor");
  const btnSpawnFromLibrary = $("#btnSpawnFromLibrary");
  const tokenSearch = $("#tokenSearch");
  const tableTokens = $("#tableTokens");

  // Inspector
  const noSelection = $("#noSelection");
  const tokenEditor = $("#tokenEditor");
  const selPreview = $("#selPreview");
  const selTitle = $("#selTitle");
  const selId = $("#selId");
  const tokName = $("#tokName");
  const tokX = $("#tokX");
  const tokY = $("#tokY");
  const tokSize = $("#tokSize");
  const tokRot = $("#tokRot");
  const tokShape = $("#tokShape");
  const tokColor = $("#tokColor");
  const btnCenterOnToken = $("#btnCenterOnToken");
  const btnDeleteToken = $("#btnDeleteToken");

  // Tools (grid/fog)
  const tgGrid = $("#tgGrid");
  const tgSnap = $("#tgSnap");
  const gridSize = $("#gridSize");
  const gridColor = $("#gridColor");
  const btnApplyGrid = $("#btnApplyGrid");

  const tgFog = $("#tgFog");
  const fogOpacity = $("#fogOpacity");
  const fogBrush = $("#fogBrush");
  const btnFillFog = $("#btnFillFog");
  const btnClearFog = $("#btnClearFog");

  // Dice
  const diceExpr = $("#diceExpr");
  const btnRoll = $("#btnRoll");
  const btnClearRolls = $("#btnClearRolls");
  const rolls = $("#rolls");

  // Initiative
  const iniName = $("#iniName");
  const iniVal = $("#iniVal");
  const btnAddIni = $("#btnAddIni");
  const btnSortIni = $("#btnSortIni");
  const btnNextTurn = $("#btnNextTurn");
  const btnClearIni = $("#btnClearIni");
  const iniList = $("#iniList");

  // Notes
  const notes = $("#notes");
  const btnSaveNotes = $("#btnSaveNotes");
  const btnClearNotes = $("#btnClearNotes");

  // Save
  const importFile = $("#importFile");
  const btnImport = $("#btnImport");
  const btnExport = $("#btnExport");
  const btnSaveLocal = $("#btnSaveLocal");
  const btnLoadLocal = $("#btnLoadLocal");
  const btnResetAll = $("#btnResetAll");

  // Toolbar
  const toolBar = $("#toolBar");
  const toolBtns = $$(".toolBtn", toolBar);

  // ---------- Helpers ----------
  const uid = () => Math.random().toString(36).slice(2,10) + "-" + Date.now().toString(36);
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const escapeHtml = (s) => String(s).replace(/[&<>"']/g, (m) => ({
    "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"
  }[m]));

  function toast(msg, sub=""){
    const el = document.createElement("div");
    el.className = "toast";
    el.innerHTML = `<div>${escapeHtml(msg)}</div>${sub?`<div class="small">${escapeHtml(sub)}</div>`:""}`;
    toastWrap.appendChild(el);
    setTimeout(() => { el.style.opacity = "0"; el.style.transform = "translateY(-4px)"; }, 2200);
    setTimeout(() => el.remove(), 2600);
  }

  function stageRect(){ return stage.getBoundingClientRect(); }

  function applyBoardTransform(){
    const { panX, panY, scale } = state.view;
    board.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
    setHUD();
    drawOverlay();
  }

  function screenToBoard(clientX, clientY){
    const r = stageRect();
    return {
      x: (clientX - r.left - state.view.panX) / state.view.scale,
      y: (clientY - r.top  - state.view.panY) / state.view.scale
    };
  }
  function boardToScreen(x, y){
    const r = stageRect();
    return {
      x: r.left + state.view.panX + x * state.view.scale,
      y: r.top  + state.view.panY + y * state.view.scale
    };
  }

  function snap(v, s){ return Math.round(v / s) * s; }

  function setHUD(){
    hudZoom.textContent = Math.round(state.view.scale*100) + "%";
    hudGrid.textContent = state.grid.size + "px";
    hudTokens.textContent = String(state.tokens.length);

    const toolName = ({
      select:"selecionar",
      pan:"pan",
      measure:"régua",
      fog_reveal:"fog: revelar",
      fog_cover:"fog: cobrir"
    }[state.tool] || state.tool);

    hudMode.textContent = toolName;

    chipTool.textContent = toolName;
    chipTokens.textContent = `${state.tokens.length} na mesa`;
    chipMap.textContent = state.map.src ? `${state.map.w}×${state.map.h}` : "sem mapa";
    chipIni.textContent = state.initiative.list.length ? `${state.initiative.list.length} itens` : "vazia";

    tgGrid.classList.toggle("on", state.grid.show);
    tgSnap.classList.toggle("on", state.grid.snap);
    tgFog.classList.toggle("on", state.fog.enabled);
  }

  function ensureCanvasSizes(){
    const w = state.map.w, h = state.map.h;

    board.style.width = w + "px";
    board.style.height = h + "px";

    $("#mapLayer").style.width = w + "px";
    $("#mapLayer").style.height = h + "px";
    $("#gridLayer").style.width = w + "px";
    $("#gridLayer").style.height = h + "px";
    $("#tokenLayer").style.width = w + "px";
    $("#tokenLayer").style.height = h + "px";
    $("#fogLayer").style.width = w + "px";
    $("#fogLayer").style.height = h + "px";

    mapImg.style.width = w + "px";
    mapImg.style.height = h + "px";

    // DPR-aware canvas sizes
    const dpr = Math.max(1, Math.floor(window.devicePixelRatio || 1));

    gridCanvas.width = w * dpr;
    gridCanvas.height = h * dpr;
    gridCanvas.style.width = w + "px";
    gridCanvas.style.height = h + "px";

    fogCanvas.width = w * dpr;
    fogCanvas.height = h * dpr;
    fogCanvas.style.width = w + "px";
    fogCanvas.style.height = h + "px";

    resizeOverlay();
    drawGrid();
    applyFogVisual();
  }

  function resizeOverlay(){
    const r = stageRect();
    const dpr = Math.max(1, Math.floor(window.devicePixelRatio || 1));
    overlay.width = Math.max(1, Math.floor(r.width * dpr));
    overlay.height = Math.max(1, Math.floor(r.height * dpr));
    overlay.style.width = r.width + "px";
    overlay.style.height = r.height + "px";
    drawOverlay();
  }

  window.addEventListener("resize", () => {
    resizeOverlay();
    requestAnimationFrame(() => fit(true, false));
  });

  // ---------- Grid ----------
  function drawGrid(){
    const ctx = gridCanvas.getContext("2d");
    const dpr = Math.max(1, Math.floor(window.devicePixelRatio || 1));
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    ctx.clearRect(0,0,state.map.w,state.map.h);

    if(!state.grid.show) return;

    const s = state.grid.size;
    ctx.strokeStyle = state.grid.color;
    ctx.lineWidth = 1;

    ctx.save();
    ctx.translate(0.5, 0.5);

    for(let x = 0; x <= state.map.w; x += s){
      ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, state.map.h); ctx.stroke();
    }
    for(let y = 0; y <= state.map.h; y += s){
      ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(state.map.w, y); ctx.stroke();
    }

    // heavier every 5
    ctx.strokeStyle = "rgba(255,255,255,0.18)";
    for(let x = 0; x <= state.map.w; x += s*5){
      ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, state.map.h); ctx.stroke();
    }
    for(let y = 0; y <= state.map.h; y += s*5){
      ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(state.map.w, y); ctx.stroke();
    }

    ctx.restore();
  }

  // ---------- Fog ----------
  function applyFogVisual(){
    fogCanvas.style.opacity = String(state.fog.enabled ? state.fog.opacity : 0);
  }
  function fogCtx(){
    const ctx = fogCanvas.getContext("2d");
    const dpr = Math.max(1, Math.floor(window.devicePixelRatio || 1));
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    return ctx;
  }
  function fillFog(){
    const ctx = fogCtx();
    ctx.save();
    ctx.globalCompositeOperation = "source-over";
    ctx.fillStyle = "rgba(0,0,0,1)";
    ctx.fillRect(0,0,state.map.w,state.map.h);
    ctx.restore();
  }
  function clearFog(){
    const ctx = fogCtx();
    ctx.clearRect(0,0,state.map.w,state.map.h);
  }
  function paintFogLine(a, b, mode){
    const ctx = fogCtx();
    ctx.save();

    ctx.lineCap = "round";
    ctx.lineJoin = "round";
    ctx.lineWidth = state.fog.brush;

    if(mode === "reveal"){
      ctx.globalCompositeOperation = "destination-out";
      ctx.strokeStyle = "rgba(0,0,0,1)";
    } else {
      ctx.globalCompositeOperation = "source-over";
      ctx.strokeStyle = "rgba(0,0,0,1)";
    }

    ctx.beginPath();
    ctx.moveTo(a.x, a.y);
    ctx.lineTo(b.x, b.y);
    ctx.stroke();
    ctx.restore();
  }
  function loadFogFromDataURL(dataURL){
    if(!dataURL){
      fillFog(); return;
    }
    const img = new Image();
    img.onload = () => {
      const ctx = fogCtx();
      ctx.clearRect(0,0,state.map.w,state.map.h);
      ctx.drawImage(img, 0, 0, state.map.w, state.map.h);
    };
    img.src = dataURL;
  }

  // ---------- Tokens ----------
  function tokenById(id){ return state.tokens.find(t => t.id === id) || null; }

  function renderToken(token){
    let el = tokenLayer.querySelector(`[data-token-id="${token.id}"]`);
    if(!el){
      el = document.createElement("div");
      el.className = "token";
      el.dataset.tokenId = token.id;
      el.innerHTML = `<img draggable="false" alt="" style="display:none" /><div class="label"></div>`;
      tokenLayer.appendChild(el);

      el.addEventListener("pointerdown", (e) => {
        if(e.button !== 0) return;
        if(state.tool !== "select") return;
        selectToken(token.id);
        beginTokenDrag(e, token.id);
      });

      el.addEventListener("contextmenu", (e) => e.preventDefault());
    }

    const img = el.querySelector("img");
    const label = el.querySelector(".label");

    label.textContent = token.name || "token";
    label.style.display = (token.name && token.name.trim()) ? "block" : "none";

    el.style.left = (token.x - token.size/2) + "px";
    el.style.top  = (token.y - token.size/2) + "px";
    el.style.width = token.size + "px";
    el.style.height = token.size + "px";
    el.style.transform = `rotate(${token.rot}deg)`;
    el.style.borderRadius = token.shape === "square" ? "16px" : "999px";

    if(token.src){
      img.src = token.src;
      img.style.display = "block";
      el.style.background = "rgba(0,0,0,.15)";
    } else {
      img.style.display = "none";
      el.style.background = token.color || "rgba(106,92,255,.35)";
    }

    el.classList.toggle("selected", state.selectedTokenId === token.id);
  }

  function renderAllTokens(){
    const ids = new Set(state.tokens.map(t => t.id));
    $$(".token", tokenLayer).forEach(el => { if(!ids.has(el.dataset.tokenId)) el.remove(); });
    state.tokens.forEach(renderToken);
    refreshTokenLists();
    refreshTokenEditor(true);
    setHUD();
  }

  function selectToken(id){
    state.selectedTokenId = id;
    renderAllTokens();
  }

  function deselectToken(){
    state.selectedTokenId = null;
    renderAllTokens();
  }

  function createToken({name, size, x, y, rot=0, src="", color="rgba(106,92,255,.35)", shape="circle"}){
    const t = { id: uid(), name, size, x, y, rot, src, color, shape };
    state.tokens.push(t);
    selectToken(t.id);
    toast("Token criado", `${t.name || "token"} · ${Math.round(t.x)},${Math.round(t.y)}`);
  }

  // Dragging token
  function beginTokenDrag(e, tokenId){
    const t = tokenById(tokenId);
    if(!t) return;

    const p = screenToBoard(e.clientX, e.clientY);
    state.input.tokenDrag = {
      id: tokenId,
      start: { x: p.x, y: p.y },
      orig: { x: t.x, y: t.y },
      pointerId: e.pointerId
    };

    const el = tokenLayer.querySelector(`[data-token-id="${tokenId}"]`);
    if(el) el.setPointerCapture(e.pointerId);
  }

  function moveTokenDrag(e){
    const drag = state.input.tokenDrag;
    if(!drag) return;
    const t = tokenById(drag.id);
    if(!t) return;

    const p = screenToBoard(e.clientX, e.clientY);
    const dx = p.x - drag.start.x;
    const dy = p.y - drag.start.y;

    let nx = drag.orig.x + dx;
    let ny = drag.orig.y + dy;

    const snapEnabled = state.grid.snap && !e.shiftKey;
    if(snapEnabled){
      const s = state.grid.size;
      nx = snap(nx, s);
      ny = snap(ny, s);
    }

    t.x = clamp(nx, 0, state.map.w);
    t.y = clamp(ny, 0, state.map.h);

    renderToken(t);
    refreshTokenEditor(false);
  }

  function endTokenDrag(){
    if(!state.input.tokenDrag) return;
    state.input.tokenDrag = null;
    refreshTokenLists();
  }

  // ---------- Overlay: ruler + cursor preview ----------
  function roundRect(ctx,x,y,w,h,r){
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr, y);
    ctx.arcTo(x+w, y, x+w, y+h, rr);
    ctx.arcTo(x+w, y+h, x, y+h, rr);
    ctx.arcTo(x, y+h, x, y, rr);
    ctx.arcTo(x, y, x+w, y, rr);
    ctx.closePath();
  }

  function drawOverlay(cursor=null){
    const ctx = overlay.getContext("2d");
    const r = stageRect();
    const dpr = Math.max(1, Math.floor(window.devicePixelRatio || 1));
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    ctx.clearRect(0,0,r.width,r.height);

    // Cursor preview for fog tool
    if(cursor && (state.tool === "fog_reveal" || state.tool === "fog_cover")){
      const p = cursor;
      const rad = state.fog.brush/2;
      ctx.save();
      ctx.strokeStyle = state.tool === "fog_reveal" ? "rgba(56,217,150,0.85)" : "rgba(255,204,102,0.85)";
      ctx.lineWidth = 2;
      ctx.setLineDash([6,4]);
      ctx.beginPath();
      ctx.arc(p.x, p.y, rad * state.view.scale, 0, Math.PI*2);
      ctx.stroke();
      ctx.restore();
    }

    // Ruler
    if(state.tool === "measure" && state.measure.a && state.measure.b){
      const a = state.measure.a;
      const b = state.measure.b;

      const A = boardToScreen(a.x, a.y);
      const B = boardToScreen(b.x, b.y);

      const ax = A.x - r.left, ay = A.y - r.top;
      const bx = B.x - r.left, by = B.y - r.top;

      ctx.save();
      ctx.lineWidth = 2;
      ctx.strokeStyle = "rgba(255,255,255,0.85)";
      ctx.beginPath();
      ctx.moveTo(ax, ay);
      ctx.lineTo(bx, by);
      ctx.stroke();

      ctx.fillStyle = "rgba(106,92,255,0.95)";
      ctx.beginPath();
      ctx.arc(ax, ay, 4, 0, Math.PI*2);
      ctx.arc(bx, by, 4, 0, Math.PI*2);
      ctx.fill();

      const dx = b.x - a.x;
      const dy = b.y - a.y;
      const distPx = Math.hypot(dx, dy);
      const squares = distPx / state.grid.size;

      const midx = (ax+bx)/2, midy = (ay+by)/2;
      const text = `${squares.toFixed(2)}q (${Math.round(distPx)}px)`;

      ctx.font = `12px ${getComputedStyle(document.documentElement).getPropertyValue("--mono").trim() || "monospace"}`;
      const pad = 6;
      const m = ctx.measureText(text);
      const w = m.width + pad*2;
      const h = 22;

      ctx.fillStyle = "rgba(0,0,0,0.65)";
      ctx.strokeStyle = "rgba(255,255,255,0.35)";
      ctx.lineWidth = 1;

      roundRect(ctx, midx - w/2, midy - h/2, w, h, 10);
      ctx.fill();
      ctx.stroke();

      ctx.fillStyle = "rgba(255,255,255,0.92)";
      ctx.fillText(text, midx - m.width/2, midy + 4);
      ctx.restore();
    }
  }

  // ---------- Map ----------
  function setMapSrc(src){
    state.map.src = src || "";
    mapImg.src = src || "";
  }
  function setMapSize(w, h){
    state.map.w = Math.max(200, Math.floor(w));
    state.map.h = Math.max(200, Math.floor(h));
    mapW.value = state.map.w;
    mapH.value = state.map.h;
    ensureCanvasSizes();
    renderAllTokens();
    setHUD();
  }

  async function fileToDataURL(file){
    return new Promise((resolve, reject) => {
      const fr = new FileReader();
      fr.onload = () => resolve(fr.result);
      fr.onerror = reject;
      fr.readAsDataURL(file);
    });
  }

  async function loadMapFromFile(){
    const f = mapFile.files && mapFile.files[0];
    if(!f) return;

    const dataURL = await fileToDataURL(f);
    const img = new Image();
    img.onload = () => {
      setMapSrc(dataURL);
      setMapSize(img.naturalWidth || state.map.w, img.naturalHeight || state.map.h);
      fillFog();
      fit(true, true);
      toast("Mapa carregado", `${state.map.w}×${state.map.h}`);
    };
    img.src = dataURL;
  }

  function resetMap(){
    setMapSrc("");
    setMapSize(DEFAULT_MAP.w, DEFAULT_MAP.h);
    fillFog();
    fit(true, true);
    toast("Mapa removido", "Voltando ao canvas padrão");
  }

  // Fit view
  function fit(force=true, center=true){
    const r = stageRect();
    const pad = 92;
    const availableW = r.width - pad*2;
    const availableH = r.height - pad*2;
    if(availableW <= 0 || availableH <= 0) return;

    if(force){
      const scale = clamp(Math.min(availableW / state.map.w, availableH / state.map.h), 0.15, 2.8);
      state.view.scale = scale;
      if(center){
        state.view.panX = (r.width - state.map.w*scale)/2;
        state.view.panY = (r.height - state.map.h*scale)/2;
      }
      applyBoardTransform();
    }
  }

  function resetView(){
    state.view.scale = 1;
    state.view.panX = 60;
    state.view.panY = 60;
    applyBoardTransform();
  }

  // ---------- Library ----------
  function renderLibrary(){
    libraryGrid.innerHTML = "";
    if(!state.tokenLibrary.length){
      libraryGrid.innerHTML = `<div class="hint" style="grid-column:1/-1">Biblioteca vazia. Adicione imagens ou crie token simples.</div>`;
      return;
    }

    for(const it of state.tokenLibrary){
      const el = document.createElement("div");
      el.className = "thumb";
      el.title = "Clique para spawn";
      el.innerHTML = `
        <div class="badge">spawn</div>
        <img alt="" src="${it.src}" />
        <div class="cap">${escapeHtml(it.name)}</div>
      `;
      el.addEventListener("click", () => spawnFromLibraryId(it.id));
      el.addEventListener("contextmenu", (e) => {
        e.preventDefault();
        if(confirm(`Remover "${it.name}" da biblioteca?`)){
          state.tokenLibrary = state.tokenLibrary.filter(x => x.id !== it.id);
          renderLibrary();
          toast("Removido da biblioteca", it.name);
        }
      });
      libraryGrid.appendChild(el);
    }
  }

  function getStageCenterBoard(){
    const r = stageRect();
    const cx = r.left + r.width/2;
    const cy = r.top + r.height/2;
    const p = screenToBoard(cx, cy);
    return { x: clamp(p.x, 0, state.map.w), y: clamp(p.y, 0, state.map.h) };
  }

  function spawnFromLibraryId(id){
    const it = state.tokenLibrary.find(x => x.id === id);
    if(!it) return;
    const name = (newTokenName.value || it.name || "token").trim();
    const size = Number(newTokenSize.value || 64);
    const shape = newTokenShape.value || "circle";
    const center = getStageCenterBoard();
    createToken({ name, size, x:center.x, y:center.y, src: it.src, shape });
  }

  // ---------- Token lists / inspector ----------
  function refreshTokenLists(){
    const q = (tokenSearch.value || "").trim().toLowerCase();
    tableTokens.innerHTML = "";

    const list = state.tokens.filter(t => {
      if(!q) return true;
      return (t.name || "").toLowerCase().includes(q);
    });

    if(!list.length){
      tableTokens.innerHTML = `<div class="hint">Nenhum token encontrado.</div>`;
      return;
    }

    for(const t of list){
      const row = document.createElement("div");
      row.className = "item";
      const isSel = t.id === state.selectedTokenId;

      let mini = `<div class="mini"></div>`;
      if(t.src) mini = `<div class="mini"><img alt="" src="${t.src}"></div>`;

      row.style.borderColor = isSel ? "rgba(106,92,255,.60)" : "var(--line)";
      row.style.background = isSel ? "rgba(106,92,255,.10)" : "rgba(0,0,0,.16)";

      row.innerHTML = `
        <div class="meta">
          ${mini}
          <div style="min-width:0">
            <div class="name">${escapeHtml(t.name || "token")}</div>
            <div class="sub">x:${Math.round(t.x)} y:${Math.round(t.y)} size:${Math.round(t.size)}</div>
          </div>
        </div>
        <div class="actions">
          <button class="tiny" data-act="sel">Selecionar</button>
        </div>
      `;

      row.addEventListener("click", (e) => {
        const b = e.target.closest("button");
        if(b){
          selectToken(t.id);
          return;
        }
        selectToken(t.id);
      });

      tableTokens.appendChild(row);
    }
  }

  function refreshTokenEditor(updateInputs=true){
    const t = tokenById(state.selectedTokenId);
    if(!t){
      chipSel.textContent = "nenhum";
      noSelection.style.display = "";
      tokenEditor.style.display = "none";
      selPreview.innerHTML = "";
      return;
    }

    chipSel.textContent = t.name ? t.name.slice(0,18) : "token";
    noSelection.style.display = "none";
    tokenEditor.style.display = "";

    selTitle.textContent = t.name || "token";
    selId.textContent = t.id;

    // preview
    selPreview.innerHTML = "";
    if(t.src){
      const img = document.createElement("img");
      img.src = t.src;
      img.alt = "";
      selPreview.appendChild(img);
    } else {
      selPreview.style.background = t.color || "rgba(106,92,255,.35)";
      selPreview.textContent = "";
    }

    if(updateInputs){
      tokName.value = t.name || "";
      tokX.value = Math.round(t.x);
      tokY.value = Math.round(t.y);
      tokSize.value = Math.round(t.size);
      tokRot.value = Math.round(t.rot);
      tokShape.value = t.shape || "circle";
      tokColor.value = t.color || "rgba(106,92,255,.35)";
    }
  }

  function centerViewOn(x,y){
    const r = stageRect();
    const s = state.view.scale;
    state.view.panX = r.width/2 - x*s;
    state.view.panY = r.height/2 - y*s;
    applyBoardTransform();
  }

  // ---------- Dice ----------
  function parseDice(expr){
    const cleaned = expr.replace(/\s+/g,"").toLowerCase();
    if(!cleaned) throw new Error("Expressão vazia.");

    const tokens = cleaned.match(/[+-]?[^+-]+/g);
    if(!tokens) throw new Error("Expressão inválida.");

    const parts = [];
    let total = 0;

    for(const tk of tokens){
      const sign = tk.startsWith("-") ? -1 : 1;
      const body = tk.replace(/^[-+]/,"");
      if(!body) continue;

      if(body.includes("d")){
        const [a,b] = body.split("d");
        const n = a === "" ? 1 : Number(a);
        const m = Number(b);
        if(!Number.isFinite(n) || !Number.isFinite(m) || n<=0 || m<=0) throw new Error("Dados inválidos.");

        const rolls = [];
        let sum = 0;
        for(let i=0;i<n;i++){
          const r = 1 + Math.floor(Math.random()*m);
          rolls.push(r);
          sum += r;
        }
        total += sign * sum;
        parts.push({ raw: tk, rolls, value: sign*sum });
      } else {
        const v = Number(body);
        if(!Number.isFinite(v)) throw new Error("Número inválido.");
        total += sign * v;
        parts.push({ raw: tk, rolls: [], value: sign*v });
      }
    }
    return { total, parts };
  }

  function renderRolls(){
    rolls.innerHTML = "";
    if(!state.rolls.length){
      rolls.innerHTML = `<div class="hint">Sem rolagens ainda. Aproveite a paz.</div>`;
      return;
    }
    for(const r of state.rolls.slice().reverse()){
      const row = document.createElement("div");
      row.className = "item";
      const detail = r.parts.map(p => p.rolls.length ? `${p.raw}=[${p.rolls.join(",")}]` : `${p.raw}`).join(" ");
      row.innerHTML = `
        <div class="meta" style="gap:0">
          <div style="min-width:0">
            <div class="name">${escapeHtml(r.expr)} → <span style="color:var(--accent2)">${escapeHtml(String(r.total))}</span></div>
            <div class="sub">${escapeHtml(detail)}</div>
          </div>
        </div>
        <div class="actions">
          <button class="tiny" data-act="copy">Copiar</button>
        </div>
      `;
      row.addEventListener("click", (e) => {
        const b = e.target.closest("button");
        if(!b) return;
        navigator.clipboard?.writeText(`${r.expr} = ${r.total}`);
        toast("Copiado", `${r.expr} = ${r.total}`);
      });
      rolls.appendChild(row);
    }
  }

  // ---------- Initiative ----------
  function renderInitiative(){
    iniList.innerHTML = "";
    if(!state.initiative.list.length){
      iniList.innerHTML = `<div class="hint">Lista vazia.</div>`;
      setHUD();
      return;
    }
    state.initiative.list.forEach((it, idx) => {
      const row = document.createElement("div");
      row.className = "item";
      const isTurn = idx === state.initiative.turnIndex;
      row.style.borderColor = isTurn ? "rgba(56,217,150,.55)" : "var(--line)";
      row.style.background = isTurn ? "rgba(56,217,150,.10)" : "rgba(0,0,0,.16)";
      row.innerHTML = `
        <div class="meta" style="gap:0">
          <div style="min-width:0">
            <div class="name">${escapeHtml(it.name)} ${isTurn ? "· (turno)" : ""}</div>
            <div class="sub">ini: ${it.val}</div>
          </div>
        </div>
        <div class="actions">
          <button class="tiny" data-act="up">▲</button>
          <button class="tiny" data-act="down">▼</button>
          <button class="tiny danger" data-act="del">Rem</button>
        </div>
      `;
      row.addEventListener("click", (e) => {
        const b = e.target.closest("button");
        if(!b) return;
        const act = b.dataset.act;
        if(act === "del"){
          state.initiative.list.splice(idx,1);
          if(state.initiative.turnIndex >= state.initiative.list.length) state.initiative.turnIndex = 0;
        } else if(act === "up" && idx>0){
          [state.initiative.list[idx-1], state.initiative.list[idx]] = [state.initiative.list[idx], state.initiative.list[idx-1]];
          if(state.initiative.turnIndex === idx) state.initiative.turnIndex = idx-1;
          else if(state.initiative.turnIndex === idx-1) state.initiative.turnIndex = idx;
        } else if(act === "down" && idx<state.initiative.list.length-1){
          [state.initiative.list[idx+1], state.initiative.list[idx]] = [state.initiative.list[idx], state.initiative.list[idx+1]];
          if(state.initiative.turnIndex === idx) state.initiative.turnIndex = idx+1;
          else if(state.initiative.turnIndex === idx+1) state.initiative.turnIndex = idx;
        }
        renderInitiative();
      });
      iniList.appendChild(row);
    });
    setHUD();
  }

  // ---------- Save/Load ----------
  function safeToDataURL(canvas){
    try{ return canvas.toDataURL("image/png"); } catch { return null; }
  }
  function exportScene(){
    const data = JSON.parse(JSON.stringify({
      version: state.version,
      project: state.project,
      map: state.map,
      grid: state.grid,
      fog: state.fog,
      fogData: safeToDataURL(fogCanvas),
      tokens: state.tokens,
      tokenLibrary: state.tokenLibrary,
      notes: notes.value ?? state.notes,
      rolls: state.rolls,
      initiative: state.initiative,
      view: state.view
    }));

    const blob = new Blob([JSON.stringify(data, null, 2)], { type: "application/json" });
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = `mesa-atelier-scene-${new Date().toISOString().slice(0,10)}.json`;
    a.click();
    URL.revokeObjectURL(a.href);
    toast("Export feito", "JSON baixado");
  }

  async function importSceneFromFile(){
    const f = importFile.files && importFile.files[0];
    if(!f) return;
    const txt = await f.text();
    const data = JSON.parse(txt);

    // map
    if(data.map){
      setMapSrc(data.map.src || "");
      setMapSize(Number(data.map.w||DEFAULT_MAP.w), Number(data.map.h||DEFAULT_MAP.h));
    } else {
      setMapSrc("");
      setMapSize(DEFAULT_MAP.w, DEFAULT_MAP.h);
    }

    // grid
    if(data.grid){
      state.grid.size = clamp(Number(data.grid.size||64), 10, 500);
      state.grid.show = !!data.grid.show;
      state.grid.snap = !!data.grid.snap;
      state.grid.color = data.grid.color || "rgba(255,255,255,0.12)";
    }

    // fog
    if(data.fog){
      state.fog.enabled = !!data.fog.enabled;
      state.fog.opacity = clamp(Number(data.fog.opacity ?? 0.92), 0, 1);
      state.fog.brush = clamp(Number(data.fog.brush ?? 44), 6, 200);
    }

    // content
    state.tokens = Array.isArray(data.tokens) ? data.tokens : [];
    state.tokenLibrary = Array.isArray(data.tokenLibrary) ? data.tokenLibrary : [];
    state.notes = data.notes || "";
    state.rolls = Array.isArray(data.rolls) ? data.rolls : [];
    state.initiative = data.initiative && typeof data.initiative === "object" ? data.initiative : { list: [], turnIndex: 0 };
    state.view = data.view && typeof data.view === "object" ? data.view : state.view;

    // UI sync
    mapW.value = state.map.w;
    mapH.value = state.map.h;

    gridSize.value = state.grid.size;
    gridColor.value = state.grid.color;

    fogOpacity.value = Math.round(state.fog.opacity * 100);
    fogBrush.value = state.fog.brush;

    tgGrid.classList.toggle("on", state.grid.show);
    tgSnap.classList.toggle("on", state.grid.snap);
    tgFog.classList.toggle("on", state.fog.enabled);

    notes.value = state.notes;

    ensureCanvasSizes();
    drawGrid();
    applyFogVisual();
    renderLibrary();
    renderAllTokens();
    renderRolls();
    renderInitiative();
    loadFogFromDataURL(data.fogData);
    applyBoardTransform();
    fit(false, false);

    importFile.value = "";
    toast("Cena importada", "Tudo recarregado");
  }

  // ---------- Tool switching ----------
  function setTool(tool){
    if(tool === "fit"){
      fit(true, true);
      toast("Enquadrado", "Mapa centralizado");
      return;
    }
    state.tool = tool;
    toolBtns.forEach(b => b.classList.toggle("active", b.dataset.tool === tool));
    setHUD();
  }

  toolBar.addEventListener("click", (e) => {
    const btn = e.target.closest(".toolBtn");
    if(!btn) return;
    setTool(btn.dataset.tool);
  });

  // ---------- Inputs & bindings ----------
  btnHelp.addEventListener("click", () => helpModal.classList.add("on"));
  btnCloseHelp.addEventListener("click", () => helpModal.classList.remove("on"));
  helpModal.addEventListener("click", (e) => { if(e.target === helpModal) helpModal.classList.remove("on"); });

  btnExportTop.addEventListener("click", exportScene);
  btnSaveTop.addEventListener("click", () => {
    try{
      const data = JSON.parse(JSON.stringify({
        version: state.version,
        project: state.project,
        map: state.map,
        grid: state.grid,
        fog: state.fog,
        fogData: safeToDataURL(fogCanvas),
        tokens: state.tokens,
        tokenLibrary: state.tokenLibrary,
        notes: notes.value ?? state.notes,
        rolls: state.rolls,
        initiative: state.initiative,
        view: state.view
      }));
      localStorage.setItem("mesaAtelier.save", JSON.stringify(data));
      toast("Salvo localmente", "localStorage: mesaAtelier.save");
    } catch {
      alert("Falhou ao salvar localmente (provavelmente ficou grande demais). Use Exportar.");
    }
  });

  // Map
  btnLoadMap.addEventListener("click", () => loadMapFromFile());
  btnClearMap.addEventListener("click", resetMap);
  btnApplyMapSize.addEventListener("click", () => {
    setMapSize(Number(mapW.value || state.map.w), Number(mapH.value || state.map.h));
    fillFog();
    toast("Tamanho aplicado", `${state.map.w}×${state.map.h}`);
  });
  btnFit.addEventListener("click", () => fit(true, true));

  // Library add
  btnAddTokenImgs.addEventListener("click", async () => {
    const files = tokenFile.files ? Array.from(tokenFile.files) : [];
    if(!files.length) return;

    for(const f of files){
      const src = await fileToDataURL(f);
      state.tokenLibrary.push({ id: uid(), name: f.name.replace(/\.[^.]+$/,""), src });
    }
    tokenFile.value = "";
    renderLibrary();
    toast("Biblioteca atualizada", `${state.tokenLibrary.length} itens`);
  });

  btnSpawnFromLibrary.addEventListener("click", () => {
    const it = state.tokenLibrary[0];
    if(!it) return toast("Biblioteca vazia", "Adicione imagens primeiro");
    spawnFromLibraryId(it.id);
  });

  btnSpawnColor.addEventListener("click", () => {
    const name = (newTokenName.value || "token").trim();
    const size = Number(newTokenSize.value || 64);
    const color = (newTokenColor.value || "rgba(106,92,255,.35)").trim();
    const shape = newTokenShape.value || "circle";
    const center = getStageCenterBoard();
    createToken({ name, size, x:center.x, y:center.y, src:"", color, shape });
  });

  tokenSearch.addEventListener("input", refreshTokenLists);

  // Inspector binds
  tokName.addEventListener("input", () => {
    const t = tokenById(state.selectedTokenId); if(!t) return;
    t.name = tokName.value;
    renderAllTokens();
  });
  tokX.addEventListener("input", () => {
    const t = tokenById(state.selectedTokenId); if(!t) return;
    t.x = clamp(Number(tokX.value||t.x), 0, state.map.w);
    renderToken(t);
    refreshTokenLists();
  });
  tokY.addEventListener("input", () => {
    const t = tokenById(state.selectedTokenId); if(!t) return;
    t.y = clamp(Number(tokY.value||t.y), 0, state.map.h);
    renderToken(t);
    refreshTokenLists();
  });
  tokSize.addEventListener("input", () => {
    const t = tokenById(state.selectedTokenId); if(!t) return;
    t.size = clamp(Number(tokSize.value||t.size), 16, 512);
    renderToken(t);
    refreshTokenLists();
  });
  tokRot.addEventListener("input", () => {
    const t = tokenById(state.selectedTokenId); if(!t) return;
    t.rot = Number(tokRot.value||t.rot);
    renderToken(t);
    refreshTokenLists();
  });
  tokShape.addEventListener("change", () => {
    const t = tokenById(state.selectedTokenId); if(!t) return;
    t.shape = tokShape.value;
    renderToken(t);
    refreshTokenLists();
  });
  tokColor.addEventListener("input", () => {
    const t = tokenById(state.selectedTokenId); if(!t) return;
    t.color = tokColor.value;
    renderToken(t);
    refreshTokenLists();
    refreshTokenEditor(false);
  });

  btnCenterOnToken.addEventListener("click", () => {
    const t = tokenById(state.selectedTokenId);
    if(!t) return;
    centerViewOn(t.x, t.y);
    toast("Centralizado", t.name || "token");
  });

  btnDeleteToken.addEventListener("click", () => {
    const id = state.selectedTokenId;
    if(!id) return;
    const t = tokenById(id);
    state.tokens = state.tokens.filter(x => x.id !== id);
    state.selectedTokenId = null;
    renderAllTokens();
    toast("Token deletado", t?.name || "token");
  });

  // Grid toggles
  tgGrid.addEventListener("click", () => {
    state.grid.show = !state.grid.show;
    drawGrid();
    setHUD();
  });
  tgSnap.addEventListener("click", () => {
    state.grid.snap = !state.grid.snap;
    setHUD();
  });
  btnApplyGrid.addEventListener("click", () => {
    state.grid.size = clamp(Number(gridSize.value || 64), 10, 500);
    state.grid.color = (gridColor.value || "rgba(255,255,255,0.12)").trim();
    drawGrid();
    toast("Grid aplicado", `${state.grid.size}px`);
    setHUD();
  });

  // Fog
  tgFog.addEventListener("click", () => {
    state.fog.enabled = !state.fog.enabled;
    applyFogVisual();
    setHUD();
    toast("Fog", state.fog.enabled ? "ligado" : "desligado");
  });
  fogOpacity.addEventListener("input", () => {
    state.fog.opacity = Number(fogOpacity.value)/100;
    applyFogVisual();
  });
  fogBrush.addEventListener("input", () => {
    state.fog.brush = Number(fogBrush.value);
  });
  btnFillFog.addEventListener("click", () => { fillFog(); toast("Fog", "cobriu tudo"); });
  btnClearFog.addEventListener("click", () => { clearFog(); toast("Fog", "revelou tudo"); });

  // Dice
  btnRoll.addEventListener("click", () => {
    try{
      const expr = diceExpr.value.trim();
      const out = parseDice(expr);
      state.rolls.push({ id: uid(), expr, ...out, ts: Date.now() });
      renderRolls();
    } catch(err){
      state.rolls.push({ id: uid(), expr: diceExpr.value.trim() || "(vazio)", total: "erro", parts: [{raw:String(err.message||err), rolls:[], value:0}], ts: Date.now() });
      renderRolls();
    }
  });
  btnClearRolls.addEventListener("click", () => { state.rolls = []; renderRolls(); });

  // Initiative
  btnAddIni.addEventListener("click", () => {
    const name = (iniName.value || "").trim();
    const val = Number(iniVal.value);
    if(!name || !Number.isFinite(val)) return;
    state.initiative.list.push({ id: uid(), name, val });
    iniName.value = ""; iniVal.value = "";
    renderInitiative();
  });
  btnSortIni.addEventListener("click", () => {
    state.initiative.list.sort((a,b) => b.val - a.val);
    state.initiative.turnIndex = 0;
    renderInitiative();
  });
  btnNextTurn.addEventListener("click", () => {
    if(!state.initiative.list.length) return;
    state.initiative.turnIndex = (state.initiative.turnIndex + 1) % state.initiative.list.length;
    renderInitiative();
  });
  btnClearIni.addEventListener("click", () => {
    state.initiative.list = [];
    state.initiative.turnIndex = 0;
    renderInitiative();
  });

  // Notes
  btnSaveNotes.addEventListener("click", () => {
    state.notes = notes.value || "";
    toast("Notas salvas", "Incluídas no export/local");
  });
  btnClearNotes.addEventListener("click", () => {
    state.notes = "";
    notes.value = "";
    toast("Notas limpas", "");
  });

  // Save/Load
  btnExport.addEventListener("click", exportScene);
  btnImport.addEventListener("click", importSceneFromFile);

  btnSaveLocal.addEventListener("click", () => btnSaveTop.click());
  btnLoadLocal.addEventListener("click", () => {
    try{
      const raw = localStorage.getItem("mesaAtelier.save");
      if(!raw) return toast("Nada salvo", "localStorage vazio");
      const data = JSON.parse(raw);

      // map
      if(data.map){
        setMapSrc(data.map.src || "");
        setMapSize(Number(data.map.w||DEFAULT_MAP.w), Number(data.map.h||DEFAULT_MAP.h));
      }

      // grid/fog/content
      if(data.grid) state.grid = { ...state.grid, ...data.grid };
      if(data.fog) state.fog = { ...state.fog, ...data.fog };
      if(data.view) state.view = { ...state.view, ...data.view };

      state.tokens = Array.isArray(data.tokens) ? data.tokens : [];
      state.tokenLibrary = Array.isArray(data.tokenLibrary) ? data.tokenLibrary : [];
      state.notes = data.notes || "";
      state.rolls = Array.isArray(data.rolls) ? data.rolls : [];
      state.initiative = data.initiative || { list: [], turnIndex: 0 };

      // UI sync
      mapW.value = state.map.w; mapH.value = state.map.h;
      gridSize.value = state.grid.size;
      gridColor.value = state.grid.color;
      fogOpacity.value = Math.round(state.fog.opacity * 100);
      fogBrush.value = state.fog.brush;
      notes.value = state.notes;

      ensureCanvasSizes();
      drawGrid();
      applyFogVisual();
      renderLibrary();
      renderAllTokens();
      renderRolls();
      renderInitiative();
      loadFogFromDataURL(data.fogData);

      applyBoardTransform();
      toast("Carregado localmente", "mesaAtelier.save");
    } catch(err){
      alert("Falhou ao carregar do localStorage. Talvez o save esteja corrompido.");
    }
  });

  btnResetAll.addEventListener("click", () => {
    if(!confirm("Resetar tudo? Isso apaga mapa/tokens/fog/notas da sessão atual.")) return;

    state.tool = "select";
    state.view = { panX: 60, panY: 60, scale: 1 };
    state.map = { ...DEFAULT_MAP };
    state.grid = { size: 64, show: true, snap: true, color: "rgba(255,255,255,0.12)" };
    state.fog = { enabled: true, opacity: 0.92, brush: 44 };
    state.tokens = [];
    state.tokenLibrary = [];
    state.selectedTokenId = null;
    state.notes = "";
    state.rolls = [];
    state.initiative = { list: [], turnIndex: 0 };
    state.measure = { dragging:false, a:null, b:null };
    state.input = { spaceDown:false, isPanning:false, panStart:null, tokenDrag:null, fogPainting:false, fogLast:null };

    mapW.value = state.map.w; mapH.value = state.map.h;
    gridSize.value = state.grid.size;
    gridColor.value = state.grid.color;
    fogOpacity.value = 92;
    fogBrush.value = 44;
    notes.value = "";
    diceExpr.value = "";
    tokenSearch.value = "";

    toolBtns.forEach(b => b.classList.toggle("active", b.dataset.tool === "select"));

    setMapSrc("");
    setMapSize(DEFAULT_MAP.w, DEFAULT_MAP.h);
    fillFog();
    applyFogVisual();
    renderLibrary();
    renderAllTokens();
    renderRolls();
    renderInitiative();
    resetView();
    setHUD();

    toast("Reset feito", "Estado limpo");
  });

  // ---------- Stage interactions: pan/zoom/measure/fog/select ----------
  stage.addEventListener("contextmenu", (e) => e.preventDefault());

  // pointer move cursor preview
  stage.addEventListener("pointermove", (e) => {
    // token drag
    if(state.input.tokenDrag) moveTokenDrag(e);

    // measure drag
    if(state.tool === "measure" && state.measure.dragging){
      const p = screenToBoard(e.clientX, e.clientY);
      state.measure.b = e.shiftKey ? { x: snap(p.x, state.grid.size), y: snap(p.y, state.grid.size) } : p;
      drawOverlay();
      return;
    }

    // fog paint
    if(state.input.fogPainting){
      const p = screenToBoard(e.clientX, e.clientY);
      if(state.input.fogLast){
        const mode = state.tool === "fog_reveal" ? "reveal" : "cover";
        paintFogLine(state.input.fogLast, p, mode);
      }
      state.input.fogLast = p;
      return;
    }

    // panning
    if(state.input.isPanning && state.input.panStart && state.input.panStart.pointerId === e.pointerId){
      const dx = e.clientX - state.input.panStart.x;
      const dy = e.clientY - state.input.panStart.y;
      state.view.panX = state.input.panStart.panX + dx;
      state.view.panY = state.input.panStart.panY + dy;
      applyBoardTransform();
      return;
    }

    // cursor preview for fog tool
    const r = stageRect();
    drawOverlay({ x: e.clientX - r.left, y: e.clientY - r.top });
  });

  stage.addEventListener("pointerdown", (e) => {
    const isLeft = e.button === 0;
    const isRight = e.button === 2;
    const isMiddle = e.button === 1;

    // deselect if click empty in select mode
    if(isLeft && state.tool === "select" && !e.target.closest(".token")){
      deselectToken();
    }

    // measure
    if(isLeft && state.tool === "measure"){
      const p = screenToBoard(e.clientX, e.clientY);
      state.measure.dragging = true;
      state.measure.a = e.shiftKey ? { x: snap(p.x, state.grid.size), y: snap(p.y, state.grid.size) } : p;
      state.measure.b = state.measure.a;
      drawOverlay();
      return;
    }

    // fog paint
    if(isLeft && (state.tool === "fog_reveal" || state.tool === "fog_cover")){
      if(!state.fog.enabled) return toast("Fog está desligado", "Ligue em Ferramentas ou tecla F");
      state.input.fogPainting = true;
      const p = screenToBoard(e.clientX, e.clientY);
      state.input.fogLast = p;
      const mode = state.tool === "fog_reveal" ? "reveal" : "cover";
      paintFogLine(p, p, mode);
      return;
    }

    // pan (tool pan OR space OR mouse2/3)
    const wantsPan = (state.tool === "pan") || state.input.spaceDown || isRight || isMiddle;
    if(wantsPan){
      state.input.isPanning = true;
      state.input.panStart = { x: e.clientX, y: e.clientY, panX: state.view.panX, panY: state.view.panY, pointerId: e.pointerId };
      stage.setPointerCapture(e.pointerId);
      return;
    }
  });

  stage.addEventListener("pointerup", (e) => {
    if(state.input.tokenDrag) endTokenDrag();

    if(state.tool === "measure" && state.measure.dragging){
      state.measure.dragging = false;
      drawOverlay();
    }

    if(state.input.fogPainting){
      state.input.fogPainting = false;
      state.input.fogLast = null;
      toast("Fog aplicado", state.tool === "fog_reveal" ? "revelou área" : "cobriu área");
    }

    if(state.input.isPanning && state.input.panStart && state.input.panStart.pointerId === e.pointerId){
      state.input.isPanning = false;
      state.input.panStart = null;
    }
  });

  stage.addEventListener("wheel", (e) => {
    e.preventDefault();
    const delta = -Math.sign(e.deltaY) * 0.12;
    const old = state.view.scale;
    const next = clamp(old * (1 + delta), 0.15, 4);

    const r = stageRect();
    const mx = e.clientX - r.left;
    const my = e.clientY - r.top;

    const bx = (mx - state.view.panX) / old;
    const by = (my - state.view.panY) / old;

    state.view.scale = next;
    state.view.panX = mx - bx * next;
    state.view.panY = my - by * next;

    applyBoardTransform();
  }, { passive:false });

  // ---------- Keyboard shortcuts ----------
  window.addEventListener("keydown", (e) => {
    if(e.code === "Space") state.input.spaceDown = true;

    const tag = document.activeElement?.tagName?.toLowerCase();
    const typing = tag === "input" || tag === "textarea" || tag === "select";
    if(typing) return;

    const k = e.key.toLowerCase();

    if(e.key === "Delete"){
      if(state.selectedTokenId){
        const t = tokenById(state.selectedTokenId);
        state.tokens = state.tokens.filter(x => x.id !== state.selectedTokenId);
        state.selectedTokenId = null;
        renderAllTokens();
        toast("Token deletado", t?.name || "token");
      }
    }

    if(k === "m") setTool("measure");
    if(k === "v") setTool("select");
    if(k === "h") setTool("pan");
    if(k === "e") setTool("fog_reveal");
    if(k === "c") setTool("fog_cover");
    if(k === "z") setTool("fit");

    if(k === "g"){
      state.grid.show = !state.grid.show;
      drawGrid();
      setHUD();
      toast("Grid", state.grid.show ? "ligado" : "desligado");
    }

    if(k === "f"){
      state.fog.enabled = !state.fog.enabled;
      applyFogVisual();
      setHUD();
      toast("Fog", state.fog.enabled ? "ligado" : "desligado");
    }
  });

  window.addEventListener("keyup", (e) => {
    if(e.code === "Space") state.input.spaceDown = false;
  });

  // Token drag global
  window.addEventListener("pointermove", (e) => { if(state.input.tokenDrag) moveTokenDrag(e); });
  window.addEventListener("pointerup",   (e) => { if(state.input.tokenDrag) endTokenDrag(); });

  // ---------- Init ----------
  function init(){
    // defaults UI
    setMapSrc("");
    setMapSize(DEFAULT_MAP.w, DEFAULT_MAP.h);

    mapW.value = state.map.w;
    mapH.value = state.map.h;

    gridSize.value = state.grid.size;
    gridColor.value = state.grid.color;

    fogOpacity.value = Math.round(state.fog.opacity * 100);
    fogBrush.value = state.fog.brush;

    notes.value = state.notes;

    fillFog();
    applyFogVisual();
    drawGrid();

    renderLibrary();
    renderAllTokens();
    renderRolls();
    renderInitiative();

    applyBoardTransform();
    fit(true, true);
    setHUD();

    // Ajudinha inicial (uma vez)
    setTimeout(() => toast("Dica", "Use a toolbar no rodapé para trocar ferramentas"), 450);
    setTimeout(() => toast("Atalhos", "Espaço+arrastar = pan · M = régua · F = fog"), 950);
  }

  init();
})();
</script>
</body>
</html>
