<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>Tabletop Luxury - Online P2P (Host Autoritativo + Cenas Save/Load)</title>

  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>

  <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Inter:wght@300;400;600&display=swap" rel="stylesheet">

  <style>
    :root {
      --gold: #c5a059;
      --dark-bg: #0f0f0f;
      --panel-bg: rgba(20, 20, 20, 0.9);
      --glass: rgba(255, 255, 255, 0.03);
      --status-online: #4ade80;
      --status-offline: #ef4444;
    }

    body {
      margin: 0;
      overflow: hidden;
      background-color: var(--dark-bg);
      font-family: 'Inter', sans-serif;
      color: #e0e0e0;
    }

    #viewport {
      width: 100vw;
      height: 100vh;
      overflow: hidden;
      position: relative;
      background: radial-gradient(circle, #1a1a1a 0%, #0a0a0a 100%);
      z-index: 1;
    }

    #canvas-container {
      width: 10000px;
      height: 10000px;
      position: absolute;
      top: 0;
      left: 0;
      transform-origin: 0 0;
      cursor: grab;
      z-index: 2;
    }

    .map-layer {
      position: absolute;
      top: 0;
      left: 0;
      z-index: 5;
      pointer-events: none;
      transition: opacity 0.3s;
    }
    .map-layer.locked { pointer-events: none; }
    .map-layer img { display: block; max-width: none; }

    .grid-layer {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      background-image:
        linear-gradient(to right, rgba(197, 160, 89, 0.05) 1px, transparent 1px),
        linear-gradient(to bottom, rgba(197, 160, 89, 0.05) 1px, transparent 1px);
      background-size: 50px 50px;
      z-index: 6;
    }

    .token {
      position: absolute;
      cursor: move;
      user-select: none;
      z-index: 100;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: filter 0.2s ease, outline 0.2s ease;
      background: transparent;
      overflow: visible;
    }

    .token.locked {
      cursor: default !important;
      pointer-events: none;
    }

    .token.locked .token-controls,
    .token.locked .resize-handle { display: none !important; }

    .token-blocker {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      z-index: 50;
      background: rgba(255, 255, 255, 0.001);
    }

    .token-content-wrapper {
      width: 100%;
      height: 100%;
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: none;
    }

    .token iframe, .token img {
      width: 100%;
      height: 100%;
      border: none;
      background: transparent;
      pointer-events: none;
      object-fit: contain;
      transition: transform 0.2s ease-out;
    }

    .token.selected:not(.locked) {
      filter: drop-shadow(0 0 15px var(--gold));
      z-index: 101;
      outline: 2px dashed rgba(197, 160, 89, 0.6);
      outline-offset: 4px;
    }

    .resize-handle {
      position: absolute;
      width: 16px;
      height: 16px;
      background: var(--gold);
      border: 2px solid white;
      border-radius: 4px;
      display: none;
      z-index: 110;
      cursor: nwse-resize;
      bottom: -8px;
      right: -8px;
    }

    .token.selected:not(.locked) .resize-handle { display: block; }

    .token-controls {
      position: absolute;
      top: -65px;
      left: 50%;
      transform: translateX(-50%);
      display: none;
      background: var(--panel-bg);
      backdrop-filter: blur(12px);
      border: 1px solid rgba(197, 160, 89, 0.4);
      border-radius: 40px;
      padding: 8px 16px;
      gap: 15px;
      z-index: 200;
      box-shadow: 0 4px 20px rgba(0,0,0,0.5);
      white-space: nowrap;
    }

    .token.selected:not(.locked) .token-controls { display: flex; align-items: center; }

    .token-btn {
      color: #fff;
      font-size: 16px;
      cursor: pointer;
      opacity: 0.8;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      gap: 5px;
    }

    .token-btn:hover {
      opacity: 1;
      color: var(--gold);
      transform: scale(1.1);
    }

    .hud-element { transition: opacity 0.4s ease, transform 0.4s ease; }
    .hud-hidden .hud-element { opacity: 0 !important; pointer-events: none !important; transform: translateY(10px); }

    .sidebar {
      width: 280px;
      background: var(--panel-bg);
      backdrop-filter: blur(15px);
      height: 100vh;
      position: fixed;
      left: 0;
      top: 0;
      z-index: 1000;
      border-right: 1px solid rgba(197, 160, 89, 0.2);
      transform: translateX(-100%);
      transition: transform 0.4s cubic-bezier(0.16, 1, 0.3, 1);
    }
    .sidebar.open { transform: translateX(0); }

    .toggle-sidebar-btn {
      position: absolute;
      right: -35px;
      top: 20px;
      background: var(--panel-bg);
      border: 1px solid rgba(197, 160, 89, 0.2);
      border-left: none;
      padding: 10px 8px;
      border-radius: 0 8px 8px 0;
      cursor: pointer;
      color: var(--gold);
    }

    .controls-top {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 10px;
      z-index: 1000;
      background: var(--panel-bg);
      padding: 8px;
      border-radius: 40px;
      border: 1px solid rgba(197, 160, 89, 0.2);
      backdrop-filter: blur(10px);
      box-shadow: 0 5px 25px rgba(0,0,0,0.4);
    }

    .btn-luxury {
      padding: 8px 16px;
      border-radius: 20px;
      font-size: 12px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 1px;
      transition: all 0.3s;
      border: 1px solid transparent;
      color: #ccc;
      background: transparent;
    }

    .btn-luxury:hover, .btn-luxury.active {
      color: var(--gold);
      background: var(--glass);
      border-color: rgba(197, 160, 89, 0.4);
    }

    .dice-log {
      position: fixed;
      bottom: 25px;
      right: 25px;
      width: 240px;
      max-height: 200px;
      background: var(--panel-bg);
      border-radius: 12px;
      border: 1px solid rgba(197, 160, 89, 0.15);
      padding: 15px;
      overflow-y: auto;
      font-size: 13px;
      z-index: 1000;
      box-shadow: 0 4px 15px rgba(0,0,0,0.3);
    }

    .btn-toggle-hud {
      position: fixed;
      bottom: 25px;
      left: 25px;
      z-index: 2000;
      background: var(--panel-bg);
      width: 45px;
      height: 45px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      border: 1px solid rgba(197, 160, 89, 0.3);
      cursor: pointer;
      color: var(--gold);
      box-shadow: 0 4px 10px rgba(0,0,0,0.4);
    }

    .url-field {
      background: rgba(0,0,0,0.3);
      border: 1px solid rgba(197, 160, 89, 0.2);
      color: white;
      width: 100%;
      font-size: 12px;
      padding: 8px;
      margin-bottom: 10px;
      outline: none;
      border-radius: 6px;
    }

    .url-field:focus { border-color: var(--gold); background: rgba(0,0,0,0.5); }

    h2, h3 { font-family: 'Cinzel', serif; letter-spacing: 1px; color: var(--gold); }

    .network-status {
      position: fixed;
      top: 80px;
      right: 20px;
      display: flex;
      align-items: center;
      gap: 10px;
      background: var(--panel-bg);
      padding: 8px 16px;
      border-radius: 20px;
      border: 1px solid rgba(197, 160, 89, 0.2);
      font-size: 11px;
      z-index: 1000;
      backdrop-filter: blur(10px);
      opacity: 0;
      pointer-events: none;
      transform: translateY(-10px);
      transition: all 0.3s;
    }
    .network-status.show { opacity: 1; pointer-events: auto; transform: translateY(0); }

    .status-dot {
      width: 8px; height: 8px;
      border-radius: 50%;
      background-color: var(--status-offline);
      box-shadow: 0 0 5px currentColor;
    }
    .status-dot.online { background-color: var(--status-online); }

    .lock-manager {
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 1000;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    #notification {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) scale(0.9);
      background: rgba(0,0,0,0.9);
      border: 1px solid var(--gold);
      padding: 20px 40px;
      border-radius: 10px;
      z-index: 9999;
      color: var(--gold);
      font-family: 'Cinzel', serif;
      opacity: 0;
      pointer-events: none;
      transition: all 0.3s;
    }
    #notification.active { opacity: 1; transform: translate(-50%, -50%) scale(1); }

    #role-badge {
      position: fixed;
      top: 140px;
      right: 20px;
      z-index: 1100;
      background: var(--panel-bg);
      border: 1px solid rgba(197, 160, 89, 0.2);
      border-radius: 999px;
      padding: 6px 12px;
      font-size: 11px;
      backdrop-filter: blur(10px);
      opacity: 0.95;
    }
    #role-badge b { color: var(--gold); }
  </style>
</head>

<body>
  <div id="notification">Link copiado!</div>
  <div id="role-badge">Modo: <b id="role-text">...</b></div>

  <div class="btn-toggle-hud" onclick="toggleHUD()" title="Esconder/Mostrar Interface">üëÅÔ∏è</div>

  <div id="hud-root">
    <div class="controls-top hud-element">
      <button class="btn-luxury" id="btn-d20" onclick="rollDice(20)">D20</button>
      <button class="btn-luxury" id="btn-d6" onclick="rollDice(6)">D6</button>
      <button class="btn-luxury" onclick="toggleGrid()">Grelha</button>
      <button class="btn-luxury" id="btn-lock-all" onclick="unlockEverything()">üîì Destrancar</button>
      <button class="btn-luxury" id="btn-save-scene" onclick="openScenePanel()">üíæ Cena</button>
      <button class="btn-luxury" onclick="toggleNetworkPanel()">üåê Rede</button>
    </div>

    <div class="lock-manager hud-element">
      <button class="btn-luxury bg-black/40 border-gold/20" id="btn-lock-map" onclick="toggleMapLock()">üîì Mapa M√≥vel</button>
    </div>

    <div class="network-status" id="network-panel">
      <div id="status-dot" class="status-dot"></div>
      <span id="status-text">Offline</span>
      <div class="h-4 w-px bg-white/20 mx-2"></div>
      <button class="btn-luxury py-0 px-2 text-[10px]" onclick="copyInviteLink()" id="btn-invite">üîó Copiar Convite</button>
    </div>

    <!-- Painel de Cenas (HOST) -->
    <div class="network-status" id="scene-panel" style="top: 120px;">
      <span style="color: var(--gold); font-weight:700;">Cenas</span>
      <div class="h-4 w-px bg-white/20 mx-2"></div>

      <label class="btn-luxury py-0 px-2 text-[10px] cursor-pointer" style="display:flex;align-items:center;gap:6px;">
        <input type="checkbox" id="embed-remote" checked>
        Embutir URLs
      </label>

      <label class="btn-luxury py-0 px-2 text-[10px] cursor-pointer" style="display:flex;align-items:center;gap:6px;">
        <input type="checkbox" id="compress-images" checked>
        Comprimir
      </label>

      <select id="max-dim" class="url-field" style="margin:0; padding:6px; width:95px;">
        <option value="1024">1024px</option>
        <option value="1536">1536px</option>
        <option value="2048" selected>2048px</option>
        <option value="3072">3072px</option>
        <option value="4096">4096px</option>
      </select>

      <input id="quality" type="range" min="0.4" max="0.95" step="0.05" value="0.75" style="width:90px;">
      <span id="quality-label" style="font-size:10px;opacity:.8;">Q 0.75</span>

      <span id="scene-size" style="font-size:10px;opacity:.8; margin-left:6px;">~ -</span>

      <div class="h-4 w-px bg-white/20 mx-2"></div>

      <button class="btn-luxury py-0 px-2 text-[10px]" onclick="saveSceneToFile()">Salvar .JSON</button>
      <label class="btn-luxury py-0 px-2 text-[10px] cursor-pointer">
        Carregar .JSON
        <input type="file" id="scene-file" accept="application/json" style="display:none" onchange="loadSceneFromFile(event)">
      </label>
    </div>

    <div class="sidebar hud-element" id="sidebar">
      <div class="toggle-sidebar-btn" onclick="toggleSidebar()">‚ò∞</div>
      <div class="p-6 overflow-y-auto h-full">
        <h2 class="text-xl font-bold mb-8 border-b border-gold/30 pb-3">Atelier P2P</h2>

        <div class="mb-10" id="host-only-map">
          <h3 class="text-xs font-semibold uppercase mb-4 opacity-70">Ambiente</h3>
          <div class="bg-black/40 p-4 border border-dashed border-gold/30 rounded-xl">
            <input type="file" id="map-file" accept="image/*" class="hidden" onchange="importAsset(event, 'map')">
            <label for="map-file" class="btn-luxury block text-center mb-3 cursor-pointer bg-white/5">Ficheiro Local</label>
            <input type="text" id="map-url" class="url-field" placeholder="https://link-do-mapa.jpg">
            <button class="btn-luxury w-full border border-gold/30" onclick="importFromUrl('map-url', 'map')">Definir Mapa</button>
          </div>
          <p class="text-[10px] opacity-50 mt-3 leading-relaxed italic">
            Dica: imagens locais viram dataURL. Se ficar pesado, use compress√£o no Save de Cena.
          </p>
        </div>

        <div class="mb-10" id="host-only-tokens">
          <h3 class="text-xs font-semibold uppercase mb-4 opacity-70">Pe√ßas</h3>
          <div class="bg-black/40 p-4 border border-dashed border-gold/30 rounded-xl">
            <input type="file" id="token-file" accept="image/*" class="hidden" onchange="importAsset(event, 'pc')">
            <label for="token-file" class="btn-luxury block text-center mb-3 cursor-pointer bg-white/5">Ficheiro Local</label>
            <input type="text" id="token-url" class="url-field" placeholder="URL Imagem...">
            <button class="btn-luxury w-full border border-gold/30" onclick="importFromUrl('token-url', 'pc')">Adicionar Pe√ßa</button>
          </div>
          <p class="text-[10px] opacity-50 mt-3 leading-relaxed italic">
            Players s√≥ movem tokens destravados. A√ß√µes passam pelo Host (autoridade).
          </p>
        </div>

        <div class="mt-auto pt-6 border-t border-gold/20" id="host-only-clear">
          <button class="btn-luxury w-full text-red-500 border-red-900/30 hover:bg-red-900/20" onclick="clearTable()">Limpar Mesa</button>
        </div>

        <div class="mt-6 text-[10px] opacity-50 leading-relaxed">
          <div><b>Status:</b> <span id="tiny-status">iniciando...</span></div>
          <div><b>Sala:</b> <span id="tiny-room">-</span></div>
        </div>
      </div>
    </div>

    <div class="dice-log hud-element" id="dice-log">
      <div id="dice-entries">
        <div class="text-[11px] opacity-40 mb-3 uppercase tracking-tighter">Hist√≥rico</div>
      </div>
    </div>
  </div>

  <div id="viewport">
    <div id="canvas-container">
      <div id="map-container" class="map-layer"></div>
      <div id="grid-layer" class="grid-layer"></div>
    </div>
  </div>

  <script>
    /********************************************************************
     * MODELO: HOST AUTORITATIVO
     * - Player envia REQUEST (kind="REQ")
     * - Host valida, aplica e BROADCAST (kind="ACT")
     * - Clients aplicam apenas ACT
     * - Host manda SYNC ao conectar (kind="SYNC")
     ********************************************************************/

    // --- UTILIT√ÅRIOS ---
    const generateUUID = () => Date.now().toString(36) + Math.random().toString(36).slice(2);

    // --- ELEMENTOS ---
    const canvas = document.getElementById('canvas-container');
    const viewport = document.getElementById('viewport');
    const mapContainer = document.getElementById('map-container');
    const sidebar = document.getElementById('sidebar');
    const diceLogEntries = document.getElementById('dice-entries');
    const gridLayer = document.getElementById('grid-layer');
    const statusDot = document.getElementById('status-dot');
    const statusText = document.getElementById('status-text');
    const networkPanel = document.getElementById('network-panel');
    const scenePanel = document.getElementById('scene-panel');
    const roleText = document.getElementById('role-text');
    const tinyStatus = document.getElementById('tiny-status');
    const tinyRoom = document.getElementById('tiny-room');

    // Host-only UI
    const hostOnlyMap = document.getElementById('host-only-map');
    const hostOnlyTokens = document.getElementById('host-only-tokens');
    const hostOnlyClear = document.getElementById('host-only-clear');
    const btnLockAll = document.getElementById('btn-lock-all');
    const btnLockMap = document.getElementById('btn-lock-map');
    const btnInvite = document.getElementById('btn-invite');
    const btnD20 = document.getElementById('btn-d20');
    const btnD6 = document.getElementById('btn-d6');
    const btnSaveScene = document.getElementById('btn-save-scene');

    // --- C√ÇMERA ---
    let scale = 1;
    let posX = window.innerWidth / 2 - 5000;
    let posY = window.innerHeight / 2 - 5000;
    let isPanning = false;
    let startPan = { x: 0, y: 0 };

    // --- SELE√á√ÉO ---
    let selectedToken = null;

    // --- ESTADO (Host mant√©m) ---
    const state = {
      mapSrc: null,
      mapLocked: false,
      tokens: {} // id -> {id, src, type, x, y, w, h, rotation, flipped, innerZoom, locked}
    };

    // --- REDE / PEERJS ---
    let peer;
    let connections = [];
    let hostConnection = null;
    let myId = null;
    let isHost = false;

    // ICE servers (STUN). Voc√™ pode adicionar TURN depois.
    const PEER_ICE_CONFIG = {
      iceServers: [
        { urls: "stun:stun.l.google.com:19302" },
        { urls: "stun:stun1.l.google.com:19302" },
        { urls: "stun:global.stun.twilio.com:3478" }
      ]
    };

    // =============== UI ===============
    function toggleHUD() { document.body.classList.toggle('hud-hidden'); }
    function toggleSidebar() { sidebar.classList.toggle('open'); }
    function toggleGrid() { gridLayer.style.display = gridLayer.style.display === 'none' ? 'block' : 'none'; }
    function toggleNetworkPanel() { networkPanel.classList.toggle('show'); }

    function openScenePanel() {
      if (!isHost) return alert("Apenas o Host pode salvar/carregar cenas.");
      scenePanel.classList.toggle('show');
      updateQualityLabel();
      updateSceneSizeEstimate();
    }

    function showNotification(msg) {
      const notif = document.getElementById('notification');
      notif.innerText = msg;
      notif.classList.add('active');
      setTimeout(() => notif.classList.remove('active'), 2000);
    }

    function copyInviteLink() {
      if (!myId) return alert("Aguarde a conex√£o...");
      if (!isHost) return alert("Apenas o Host copia convite.");

      const urlObj = new URL(window.location.href);
      urlObj.searchParams.set('room', myId);
      const inviteUrl = urlObj.toString();

      if (navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(inviteUrl)
          .then(() => showNotification("Link copiado!"))
          .catch(() => fallbackCopy(inviteUrl));
      } else {
        fallbackCopy(inviteUrl);
      }
    }

    function fallbackCopy(text) {
      const textArea = document.createElement("textarea");
      textArea.value = text;
      textArea.style.top = "0";
      textArea.style.left = "0";
      textArea.style.position = "fixed";
      textArea.style.opacity = "0";
      document.body.appendChild(textArea);
      textArea.focus();
      textArea.select();
      try {
        const ok = document.execCommand('copy');
        if (ok) showNotification("Link copiado!");
        else prompt("Pressione Ctrl+C para copiar o link:", text);
      } catch {
        prompt("Pressione Ctrl+C para copiar o link:", text);
      }
      document.body.removeChild(textArea);
    }

    function setRoleUI() {
      roleText.textContent = isHost ? "HOST (Mestre)" : "PLAYER";

      hostOnlyMap.style.display = isHost ? "" : "none";
      hostOnlyTokens.style.display = isHost ? "" : "none";
      hostOnlyClear.style.display = isHost ? "" : "none";
      btnLockAll.style.display = isHost ? "" : "none";
      btnLockMap.style.display = isHost ? "" : "none";
      btnInvite.style.display = isHost ? "" : "none";
      btnD20.style.display = isHost ? "" : "none";
      btnD6.style.display = isHost ? "" : "none";
      if (btnSaveScene) btnSaveScene.style.display = isHost ? "" : "none";
      if (scenePanel) scenePanel.style.display = isHost ? "" : "none";
    }

    // =============== Transform / Pan / Zoom ===============
    function updateTransform() {
      canvas.style.transform = `translate(${posX}px, ${posY}px) scale(${scale})`;
    }
    updateTransform();

    viewport.addEventListener('wheel', (e) => {
      if (e.ctrlKey) return;
      e.preventDefault();
      const zoomSpeed = 0.15;
      const delta = e.deltaY > 0 ? -zoomSpeed : zoomSpeed;
      const newScale = Math.min(Math.max(0.05, scale + delta), 4);
      const mouseX = e.clientX;
      const mouseY = e.clientY;
      const contentMouseX = (mouseX - posX) / scale;
      const contentMouseY = (mouseY - posY) / scale;
      scale = newScale;
      posX = mouseX - contentMouseX * scale;
      posY = mouseY - contentMouseY * scale;
      updateTransform();
    }, { passive: false });

    window.addEventListener('mousedown', (e) => {
      if (e.button === 2 || e.button === 1 || (e.button === 0 && e.altKey)) {
        isPanning = true;
        startPan = { x: e.clientX - posX, y: e.clientY - posY };
        viewport.style.cursor = 'grabbing';
      }
    });

    window.addEventListener('mousemove', (e) => {
      if (isPanning) {
        posX = e.clientX - startPan.x;
        posY = e.clientY - startPan.y;
        updateTransform();
      }
    });

    window.addEventListener('mouseup', () => { isPanning = false; viewport.style.cursor = 'grab'; });

    // =============== Protocolo de Mensagens ===============
    // kind: "REQ" (client->host), "ACT" (host->all), "SYNC" (host->client)
    function sendREQ(action) {
      if (isHost) {
        applyHostAuthorizedAction(action, { sender: myId });
        return;
      }
      if (hostConnection && hostConnection.open) {
        hostConnection.send({ kind: "REQ", sender: myId, action });
      }
    }

    function broadcastACT(action, meta = {}) {
      if (!isHost) return;
      const msg = { kind: "ACT", sender: myId, action, meta };
      connections.forEach(c => { if (c.open) c.send(msg); });
    }

    function sendSYNC(conn) {
      if (!isHost) return;
      conn.send({ kind: "SYNC", sender: myId, state });
    }

    function handleNetworkData(data, connPeerId = null) {
      if (!data || !data.kind) return;

      if (data.kind === "SYNC") {
        applyFullSync(data.state);
        return;
      }

      if (data.kind === "ACT") {
        applyAction(data.action, true);
        return;
      }

      if (data.kind === "REQ") {
        if (!isHost) return;
        const sender = data.sender || connPeerId || "unknown";
        const action = data.action;
        applyHostAuthorizedAction(action, { sender });
      }
    }

    // =============== Valida√ß√£o (HOST) ===============
    function validateClientAction(action, sender) {
      if (!action || !action.type) return { ok: false, reason: "A√ß√£o inv√°lida" };

      const allowedClientTypes = new Set(["MOVE", "UPDATE_PROP"]);
      if (!allowedClientTypes.has(action.type)) return { ok: false, reason: "A√ß√£o n√£o permitida para player" };

      const tokenId = action.id;
      if (!tokenId || !state.tokens[tokenId]) return { ok: false, reason: "Token inexistente" };

      const tok = state.tokens[tokenId];
      if (String(tok.locked) === "true") return { ok: false, reason: "Token travado" };

      if (action.type === "UPDATE_PROP") {
        const allowedProps = new Set(["rotation", "flipped", "innerZoom", "size"]);
        if (!allowedProps.has(action.prop)) return { ok: false, reason: "Propriedade n√£o permitida" };
      }

      return { ok: true };
    }

    function applyHostAuthorizedAction(action, { sender }) {
      if (!action || !action.type) return;

      const cameFromClient = sender && sender !== myId;

      if (cameFromClient) {
        const v = validateClientAction(action, sender);
        if (!v.ok) {
          console.warn("REQ negada:", v.reason, action);
          return;
        }
      }

      applyAction(action, false);
      broadcastACT(action, { approvedBy: myId, originalSender: sender });
    }

    // =============== Apply Action ===============
    function applyAction(action, fromNetwork) {
      switch (action.type) {
        case "MOVE": {
          const { id, x, y } = action;
          moveTokenDOM(id, x, y);
          if (isHost && state.tokens[id]) {
            state.tokens[id].x = x;
            state.tokens[id].y = y;
          }
          break;
        }

        case "CREATE_TOKEN": {
          const { id, src, contentType, props } = action;
          addTokenLocal(src, contentType, id, props);
          if (isHost) {
            state.tokens[id] = normalizeTokenProps(id, src, contentType, props);
          }
          break;
        }

        case "REMOVE_TOKEN": {
          const { id } = action;
          removeTokenLocal(id);
          if (isHost) delete state.tokens[id];
          break;
        }

        case "UPDATE_PROP": {
          const { id, prop, value } = action;
          updateTokenPropDOM(id, prop, value);
          if (isHost && state.tokens[id]) {
            if (prop === "locked") state.tokens[id].locked = value;
            if (prop === "innerZoom") state.tokens[id].innerZoom = value;
            if (prop === "rotation") state.tokens[id].rotation = value;
            if (prop === "flipped") state.tokens[id].flipped = value;
            if (prop === "size") { state.tokens[id].w = value.w; state.tokens[id].h = value.h; }
          }
          break;
        }

        case "MAP_UPDATE": {
          const { src } = action;
          applyMapLocal(src, false);
          if (isHost) state.mapSrc = src;
          break;
        }

        case "MAP_LOCK": {
          const { locked } = action;
          setMapLockLocal(!!locked, false);
          if (isHost) state.mapLocked = !!locked;
          break;
        }

        case "DICE": {
          const { faces, result } = action;
          showDiceLog(faces, result);
          break;
        }

        case "CLEAR": {
          clearTableLocal(false);
          if (isHost) {
            state.mapSrc = null;
            state.mapLocked = false;
            state.tokens = {};
          }
          break;
        }
      }
    }

    // =============== Sync (Client) ===============
    function applyFullSync(s) {
      if (!s) return;

      document.querySelectorAll('.token').forEach(t => t.remove());
      mapContainer.innerHTML = "";
      document.querySelectorAll('.dice-entry').forEach(l => l.remove());
      selectedToken = null;

      if (s.mapSrc) applyMapLocal(s.mapSrc, false);
      setMapLockLocal(!!s.mapLocked, false);

      const tokens = s.tokens || {};
      Object.keys(tokens).forEach(id => {
        const t = tokens[id];
        addTokenLocal(t.src, t.type, id, t);
      });

      if (!isHost) {
        state.mapSrc = s.mapSrc || null;
        state.mapLocked = !!s.mapLocked;
        state.tokens = JSON.parse(JSON.stringify(tokens));
      }

      updateSceneSizeEstimate();
    }

    // =============== PeerJS Setup ===============
    function initNetwork() {
      const urlParams = new URLSearchParams(window.location.search);
      const roomID = urlParams.get('room');

      peer = new Peer(null, {
        debug: 2,
        config: PEER_ICE_CONFIG
      });

      peer.on('open', (id) => {
        myId = id;

        if (roomID) {
          isHost = false;
          setRoleUI();
          statusText.innerText = "Conectando ao Host...";
          tinyStatus.textContent = "Conectando...";
          tinyRoom.textContent = roomID;
          connectToHost(roomID);
        } else {
          isHost = true;
          setRoleUI();
          statusText.innerText = "Online (Host)";
          tinyStatus.textContent = "Online (Host)";
          tinyRoom.textContent = id;
          statusDot.classList.add('online');
          toggleNetworkPanel();

          peer.on('connection', (conn) => {
            connections.push(conn);
            setupConnection(conn);

            conn.on('open', () => {
              setTimeout(() => sendSYNC(conn), 200);
            });

            conn.on('close', () => {
              connections = connections.filter(c => c !== conn);
            });
          });
        }
      });

      peer.on('error', (err) => {
        console.error(err);
        statusText.innerText = "Erro Rede";
        tinyStatus.textContent = "Erro Rede";
        statusDot.classList.remove('online');
      });
    }

    function connectToHost(hostId) {
      hostConnection = peer.connect(hostId);
      setupConnection(hostConnection);

      hostConnection.on('open', () => {
        statusText.innerText = "Conectado";
        tinyStatus.textContent = "Conectado";
        statusDot.classList.add('online');
      });

      hostConnection.on('close', () => {
        statusText.innerText = "Desconectado";
        tinyStatus.textContent = "Desconectado";
        statusDot.classList.remove('online');
        alert("O Host desconectou.");
      });
    }

    function setupConnection(conn) {
      conn.on('data', (data) => handleNetworkData(data, conn.peer));
    }

    // =============== Mapa ===============
    let mapLocked = false;

    function setMapLockLocal(lock, emit) {
      mapLocked = !!lock;
      if (mapLocked) mapContainer.classList.add('locked');
      else mapContainer.classList.remove('locked');

      const btn = document.getElementById('btn-lock-map');
      if (btn) {
        if (mapLocked) { btn.innerHTML = "üîí Mapa Fixo"; btn.classList.add('active'); }
        else { btn.innerHTML = "üîì Mapa M√≥vel"; btn.classList.remove('active'); }
      }

      if (emit) {
        if (!isHost) return;
        const action = { type: "MAP_LOCK", locked: mapLocked };
        applyAction(action, false);
        broadcastACT(action);
      }
    }

    function toggleMapLock() {
      if (!isHost) return;
      setMapLockLocal(!mapLocked, true);
    }

    function applyMapLocal(src, emit) {
      const img = new Image();
      img.onload = () => {
        mapContainer.innerHTML = '';
        mapContainer.appendChild(img);
        scale = Math.min(window.innerWidth / img.width, window.innerHeight / img.height, 1) * 0.8;
        posX = window.innerWidth / 2 - (img.width * scale) / 2;
        posY = window.innerHeight / 2 - (img.height * scale) / 2;
        updateTransform();
      };
      img.src = src;

      if (emit) {
        if (!isHost) return;
        const action = { type: "MAP_UPDATE", src };
        applyAction(action, false);
        broadcastACT(action);
      }
    }

    function isImageUrl(url) {
      return (url.match(/\.(jpeg|jpg|gif|png|webp|avif)$/i) != null) || url.startsWith('data:image');
    }

    function importFromUrl(inputId, type) {
      if (!isHost) return alert("Apenas o Host importa.");
      const url = document.getElementById(inputId).value.trim();
      if (!url) return;

      if (isImageUrl(url)) {
        if (type === 'map') applyMapLocal(url, true);
        else hostCreateToken(url, 'image');
        document.getElementById(inputId).value = "";
      } else {
        if (type === 'map') alert("Mapas precisam ser imagens diretas.");
        else {
          hostCreateToken(url, 'web');
          document.getElementById(inputId).value = "";
        }
      }
      updateSceneSizeEstimate();
    }

    function importAsset(event, type) {
      if (!isHost) return alert("Apenas o Host importa.");
      const file = event.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = (e) => {
        const dataUrl = e.target.result;
        if (type === 'map') applyMapLocal(dataUrl, true);
        else hostCreateToken(dataUrl, 'image');
        updateSceneSizeEstimate();
      };
      reader.readAsDataURL(file);
    }

    // =============== Tokens ===============
    function normalizeTokenProps(id, src, type, props) {
      const p = props || {};
      return {
        id,
        src,
        type,
        x: p.x ?? "0px",
        y: p.y ?? "0px",
        w: p.w ?? 120,
        h: p.h ?? 120,
        rotation: p.rotation ?? 0,
        flipped: p.flipped ?? "false",
        innerZoom: p.innerZoom ?? 1,
        locked: p.locked ?? "false"
      };
    }

    function hostCreateToken(src, contentType) {
      if (!isHost) return;

      const id = generateUUID();
      const width = (contentType === 'web') ? 400 : 120;
      const height = (contentType === 'web') ? 225 : 120;

      const centerX = (window.innerWidth / 2 - posX) / scale;
      const centerY = (window.innerHeight / 2 - posY) / scale;

      const props = {
        x: (centerX - width / 2) + "px",
        y: (centerY - height / 2) + "px",
        w: width,
        h: height,
        rotation: 0,
        flipped: "false",
        innerZoom: 1,
        locked: "false"
      };

      const action = { type: "CREATE_TOKEN", id, src, contentType, props };
      applyAction(action, false);
      broadcastACT(action);
      updateSceneSizeEstimate();
    }

    function addTokenLocal(src, contentType, id, props) {
      if (document.getElementById(`token-${id}`)) return;

      const token = document.createElement('div');
      token.id = `token-${id}`;
      token.dataset.uuid = id;
      token.dataset.type = contentType;
      token.className = `token`;

      const width = props?.w ? parseInt(props.w) : 120;
      const height = props?.h ? parseInt(props.h) : 120;

      token.style.width = width + "px";
      token.style.height = height + "px";

      if (props?.x != null && props?.y != null) {
        token.style.left = props.x;
        token.style.top = props.y;
      } else {
        const centerX = (window.innerWidth / 2 - posX) / scale;
        const centerY = (window.innerHeight / 2 - posY) / scale;
        token.style.left = (centerX - width / 2) + "px";
        token.style.top = (centerY - height / 2) + "px";
      }

      token.dataset.sizeW = width;
      token.dataset.sizeH = height;
      token.dataset.rotation = props?.rotation ?? 0;
      token.dataset.flipped = props?.flipped ?? "false";
      token.dataset.innerZoom = props?.innerZoom ?? 1;
      token.dataset.locked = props?.locked ?? "false";

      if (token.dataset.locked === "true") {
        token.classList.add('locked');
        token.style.pointerEvents = "none";
      }

      const blocker = document.createElement('div');
      blocker.className = 'token-blocker';

      const wrapper = document.createElement('div');
      wrapper.className = 'token-content-wrapper';

      let content;
      if (contentType === 'image') {
        content = document.createElement('img');
        content.src = src;
      } else {
        content = document.createElement('iframe');
        content.src = src;
        content.setAttribute('frameborder', '0');
        content.setAttribute('sandbox', 'allow-scripts allow-same-origin');
      }

      const handle = document.createElement('div');
      handle.className = 'resize-handle';

      const controls = document.createElement('div');
      controls.className = 'token-controls';
      controls.innerHTML = `
        <span class="token-btn" title="Zoom Interno -" onclick="zoomInnerToken(event, -0.1)">‚ûñ</span>
        <span class="token-btn" title="Zoom Interno +" onclick="zoomInnerToken(event, 0.1)">‚ûï</span>
        <span class="token-btn" title="Espelhar (F)" onclick="flipToken(this.closest('.token'))">‚ÜîÔ∏è</span>
        <span class="token-btn" title="Girar 45¬∞" onclick="rotateToken(event, 45)">üîÑ</span>
        <span class="token-btn" title="Trancar Pe√ßa" onclick="lockToken(event)">üîí</span>
        <span class="token-btn text-red-400" title="Eliminar" onclick="deleteToken(event)">üóëÔ∏è</span>
      `;

      wrapper.appendChild(content);
      token.appendChild(blocker);
      token.appendChild(wrapper);
      token.appendChild(handle);
      token.appendChild(controls);
      canvas.appendChild(token);

      setTimeout(() => updateImgTransform(token), 10);

      token.addEventListener('wheel', (e) => {
        if (!e.ctrlKey) return;
        if (token.dataset.locked === "true") return;
        e.preventDefault(); e.stopPropagation();

        const delta = e.deltaY > 0 ? -20 : 20;
        if (isHost) {
          resizeTokenDirect(token, delta, true);
        } else {
          const startW = parseInt(token.dataset.sizeW);
          const startH = parseInt(token.dataset.sizeH);
          const ratio = startH / startW;
          const newW = Math.max(40, Math.min(startW + delta, 2500));
          const newH = newW * ratio;
          sendREQ({ type: "UPDATE_PROP", id: token.dataset.uuid, prop: "size", value: { w: newW, h: newH } });
        }
      }, { passive: false });

      handle.addEventListener('mousedown', (e) => {
        if (token.dataset.locked === "true") return;
        e.stopPropagation(); e.preventDefault();

        const startX = e.clientX;
        const startW = parseInt(token.dataset.sizeW);
        const startH = parseInt(token.dataset.sizeH);
        const ratio = startH / startW;
        let pendingW = startW, pendingH = startH;

        function onMove(me) {
          const deltaW = ((me.clientX - startX) / scale) * 1.5;
          let w = Math.max(40, Math.min(startW + deltaW, 2500));
          let h = w * ratio;
          pendingW = Math.round(w);
          pendingH = Math.round(h);

          token.dataset.sizeW = pendingW;
          token.dataset.sizeH = pendingH;
          token.style.width = pendingW + "px";
          token.style.height = pendingH + "px";
        }

        function onUp() {
          document.removeEventListener('mousemove', onMove);
          document.removeEventListener('mouseup', onUp);

          if (isHost) {
            const action = { type: "UPDATE_PROP", id: token.dataset.uuid, prop: "size", value: { w: pendingW, h: pendingH } };
            applyAction(action, false);
            broadcastACT(action);
            updateSceneSizeEstimate();
          } else {
            sendREQ({ type: "UPDATE_PROP", id: token.dataset.uuid, prop: "size", value: { w: pendingW, h: pendingH } });
          }
        }

        document.addEventListener('mousemove', onMove);
        document.addEventListener('mouseup', onUp);
      });

      token.addEventListener('mousedown', (e) => {
        if (e.button !== 0 || e.altKey) return;
        if (token.dataset.locked === "true") return;

        e.stopPropagation();
        selectToken(token);
        startDraggingToken(e, token);
      });
    }

    function removeTokenLocal(id) {
      const t = document.getElementById(`token-${id}`);
      if (t) t.remove();
      if (selectedToken && selectedToken.dataset.uuid === id) selectedToken = null;
      updateSceneSizeEstimate();
    }

    function moveTokenDOM(id, x, y) {
      const token = document.getElementById(`token-${id}`);
      if (!token) return;
      token.style.left = x;
      token.style.top = y;

      if (!isHost && state.tokens[id]) {
        state.tokens[id].x = x; state.tokens[id].y = y;
      }
    }

    function updateTokenPropDOM(id, prop, value) {
      const token = document.getElementById(`token-${id}`);
      if (!token) return;

      if (prop === 'locked') {
        token.dataset.locked = String(value);
        if (String(value) === "true") {
          token.classList.add('locked');
          token.style.pointerEvents = "none";
          token.classList.remove('selected');
          if (selectedToken && selectedToken.dataset.uuid === id) selectedToken = null;
        } else {
          token.classList.remove('locked');
          token.style.pointerEvents = "auto";
        }
      } else if (prop === 'innerZoom') {
        token.dataset.innerZoom = value;
        updateImgTransform(token);
      } else if (prop === 'rotation') {
        token.dataset.rotation = value;
        updateImgTransform(token);
      } else if (prop === 'flipped') {
        token.dataset.flipped = value;
        updateImgTransform(token);
      } else if (prop === 'size') {
        token.style.width = value.w + "px";
        token.style.height = value.h + "px";
        token.dataset.sizeW = value.w;
        token.dataset.sizeH = value.h;
      }

      if (!isHost && state.tokens[id]) {
        if (prop === "locked") state.tokens[id].locked = String(value);
        if (prop === "innerZoom") state.tokens[id].innerZoom = value;
        if (prop === "rotation") state.tokens[id].rotation = value;
        if (prop === "flipped") state.tokens[id].flipped = value;
        if (prop === "size") { state.tokens[id].w = value.w; state.tokens[id].h = value.h; }
      }

      updateSceneSizeEstimate();
    }

    function updateImgTransform(token) {
      const el = token.querySelector('img') || token.querySelector('iframe');
      if (!el) return;
      const rotation = token.dataset.rotation || 0;
      const flipped = token.dataset.flipped === "true";
      const innerZoom = token.dataset.innerZoom || 1;
      el.style.transform = `scale(${innerZoom}) rotate(${rotation}deg) scaleX(${flipped ? -1 : 1})`;
    }

    function selectToken(token) {
      if (token.dataset.locked === "true") return;
      if (selectedToken) selectedToken.classList.remove('selected');
      selectedToken = token;
      selectedToken.classList.add('selected');
    }

    function startDraggingToken(e, token) {
      let startX = e.clientX;
      let startY = e.clientY;
      let initialLeft = parseFloat(token.style.left);
      let initialTop = parseFloat(token.style.top);
      let hasMoved = false;

      function onMove(me) {
        hasMoved = true;
        let dx = (me.clientX - startX) / scale;
        let dy = (me.clientY - startY) / scale;
        let newX = initialLeft + dx;
        let newY = initialTop + dy;

        if (gridLayer.style.display !== 'none') {
          newX = Math.round(newX / 50) * 50;
          newY = Math.round(newY / 50) * 50;
        }

        token.style.left = newX + 'px';
        token.style.top = newY + 'px';
      }

      function onUp() {
        document.removeEventListener('mousemove', onMove);
        document.removeEventListener('mouseup', onUp);

        if (!hasMoved) return;

        const id = token.dataset.uuid;
        const x = token.style.left;
        const y = token.style.top;

        if (isHost) {
          const action = { type: "MOVE", id, x, y };
          applyAction(action, false);
          broadcastACT(action);
        } else {
          sendREQ({ type: "MOVE", id, x, y });
        }

        updateSceneSizeEstimate();
      }

      document.addEventListener('mousemove', onMove);
      document.addEventListener('mouseup', onUp);
    }

    function unlockEverything() {
      if (!isHost) return;
      document.querySelectorAll('.token.locked').forEach(t => {
        const id = t.dataset.uuid;
        const action = { type: "UPDATE_PROP", id, prop: "locked", value: "false" };
        applyAction(action, false);
        broadcastACT(action);
      });
      if (mapLocked) setMapLockLocal(false, true);
      updateSceneSizeEstimate();
    }

    window.lockToken = (e) => {
      e.stopPropagation();
      const token = e.target.closest('.token');
      const id = token.dataset.uuid;
      if (!isHost) return;

      const action = { type: "UPDATE_PROP", id, prop: "locked", value: "true" };
      applyAction(action, false);
      broadcastACT(action);
      updateSceneSizeEstimate();
    };

    window.zoomInnerToken = (e, delta) => {
      e.stopPropagation();
      const token = e.target.closest('.token');
      if (token.dataset.locked === "true") return;

      let currentZoom = parseFloat(token.dataset.innerZoom || 1);
      currentZoom = Math.max(0.2, Math.min(5, currentZoom + delta));

      if (isHost) {
        const action = { type: "UPDATE_PROP", id: token.dataset.uuid, prop: "innerZoom", value: currentZoom };
        applyAction(action, false);
        broadcastACT(action);
      } else {
        sendREQ({ type: "UPDATE_PROP", id: token.dataset.uuid, prop: "innerZoom", value: currentZoom });
      }
      updateSceneSizeEstimate();
    };

    window.flipToken = (token) => {
      if (!token || token.dataset.locked === "true") return;
      const newVal = token.dataset.flipped === "false" ? "true" : "false";

      if (isHost) {
        const action = { type: "UPDATE_PROP", id: token.dataset.uuid, prop: "flipped", value: newVal };
        applyAction(action, false);
        broadcastACT(action);
      } else {
        sendREQ({ type: "UPDATE_PROP", id: token.dataset.uuid, prop: "flipped", value: newVal });
      }
      updateSceneSizeEstimate();
    };

    window.rotateToken = (e, deg) => {
      e.stopPropagation();
      const token = e.target.closest('.token');
      if (!token || token.dataset.locked === "true") return;

      const newVal = (parseInt(token.dataset.rotation) + deg) % 360;

      if (isHost) {
        const action = { type: "UPDATE_PROP", id: token.dataset.uuid, prop: "rotation", value: newVal };
        applyAction(action, false);
        broadcastACT(action);
      } else {
        sendREQ({ type: "UPDATE_PROP", id: token.dataset.uuid, prop: "rotation", value: newVal });
      }
      updateSceneSizeEstimate();
    };

    window.deleteToken = (e) => {
      e.stopPropagation();
      const token = e.target.closest('.token');
      if (!token) return;
      const id = token.dataset.uuid;

      if (!isHost) return;
      const action = { type: "REMOVE_TOKEN", id };
      applyAction(action, false);
      broadcastACT(action);
      updateSceneSizeEstimate();
    };

    function resizeTokenDirect(token, amount, emit) {
      let w = parseInt(token.dataset.sizeW) + amount;
      w = Math.max(40, Math.min(w, 2500));
      let currentRatio = (parseInt(token.dataset.sizeH) / parseInt(token.dataset.sizeW));
      let h = w * currentRatio;

      const id = token.dataset.uuid;
      const action = { type: "UPDATE_PROP", id, prop: "size", value: { w: Math.round(w), h: Math.round(h) } };

      if (emit) {
        applyAction(action, false);
        broadcastACT(action);
      } else {
        updateTokenPropDOM(id, "size", action.value);
      }
      updateSceneSizeEstimate();
    }

    // =============== Teclas ===============
    window.addEventListener('keydown', (e) => {
      if (!selectedToken) return;
      if (selectedToken.dataset.locked === "true") return;

      if (e.key.toLowerCase() === 'f') flipToken(selectedToken);

      if (e.key === 'Delete') {
        if (!isHost) return;
        const id = selectedToken.dataset.uuid;
        const action = { type: "REMOVE_TOKEN", id };
        applyAction(action, false);
        broadcastACT(action);
        selectedToken = null;
        updateSceneSizeEstimate();
      }
    });

    viewport.addEventListener('mousedown', (e) => {
      if (e.target === viewport || e.target === canvas || e.target === gridLayer) {
        if (selectedToken) selectedToken.classList.remove('selected');
        selectedToken = null;
      }
    });

    // =============== Dados / Log (Host-only) ===============
    function rollDice(faces) {
      if (!isHost) return;
      const res = Math.floor(Math.random() * faces) + 1;
      const action = { type: "DICE", faces, result: res };
      applyAction(action, false);
      broadcastACT(action);
    }

    function showDiceLog(faces, res) {
      const entry = document.createElement('div');
      entry.className = "dice-entry mb-2 border-l-2 border-gold pl-3 opacity-0 transform translate-x-4 transition-all duration-300";
      entry.innerHTML = `<span class="opacity-50 text-[10px] font-bold">D${faces}:</span> <b class="text-white text-lg">${res}</b>`;
      diceLogEntries.prepend(entry);
      setTimeout(() => { entry.classList.remove('opacity-0', 'translate-x-4'); }, 10);
    }

    // =============== Clear (Host-only) ===============
    function clearTable(emit = true) {
      if (!isHost) return;
      if (emit && !confirm("Deseja limpar todos os tokens e o mapa?")) return;

      const action = { type: "CLEAR" };
      applyAction(action, false);
      broadcastACT(action);
      updateSceneSizeEstimate();
    }

    function clearTableLocal() {
      document.querySelectorAll('.token').forEach(t => t.remove());
      mapContainer.innerHTML = "";
      document.querySelectorAll('.dice-entry').forEach(l => l.remove());
      selectedToken = null;
      mapLocked = false;
      mapContainer.classList.remove('locked');
    }

    // ===============================
    // CENAS (SAVE/LOAD por ARQUIVO) + EMBUTIR + COMPRESS√ÉO + ESTIMATIVA
    // ===============================

    function byteLengthOfString(str) { return new Blob([str]).size; }

    function prettyBytes(bytes) {
      const units = ["B", "KB", "MB", "GB"];
      let i = 0;
      let num = bytes;
      while (num >= 1024 && i < units.length - 1) { num /= 1024; i++; }
      return `${num.toFixed(i === 0 ? 0 : 2)} ${units[i]}`;
    }

    function blobToDataURL(blob) {
      return new Promise((resolve, reject) => {
        const r = new FileReader();
        r.onload = () => resolve(r.result);
        r.onerror = reject;
        r.readAsDataURL(blob);
      });
    }

    async function tryFetchAsBlob(url) {
      try {
        const resp = await fetch(url, { mode: "cors" });
        if (!resp.ok) throw new Error("HTTP " + resp.status);
        const blob = await resp.blob();
        return blob;
      } catch {
        return null;
      }
    }

    async function tryFetchAsDataURL(url) {
      const blob = await tryFetchAsBlob(url);
      if (!blob) return null;
      if (!blob.type.startsWith("image/")) return null;
      return await blobToDataURL(blob);
    }

    async function compressBlobToWebP(blob, maxDim, quality) {
      try {
        const bmp = await createImageBitmap(blob);
        const w = bmp.width, h = bmp.height;

        const scale = Math.min(1, maxDim / Math.max(w, h));
        const nw = Math.max(1, Math.round(w * scale));
        const nh = Math.max(1, Math.round(h * scale));

        const c = document.createElement("canvas");
        c.width = nw;
        c.height = nh;
        const ctx = c.getContext("2d", { alpha: true });
        ctx.drawImage(bmp, 0, 0, nw, nh);

        const outBlob = await new Promise((resolve) => {
          c.toBlob((b) => resolve(b), "image/webp", quality);
        });

        if (!outBlob) return null;
        return await blobToDataURL(outBlob);
      } catch {
        return null;
      }
    }

    async function compressDataURLToWebP(dataUrl, maxDim, quality) {
      try {
        const resp = await fetch(dataUrl);
        const blob = await resp.blob();
        if (!blob.type.startsWith("image/")) return null;
        return await compressBlobToWebP(blob, maxDim, quality);
      } catch {
        return null;
      }
    }

    async function compressImageSrcIfPossible(src, maxDim, quality) {
      if (typeof src === "string" && src.startsWith("http")) {
        const blob = await tryFetchAsBlob(src);
        if (!blob || !blob.type.startsWith("image/")) return src;
        const webp = await compressBlobToWebP(blob, maxDim, quality);
        return webp || src;
      }
      if (typeof src === "string" && src.startsWith("data:image")) {
        const webp = await compressDataURLToWebP(src, maxDim, quality);
        return webp || src;
      }
      return src;
    }

    function estimatePayloadSizeBytes(payload) {
      try {
        const json = JSON.stringify(payload);
        return byteLengthOfString(json);
      } catch {
        return 0;
      }
    }

    function updateQualityLabel() {
      const q = document.getElementById("quality");
      const label = document.getElementById("quality-label");
      if (q && label) label.textContent = `Q ${Number(q.value).toFixed(2)}`;
    }

    function updateSceneSizeEstimate() {
      if (!isHost) return;
      const payload = {
        version: 3,
        savedAt: new Date().toISOString(),
        mapSrc: state.mapSrc || null,
        mapLocked: !!state.mapLocked,
        tokens: state.tokens || {}
      };
      const bytes = estimatePayloadSizeBytes(payload);
      const el = document.getElementById("scene-size");
      if (el) el.textContent = `~ ${prettyBytes(bytes)}`;
    }

    function initSceneUIHooks() {
      const q = document.getElementById("quality");
      const md = document.getElementById("max-dim");
      const ci = document.getElementById("compress-images");
      const er = document.getElementById("embed-remote");

      if (q) q.addEventListener("input", () => { updateQualityLabel(); });
      if (q) q.addEventListener("change", () => { updateSceneSizeEstimate(); });
      if (md) md.addEventListener("change", () => { updateSceneSizeEstimate(); });
      if (ci) ci.addEventListener("change", () => { updateSceneSizeEstimate(); });
      if (er) er.addEventListener("change", () => { updateSceneSizeEstimate(); });

      updateQualityLabel();
      updateSceneSizeEstimate();
    }

    async function buildScenePayloadSelfContained() {
      if (!isHost) return null;

      const embedRemote = !!document.getElementById("embed-remote")?.checked;
      const compress = !!document.getElementById("compress-images")?.checked;
      const maxDim = parseInt(document.getElementById("max-dim")?.value || "2048", 10);
      const quality = parseFloat(document.getElementById("quality")?.value || "0.75");

      const payload = {
        version: 3,
        savedAt: new Date().toISOString(),
        mapSrc: state.mapSrc || null,
        mapLocked: !!state.mapLocked,
        tokens: JSON.parse(JSON.stringify(state.tokens || {}))
      };

      // MAPA
      if (payload.mapSrc && typeof payload.mapSrc === "string") {
        if (embedRemote && payload.mapSrc.startsWith("http")) {
          const dataUrl = await tryFetchAsDataURL(payload.mapSrc);
          if (dataUrl) payload.mapSrc = dataUrl;
        }
        if (compress && (payload.mapSrc.startsWith("data:image") || payload.mapSrc.startsWith("http"))) {
          payload.mapSrc = await compressImageSrcIfPossible(payload.mapSrc, maxDim, quality);
        }
      }

      // TOKENS
      const ids = Object.keys(payload.tokens || {});
      for (const id of ids) {
        const t = payload.tokens[id];
        if (!t || !t.src) continue;

        // Embutir URL (se poss√≠vel)
        if (embedRemote && typeof t.src === "string" && t.src.startsWith("http")) {
          const dataUrl = await tryFetchAsDataURL(t.src);
          if (dataUrl) t.src = dataUrl;
        }

        // Comprimir s√≥ imagens
        if (compress && t.type === "image") {
          t.src = await compressImageSrcIfPossible(t.src, maxDim, quality);
        }
      }

      return payload;
    }

    function hostLoadScenePayload(payload) {
      if (!isHost) return;

      if (!payload || typeof payload !== "object") {
        alert("Arquivo de cena inv√°lido.");
        return;
      }

      const tokens = payload.tokens && typeof payload.tokens === "object" ? payload.tokens : {};
      const mapSrc = payload.mapSrc || null;
      const mapLockedVal = !!payload.mapLocked;

      // 1) Limpa
      const clearAction = { type: "CLEAR" };
      applyAction(clearAction, false);
      broadcastACT(clearAction);

      // 2) Mapa
      if (mapSrc) {
        const mapAction = { type: "MAP_UPDATE", src: mapSrc };
        applyAction(mapAction, false);
        broadcastACT(mapAction);
      }

      // 3) Trava do mapa
      const mapLockAction = { type: "MAP_LOCK", locked: mapLockedVal };
      applyAction(mapLockAction, false);
      broadcastACT(mapLockAction);

      // 4) Tokens
      Object.keys(tokens).forEach((id) => {
        const t = tokens[id];
        if (!t || !t.src || !t.type) return;

        const props = {
          x: t.x ?? "0px",
          y: t.y ?? "0px",
          w: t.w ?? 120,
          h: t.h ?? 120,
          rotation: t.rotation ?? 0,
          flipped: t.flipped ?? "false",
          innerZoom: t.innerZoom ?? 1,
          locked: t.locked ?? "false"
        };

        const createAction = {
          type: "CREATE_TOKEN",
          id,
          src: t.src,
          contentType: t.type,
          props
        };
        applyAction(createAction, false);
        broadcastACT(createAction);
      });

      showNotification("Cena carregada!");
      updateSceneSizeEstimate();
    }

    async function saveSceneToFile() {
      if (!isHost) return alert("Apenas o Host pode salvar cenas.");

      showNotification("Salvando (compactando)...");
      const payload = await buildScenePayloadSelfContained();
      if (!payload) return;

      const json = JSON.stringify(payload);
      const blob = new Blob([json], { type: "application/json" });

      const a = document.createElement("a");
      const ts = new Date().toISOString().replace(/[:.]/g, "-");
      a.href = URL.createObjectURL(blob);
      a.download = `cena-${ts}.json`;
      document.body.appendChild(a);
      a.click();
      a.remove();

      setTimeout(() => URL.revokeObjectURL(a.href), 1500);
      showNotification(`Cena salva (${prettyBytes(blob.size)})!`);
      updateSceneSizeEstimate();
    }

    function loadSceneFromFile(event) {
      if (!isHost) return alert("Apenas o Host pode carregar cenas.");
      const file = event.target.files?.[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = () => {
        try {
          const payload = JSON.parse(String(reader.result || "{}"));
          hostLoadScenePayload(payload);
        } catch (e) {
          alert("JSON inv√°lido.");
        }
        event.target.value = "";
      };
      reader.readAsText(file);
    }

    // =============== Start ===============
    window.addEventListener('contextmenu', (e) => e.preventDefault());

    initNetwork();
    setTimeout(() => { initSceneUIHooks(); }, 0);
  </script>
</body>
</html>
