<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>Tabletop Luxury - P2P (Fog de Vis√£o + Inspector grande + Layers din√¢micas)</title>

  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>

  <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Inter:wght@300;400;600&display=swap" rel="stylesheet">

  <style>
    :root{
      --gold:#c5a059;
      --dark-bg:#0f0f0f;
      --panel-bg:rgba(20,20,20,.92);
      --glass:rgba(255,255,255,.04);
      --status-online:#4ade80;
      --status-offline:#ef4444;
    }
    body{margin:0;overflow:hidden;background:var(--dark-bg);font-family:'Inter',sans-serif;color:#e0e0e0;}

    #viewport{width:100vw;height:100vh;overflow:hidden;position:relative;background:radial-gradient(circle,#1a1a1a 0%,#0a0a0a 100%);z-index:1;}
    #canvas-container{width:10000px;height:10000px;position:absolute;top:0;left:0;transform-origin:0 0;cursor:grab;z-index:2;}

    /* MAPA = layer 0 */
    #map-container{
      position:absolute;top:0;left:0;
      z-index:5;
      pointer-events:auto;
      transform: translate(0px,0px);
      transform-origin: 0 0;
    }
    #map-container.locked{pointer-events:none;}
    #map-container img{
      display:block;max-width:none;
      user-select:none;-webkit-user-drag:none;
      cursor:grab;
      filter: drop-shadow(0 0 25px rgba(0,0,0,.45));
    }
    #map-container.dragging img{cursor:grabbing;}

    .grid-layer{
      position:absolute;top:0;left:0;width:100%;height:100%;
      pointer-events:none;
      background-image:
        linear-gradient(to right, rgba(197,160,89,.05) 1px, transparent 1px),
        linear-gradient(to bottom, rgba(197,160,89,.05) 1px, transparent 1px);
      background-size:50px 50px;
      z-index:6;
    }

    /* FOG (sobre tudo, mas abaixo do HUD) */
    #fog-layer{
      position:absolute; inset:0;
      z-index:450; /* acima dos tokens (100+) */
      pointer-events:none;
      opacity:0;
      transition:opacity .25s ease;
    }
    #fog-layer.on{opacity:1;}
    /* A m√°scara real √© aplicada via style.background no JS */

    /* TOKENS */
    .token{
      position:absolute;
      cursor:move;
      user-select:none;
      display:flex;align-items:center;justify-content:center;
      background:transparent;
      overflow:visible;
      transition:filter .2s ease, outline .2s ease;
    }
    .token.locked{cursor:default!important;pointer-events:none;}
    .token.locked .token-controls,.token.locked .resize-handle{display:none!important;}

    .token-blocker{position:absolute;top:0;left:0;width:100%;height:100%;z-index:50;background:rgba(255,255,255,.001);}
    .token-content-wrapper{width:100%;height:100%;overflow:hidden;display:flex;align-items:center;justify-content:center;pointer-events:none;}

    .token iframe,.token img{
      width:100%;height:100%;border:none;background:transparent;pointer-events:none;
      object-fit:contain;
      transition:transform .2s ease-out;
    }

    .token.selected:not(.locked){
      filter:drop-shadow(0 0 15px var(--gold));
      outline:2px dashed rgba(197,160,89,.6);
      outline-offset:6px;
    }

    .resize-handle{
      position:absolute;width:18px;height:18px;background:var(--gold);
      border:2px solid #fff;border-radius:5px;display:none;z-index:110;
      cursor:nwse-resize;bottom:-9px;right:-9px;
    }
    .token.selected:not(.locked) .resize-handle{display:block;}

    /* Controles flutuantes maiores (ainda existem, mas agora √© ‚Äúbig‚Äù) */
    .token-controls{
      position:absolute;top:-78px;left:50%;transform:translateX(-50%);
      display:none;background:var(--panel-bg);backdrop-filter:blur(12px);
      border:1px solid rgba(197,160,89,.4);border-radius:999px;
      padding:10px 14px;gap:12px;z-index:200;
      box-shadow:0 4px 22px rgba(0,0,0,.55);
      white-space:nowrap;
    }
    .token.selected:not(.locked) .token-controls{display:flex;align-items:center;}
    .token-btn{
      color:#fff;font-size:18px;cursor:pointer;opacity:.9;transition:all .2s;
      display:flex;align-items:center;gap:6px;
    }
    .token-btn:hover{opacity:1;color:var(--gold);transform:scale(1.08);}

    /* HUD */
    .hud-element{transition:opacity .4s ease, transform .4s ease;}
    .hud-hidden .hud-element{opacity:0!important;pointer-events:none!important;transform:translateY(10px);}

    .sidebar{
      width:320px;background:var(--panel-bg);backdrop-filter:blur(15px);
      height:100vh;position:fixed;left:0;top:0;z-index:1000;
      border-right:1px solid rgba(197,160,89,.2);
      transform:translateX(-100%);
      transition:transform .4s cubic-bezier(.16,1,.3,1);
    }
    .sidebar.open{transform:translateX(0);}
    .toggle-sidebar-btn{
      position:absolute;right:-38px;top:20px;background:var(--panel-bg);
      border:1px solid rgba(197,160,89,.2);border-left:none;
      padding:12px 10px;border-radius:0 10px 10px 0;cursor:pointer;color:var(--gold);
      font-size:16px;
    }

    .controls-top{
      position:fixed;top:18px;left:50%;transform:translateX(-50%);
      display:flex;gap:10px;z-index:1000;background:var(--panel-bg);
      padding:10px;border-radius:999px;border:1px solid rgba(197,160,89,.2);
      backdrop-filter:blur(10px);box-shadow:0 6px 26px rgba(0,0,0,.45);
    }

    .btn-luxury{
      padding:10px 16px;border-radius:999px;font-size:12px;font-weight:700;
      text-transform:uppercase;letter-spacing:1px;transition:all .25s;
      border:1px solid transparent;color:#ccc;background:transparent;
    }
    .btn-luxury:hover,.btn-luxury.active{
      color:var(--gold);background:var(--glass);border-color:rgba(197,160,89,.45);
    }

    .dice-log{
      position:fixed;bottom:22px;right:22px;width:260px;max-height:220px;
      background:var(--panel-bg);border-radius:14px;border:1px solid rgba(197,160,89,.15);
      padding:16px;overflow-y:auto;font-size:13px;z-index:1000;
      box-shadow:0 6px 18px rgba(0,0,0,.35);
    }

    .btn-toggle-hud{
      position:fixed;bottom:22px;left:22px;z-index:2000;background:var(--panel-bg);
      width:48px;height:48px;border-radius:50%;
      display:flex;align-items:center;justify-content:center;
      border:1px solid rgba(197,160,89,.3);cursor:pointer;color:var(--gold);
      box-shadow:0 5px 12px rgba(0,0,0,.45);
      font-size:18px;
    }

    .url-field{
      background:rgba(0,0,0,.3);border:1px solid rgba(197,160,89,.2);color:#fff;
      width:100%;font-size:12px;padding:10px;margin-bottom:10px;outline:none;border-radius:10px;
    }
    .url-field:focus{border-color:var(--gold);background:rgba(0,0,0,.5);}

    h2,h3{font-family:'Cinzel',serif;letter-spacing:1px;color:var(--gold);}

    .network-status{
      position:fixed;top:78px;right:20px;display:flex;align-items:center;gap:10px;
      background:var(--panel-bg);padding:10px 16px;border-radius:999px;
      border:1px solid rgba(197,160,89,.2);font-size:11px;z-index:1000;
      backdrop-filter:blur(10px);
      opacity:0;pointer-events:none;transform:translateY(-10px);transition:all .3s;
    }
    .network-status.show{opacity:1;pointer-events:auto;transform:translateY(0);}

    .status-dot{width:9px;height:9px;border-radius:50%;background:var(--status-offline);box-shadow:0 0 6px currentColor;}
    .status-dot.online{background:var(--status-online);}

    .lock-manager{
      position:fixed;top:18px;right:20px;z-index:1000;display:flex;flex-direction:column;gap:10px;
    }

    #notification{
      position:fixed;top:50%;left:50%;transform:translate(-50%,-50%) scale(.92);
      background:rgba(0,0,0,.92);border:1px solid var(--gold);
      padding:20px 40px;border-radius:12px;z-index:9999;color:var(--gold);
      font-family:'Cinzel',serif;opacity:0;pointer-events:none;transition:all .25s;
    }
    #notification.active{opacity:1;transform:translate(-50%,-50%) scale(1);}

    #role-badge{
      position:fixed;top:138px;right:20px;z-index:1100;background:var(--panel-bg);
      border:1px solid rgba(197,160,89,.2);border-radius:999px;padding:8px 12px;
      font-size:11px;backdrop-filter:blur(10px);opacity:.95;
    }
    #role-badge b{color:var(--gold);}

    /* Inspector grande (melhor interface) */
    .inspector{
      position:fixed;top:178px;right:20px;z-index:1200;width:380px;max-height:70vh;
      background:var(--panel-bg);border:1px solid rgba(197,160,89,.2);
      border-radius:18px;padding:14px;backdrop-filter:blur(10px);
      box-shadow:0 12px 34px rgba(0,0,0,.5);
      display:none;overflow:auto;
    }
    .inspector.show{display:block;}
    .inspector h4{font-family:'Cinzel',serif;color:var(--gold);margin:0 0 10px 0;font-size:16px;}
    .inspector .row{display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-bottom:10px;}
    .inspector .block{background:rgba(255,255,255,.03);border:1px solid rgba(197,160,89,.18);border-radius:14px;padding:10px;}
    .inspector label{font-size:11px;opacity:.85;display:flex;justify-content:space-between;gap:10px;margin-bottom:6px;}
    .inspector input[type="range"]{width:100%;}
    .inspector input[type="number"], .inspector select{
      width:100%;padding:10px;border-radius:12px;border:1px solid rgba(197,160,89,.22);
      background:rgba(0,0,0,.35);color:#fff;outline:none;
    }
    .inspector .actions{display:flex;gap:10px;margin-top:8px;}
    .inspector .actions button{
      flex:1;padding:10px 12px;border-radius:14px;border:1px solid rgba(197,160,89,.25);
      background:rgba(255,255,255,.03);color:#ddd;font-weight:700;font-size:12px;cursor:pointer;
    }
    .inspector .actions button:hover{color:var(--gold);border-color:rgba(197,160,89,.55);background:rgba(255,255,255,.05);}
    .pill{
      font-size:11px;padding:8px 12px;border-radius:999px;border:1px solid rgba(197,160,89,.25);
      cursor:pointer;background:rgba(255,255,255,.03);color:#ddd;font-weight:700;
      display:inline-flex;align-items:center;justify-content:center;gap:8px;
    }
    .pill.active{color:var(--gold);border-color:rgba(197,160,89,.55);background:rgba(255,255,255,.05);}

    /* Layers panel */
    .layers-panel{
      position:fixed;top:86px;left:50%;transform:translateX(-50%);
      z-index:1200;min-width:380px;max-width:560px;
      background:var(--panel-bg);border:1px solid rgba(197,160,89,.2);
      border-radius:18px;padding:12px;backdrop-filter:blur(10px);
      box-shadow:0 12px 34px rgba(0,0,0,.5);
      display:none;
    }
    .layers-panel.show{display:block;}
    .layer-row{display:flex;align-items:center;justify-content:space-between;gap:10px;padding:10px 12px;border-radius:14px;background:rgba(255,255,255,.03);border:1px solid rgba(197,160,89,.12);margin-bottom:8px;}
    .layer-row b{color:var(--gold);}

    /* Scene + Network reused pill style */
    .mini{font-size:10px;opacity:.85;}

  </style>
</head>

<body>
  <div id="notification">OK</div>
  <div id="role-badge">Modo: <b id="role-text">...</b></div>

  <div class="btn-toggle-hud" onclick="toggleHUD()" title="Esconder/Mostrar Interface">üëÅÔ∏è</div>

  <div id="hud-root">
    <div class="controls-top hud-element">
      <button class="btn-luxury" id="btn-d20" onclick="rollDice(20)">D20</button>
      <button class="btn-luxury" id="btn-d6" onclick="rollDice(6)">D6</button>
      <button class="btn-luxury" onclick="toggleGrid()">Grelha</button>
      <button class="btn-luxury" id="btn-lock-all" onclick="unlockEverything()">üîì Destrancar</button>
      <button class="btn-luxury" id="btn-fog" onclick="toggleFog()">üå´Ô∏è Fog</button>
      <button class="btn-luxury" id="btn-layers" onclick="toggleLayersPanel()">üß± Camadas</button>
      <button class="btn-luxury" id="btn-inspector" onclick="toggleInspector()">üõ†Ô∏è Inspector</button>
      <button class="btn-luxury" onclick="toggleNetworkPanel()">üåê Rede</button>
    </div>

    <div class="lock-manager hud-element">
      <button class="btn-luxury bg-black/40 border-gold/20" id="btn-lock-map" onclick="toggleMapLock()">üîì Mapa M√≥vel</button>
    </div>

    <div class="network-status" id="network-panel">
      <div id="status-dot" class="status-dot"></div>
      <span id="status-text">Offline</span>
      <div class="h-4 w-px bg-white/20 mx-2"></div>
      <button class="btn-luxury py-0 px-2 text-[10px]" onclick="copyInviteLink()" id="btn-invite">üîó Copiar Convite</button>
    </div>

    <!-- Inspector (grande) -->
    <div class="inspector" id="inspector">
      <h4>Inspector</h4>
      <div class="mini" id="inspector-sub">Selecione um token.</div>

      <div class="row" style="margin-top:10px;">
        <div class="block">
          <label>Layer <span id="v-layer">-</span></label>
          <input type="number" id="i-layer" min="1" max="50" value="2" />
        </div>

        <div class="block">
          <label>Lock <span id="v-locked">-</span></label>
          <div style="display:flex;gap:10px;">
            <div class="pill" id="i-lock" onclick="inspectorToggleLock()">üîí Trancar</div>
            <div class="pill" id="i-unlock" onclick="inspectorUnlock()">üîì</div>
          </div>
        </div>
      </div>

      <div class="row">
        <div class="block">
          <label>Tamanho <span id="v-size">-</span></label>
          <input type="range" id="i-size" min="40" max="2500" value="160" />
        </div>
        <div class="block">
          <label>Rota√ß√£o <span id="v-rot">-</span></label>
          <input type="range" id="i-rot" min="0" max="359" value="0" />
        </div>
      </div>

      <div class="row">
        <div class="block">
          <label>Zoom interno <span id="v-zoom">-</span></label>
          <input type="range" id="i-zoom" min="0.2" max="5" step="0.05" value="1" />
        </div>
        <div class="block">
          <label>Fit <span id="v-fit">-</span></label>
          <select id="i-fit">
            <option value="contain">Contain</option>
            <option value="cover">Cover</option>
          </select>
        </div>
      </div>

      <div class="block" style="margin-bottom:10px;">
        <div style="display:flex;align-items:center;justify-content:space-between;gap:10px;">
          <div>
            <div style="font-family:'Cinzel',serif;color:var(--gold);font-weight:700;">Fog de Vis√£o</div>
            <div class="mini">Define raio para o token (em px do tabuleiro).</div>
          </div>
          <div class="pill" id="i-fog-assign" onclick="inspectorSetFogActive()">üéØ Usar como vis√£o</div>
        </div>
        <div style="margin-top:10px;">
          <label>Raio <span id="v-fog">-</span></label>
          <input type="range" id="i-fog" min="50" max="2500" step="10" value="600" />
        </div>
      </div>

      <div class="actions">
        <button onclick="inspectorBringFront()">‚¨ÜÔ∏è Frente</button>
        <button onclick="inspectorSendBack()">‚¨áÔ∏è Fundo</button>
      </div>

      <div class="actions">
        <button onclick="inspectorReset()">‚ôªÔ∏è Reset</button>
        <button style="color:#ff6b6b;border-color:rgba(255,107,107,.35);" onclick="inspectorDelete()">üóëÔ∏è Deletar</button>
      </div>
    </div>

    <!-- Camadas (din√¢micas; 0 = mapa; tokens criam layers conforme existem) -->
    <div class="layers-panel" id="layers-panel">
      <div style="display:flex;align-items:center;justify-content:space-between;gap:10px;margin-bottom:10px;">
        <div style="color: var(--gold); font-weight:700; font-family:'Cinzel',serif;">Camadas</div>
        <button class="btn-luxury py-0 px-2 text-[10px]" onclick="rebuildLayersPanel()">Atualizar</button>
      </div>
      <div class="mini" style="margin-bottom:10px;">Layer 0 √© o mapa. As outras aparecem conforme voc√™ adiciona elementos.</div>
      <div id="layers-list"></div>
    </div>

    <div class="sidebar hud-element" id="sidebar">
      <div class="toggle-sidebar-btn" onclick="toggleSidebar()">‚ò∞</div>
      <div class="p-6 overflow-y-auto h-full">
        <h2 class="text-xl font-bold mb-6 border-b border-gold/30 pb-3">Atelier P2P</h2>

        <div class="mb-8" id="host-only-map">
          <h3 class="text-xs font-semibold uppercase mb-4 opacity-70">Mapa (Layer 0)</h3>
          <div class="bg-black/40 p-4 border border-dashed border-gold/30 rounded-xl">
            <input type="file" id="map-file" accept="image/*" class="hidden" onchange="importAsset(event, 'map')">
            <label for="map-file" class="btn-luxury block text-center mb-3 cursor-pointer bg-white/5">Ficheiro Local</label>
            <input type="text" id="map-url" class="url-field" placeholder="https://link-do-mapa.jpg">
            <button class="btn-luxury w-full border border-gold/30" onclick="importFromUrl('map-url', 'map')">Definir Mapa</button>
          </div>
        </div>

        <div class="mb-8" id="host-only-players">
          <h3 class="text-xs font-semibold uppercase mb-4 opacity-70">Players</h3>
          <div class="bg-black/40 p-4 border border-dashed border-gold/30 rounded-xl">
            <input type="file" id="player-file" accept="image/*" class="hidden" onchange="importAsset(event, 'player')">
            <label for="player-file" class="btn-luxury block text-center mb-3 cursor-pointer bg-white/5">Ficheiro Local</label>
            <input type="text" id="player-url" class="url-field" placeholder="URL Imagem...">
            <button class="btn-luxury w-full border border-gold/30" onclick="importFromUrl('player-url', 'player')">Adicionar Player</button>
          </div>
          <div class="mini" style="margin-top:8px;">Por padr√£o: primeira layer criada ser√° 1 (tokens).</div>
        </div>

        <div class="mb-8" id="host-only-assets">
          <h3 class="text-xs font-semibold uppercase mb-4 opacity-70">Assets</h3>
          <div class="bg-black/40 p-4 border border-dashed border-gold/30 rounded-xl">
            <input type="file" id="asset-file" accept="image/*" class="hidden" onchange="importAsset(event, 'asset')">
            <label for="asset-file" class="btn-luxury block text-center mb-3 cursor-pointer bg-white/5">Ficheiro Local</label>
            <input type="text" id="asset-url" class="url-field" placeholder="URL Imagem...">
            <button class="btn-luxury w-full border border-gold/30" onclick="importFromUrl('asset-url', 'asset')">Adicionar Asset</button>
          </div>
        </div>

        <div class="mt-auto pt-6 border-t border-gold/20" id="host-only-clear">
          <button class="btn-luxury w-full text-red-500 border-red-900/30 hover:bg-red-900/20" onclick="clearTable()">Limpar Mesa</button>
        </div>

        <div class="mt-6 text-[10px] opacity-50 leading-relaxed">
          <div><b>Status:</b> <span id="tiny-status">iniciando...</span></div>
          <div><b>Sala:</b> <span id="tiny-room">-</span></div>
        </div>
      </div>
    </div>

    <div class="dice-log hud-element" id="dice-log">
      <div id="dice-entries">
        <div class="text-[11px] opacity-40 mb-3 uppercase tracking-tighter">Hist√≥rico</div>
      </div>
    </div>
  </div>

  <div id="viewport">
    <div id="canvas-container">
      <div id="map-container"></div>
      <div id="grid-layer" class="grid-layer"></div>
      <div id="fog-layer"></div>
    </div>
  </div>

  <script>
    /********************************************************************
     * ‚úÖ Novos pedidos
     * 1) Fog de vis√£o por token (raio configur√°vel) + escolher qual token √© a vis√£o ativa.
     * 2) Interface melhor: Inspector grande com sliders e bot√µes grandes.
     * 3) Layers: 0 s√≥ mapa; outras layers aparecem conforme existirem tokens.
     * 4) Otimiza√ß√£o: menos rebuilds, updates de UI com throttle, fog com RAF.
     ********************************************************************/

    // ========= UTIL =========
    const generateUUID = () => Date.now().toString(36) + Math.random().toString(36).slice(2);
    const clamp = (v,min,max)=>Math.max(min,Math.min(max,v));

    function showNotification(msg){
      const n=document.getElementById('notification');
      n.innerText=msg;
      n.classList.add('active');
      setTimeout(()=>n.classList.remove('active'),1800);
    }

    // ========= ELEMENTOS =========
    const canvas = document.getElementById('canvas-container');
    const viewport = document.getElementById('viewport');
    const mapContainer = document.getElementById('map-container');
    const gridLayer = document.getElementById('grid-layer');
    const sidebar = document.getElementById('sidebar');
    const diceLogEntries = document.getElementById('dice-entries');
    const fogLayer = document.getElementById('fog-layer');

    const statusDot = document.getElementById('status-dot');
    const statusText = document.getElementById('status-text');
    const networkPanel = document.getElementById('network-panel');

    const roleText = document.getElementById('role-text');
    const tinyStatus = document.getElementById('tiny-status');
    const tinyRoom = document.getElementById('tiny-room');

    const hostOnlyMap = document.getElementById('host-only-map');
    const hostOnlyPlayers = document.getElementById('host-only-players');
    const hostOnlyAssets = document.getElementById('host-only-assets');
    const hostOnlyClear = document.getElementById('host-only-clear');

    const btnLockAll = document.getElementById('btn-lock-all');
    const btnLockMap = document.getElementById('btn-lock-map');
    const btnInvite = document.getElementById('btn-invite');
    const btnD20 = document.getElementById('btn-d20');
    const btnD6 = document.getElementById('btn-d6');
    const btnFog = document.getElementById('btn-fog');
    const btnLayers = document.getElementById('btn-layers');
    const btnInspector = document.getElementById('btn-inspector');

    const layersPanel = document.getElementById('layers-panel');
    const layersList = document.getElementById('layers-list');

    const inspector = document.getElementById('inspector');
    const inspectorSub = document.getElementById('inspector-sub');

    // inspector values
    const iLayer = document.getElementById('i-layer');
    const iSize  = document.getElementById('i-size');
    const iRot   = document.getElementById('i-rot');
    const iZoom  = document.getElementById('i-zoom');
    const iFit   = document.getElementById('i-fit');
    const iFog   = document.getElementById('i-fog');

    const vLayer = document.getElementById('v-layer');
    const vLocked= document.getElementById('v-locked');
    const vSize  = document.getElementById('v-size');
    const vRot   = document.getElementById('v-rot');
    const vZoom  = document.getElementById('v-zoom');
    const vFit   = document.getElementById('v-fit');
    const vFog   = document.getElementById('v-fog');

    // ========= CAMERA =========
    let scale = 1;
    let posX = window.innerWidth/2 - 5000;
    let posY = window.innerHeight/2 - 5000;
    let isPanning=false;
    let startPan={x:0,y:0};

    function updateTransform(){ canvas.style.transform = `translate(${posX}px, ${posY}px) scale(${scale})`; }
    updateTransform();

    // ========= SELE√á√ÉO =========
    let selectedToken = null;

    // ========= REDE =========
    let peer, connections=[], hostConnection=null;
    let myId=null;
    let isHost=false;

    const PEER_ICE_CONFIG = {
      iceServers: [
        { urls: "stun:stun.l.google.com:19302" },
        { urls: "stun:stun1.l.google.com:19302" },
        { urls: "stun:global.stun.twilio.com:3478" }
      ]
    };

    // ========= STATE (host autoritativo) =========
    const state = {
      map: { src:null, locked:false, x:0, y:0 },   // layer 0
      tokens: {},                                   // layers >= 1
      fog: {
        enabled: false,
        activeTokenId: null, // token que revela
        softness: 0.18,      // borda suave
        darkness: 0.88       // escuro
      }
    };

    // ========= LAYERS =========
    // 0 √© mapa (sempre), tokens >= 1.
    // layers aparecem dinamicamente conforme existem tokens naquela layer.
    const layerState = {
      visible: {}, // layer -> bool
      locked: {},  // layer -> bool
    };
    function ensureLayerDefaults(layer){
      if (layer == null) return;
      if (!(layer in layerState.visible)) layerState.visible[layer] = true;
      if (!(layer in layerState.locked)) layerState.locked[layer] = false;
    }
    function computeTokenZIndex(layer){
      // mapa 5, grid 6, tokens 100+ (por layer)
      const base = 100;
      const l = Number(layer || 1);
      return base + l * 10;
    }
    function applyLayerVisibilityToDOM(){
      for (const el of document.querySelectorAll('.token')){
        const layer = Number(el.dataset.layer || 1);
        ensureLayerDefaults(layer);
        el.style.display = layerState.visible[layer] ? "" : "none";
      }
    }

    // ========= FOG =========
    let fogRAF = null;
    function toggleFog(){
      if (!isHost) return alert("Apenas o Host controla o Fog.");
      const a = { type:"FOG_SET", prop:"enabled", value: !state.fog.enabled };
      applyAction(a,false); broadcastACT(a);
      showNotification(state.fog.enabled ? "Fog ON" : "Fog OFF");
    }

    function requestFogRedraw(){
      if (fogRAF) return;
      fogRAF = requestAnimationFrame(()=>{
        fogRAF = null;
        drawFog();
      });
    }

    function tokenCenterBoardPx(tokenEl){
      // centro em coordenadas do tabuleiro (px no canvas)
      const x = parseFloat(tokenEl.style.left) + (parseFloat(tokenEl.style.width)/2);
      const y = parseFloat(tokenEl.style.top)  + (parseFloat(tokenEl.style.height)/2);
      return {x,y};
    }

    function drawFog(){
      if (!state.fog.enabled){
        fogLayer.classList.remove('on');
        fogLayer.style.background = "transparent";
        return;
      }

      fogLayer.classList.add('on');

      const tid = state.fog.activeTokenId;
      if (!tid){
        // Sem token ativo: tudo escuro
        const alpha = clamp(state.fog.darkness, 0.1, 0.98);
        fogLayer.style.background = `rgba(0,0,0,${alpha})`;
        return;
      }

      const tokenEl = document.getElementById(`token-${tid}`);
      if (!tokenEl || tokenEl.style.display === "none"){
        const alpha = clamp(state.fog.darkness, 0.1, 0.98);
        fogLayer.style.background = `rgba(0,0,0,${alpha})`;
        return;
      }

      const {x,y} = tokenCenterBoardPx(tokenEl);

      // Raio vem do token (visionRadius), com fallback
      const radius = clamp(Number(tokenEl.dataset.visionRadius || 600), 50, 6000);
      const softness = clamp(Number(state.fog.softness||0.18), 0.02, 0.6);
      const alpha = clamp(Number(state.fog.darkness||0.88), 0.1, 0.98);

      // Borda suave: um anel antes do escuro total
      const inner = Math.max(0, radius * (1 - softness));
      const outer = radius;

      // A t√©cnica: radial-gradient posicionado em px do canvas.
      // (Como o fog-layer est√° dentro do canvas-container, ele escala junto com o tabuleiro.)
      fogLayer.style.background = `
        radial-gradient(circle at ${x}px ${y}px,
          rgba(0,0,0,0) 0px,
          rgba(0,0,0,0) ${inner}px,
          rgba(0,0,0,${alpha}) ${outer}px,
          rgba(0,0,0,${alpha}) 100%)
      `;
    }

    // ========= UI HELPERS =========
    function toggleHUD(){ document.body.classList.toggle('hud-hidden'); }
    function toggleSidebar(){ sidebar.classList.toggle('open'); }
    function toggleGrid(){ gridLayer.style.display = (gridLayer.style.display === 'none') ? 'block' : 'none'; }
    function toggleNetworkPanel(){ networkPanel.classList.toggle('show'); }

    function toggleLayersPanel(){
      if (!isHost) return alert("Apenas o Host gerencia camadas.");
      layersPanel.classList.toggle('show');
      rebuildLayersPanel();
    }

    function toggleInspector(){
      if (!isHost) return; // player n√£o precisa de inspector completo
      inspector.classList.toggle('show');
      syncInspectorFromSelection();
    }

    function setRoleUI(){
      roleText.textContent = isHost ? "HOST (Mestre)" : "PLAYER";

      hostOnlyMap.style.display = isHost ? "" : "none";
      hostOnlyPlayers.style.display = isHost ? "" : "none";
      hostOnlyAssets.style.display = isHost ? "" : "none";
      hostOnlyClear.style.display = isHost ? "" : "none";

      btnLockAll.style.display = isHost ? "" : "none";
      btnLockMap.style.display = isHost ? "" : "none";
      btnInvite.style.display = isHost ? "" : "none";
      btnD20.style.display = isHost ? "" : "none";
      btnD6.style.display = isHost ? "" : "none";
      btnFog.style.display = isHost ? "" : "none";
      btnLayers.style.display = isHost ? "" : "none";
      btnInspector.style.display = isHost ? "" : "none";
      inspector.style.display = isHost ? "" : "none";
    }

    // ========= INVITE =========
    function copyInviteLink(){
      if (!myId) return alert("Aguarde a conex√£o...");
      if (!isHost) return alert("Apenas o Host copia convite.");
      const u = new URL(window.location.href);
      u.searchParams.set('room', myId);
      const invite = u.toString();

      if (navigator.clipboard?.writeText){
        navigator.clipboard.writeText(invite).then(()=>showNotification("Link copiado!")).catch(()=>prompt("Copie:", invite));
      } else prompt("Copie:", invite);
    }

    // ========= PAN/ZOOM =========
    viewport.addEventListener('wheel',(e)=>{
      if (e.ctrlKey) return;
      e.preventDefault();
      const zoomSpeed=.15;
      const delta = e.deltaY>0 ? -zoomSpeed : zoomSpeed;
      const newScale = clamp(scale+delta, .05, 4);

      const mx=e.clientX,my=e.clientY;
      const cx=(mx-posX)/scale, cy=(my-posY)/scale;

      scale = newScale;
      posX = mx - cx*scale;
      posY = my - cy*scale;
      updateTransform();
    },{passive:false});

    window.addEventListener('mousedown',(e)=>{
      if (e.button===2 || e.button===1 || (e.button===0 && e.altKey)){
        isPanning=true;
        startPan={x:e.clientX-posX,y:e.clientY-posY};
        viewport.style.cursor='grabbing';
      }
    });
    window.addEventListener('mousemove',(e)=>{
      if (isPanning){
        posX=e.clientX-startPan.x;
        posY=e.clientY-startPan.y;
        updateTransform();
      }
    });
    window.addEventListener('mouseup',()=>{ isPanning=false; viewport.style.cursor='grab'; });

    // ========= MAPA palp√°vel com in√©rcia =========
    let mapDragging=false;
    let mapDragStart={mx:0,my:0,x:0,y:0};
    let mapVel={vx:0,vy:0};
    let mapLastMove={t:0,x:0,y:0};
    let mapInertiaRAF=null;

    function setMapOffset(x,y){
      state.map.x = x;
      state.map.y = y;
      mapContainer.style.transform = `translate(${x}px, ${y}px)`;
      if (state.fog.enabled) requestFogRedraw();
    }

    function stopMapInertia(){
      if (mapInertiaRAF) cancelAnimationFrame(mapInertiaRAF);
      mapInertiaRAF=null;
    }

    function startMapInertia(){
      stopMapInertia();
      const friction=0.92, minV=0.05;

      const step=()=>{
        mapVel.vx*=friction;
        mapVel.vy*=friction;

        if (Math.abs(mapVel.vx)<minV && Math.abs(mapVel.vy)<minV){
          mapVel.vx=0; mapVel.vy=0;
          stopMapInertia();
          if (isHost){
            const a={type:"MAP_MOVE", x:state.map.x, y:state.map.y};
            applyAction(a,false); broadcastACT(a);
          }
          return;
        }

        setMapOffset(state.map.x + mapVel.vx, state.map.y + mapVel.vy);
        mapInertiaRAF=requestAnimationFrame(step);
      };
      mapInertiaRAF=requestAnimationFrame(step);
    }

    function setMapLockLocal(lock, emit){
      state.map.locked = !!lock;
      mapContainer.classList.toggle('locked', state.map.locked);
      if (state.map.locked){
        btnLockMap.innerHTML="üîí Mapa Fixo"; btnLockMap.classList.add('active');
      } else {
        btnLockMap.innerHTML="üîì Mapa M√≥vel"; btnLockMap.classList.remove('active');
      }
      if (emit && isHost){
        const a={type:"MAP_LOCK", locked:state.map.locked};
        applyAction(a,false); broadcastACT(a);
      }
    }

    function toggleMapLock(){
      if (!isHost) return;
      setMapLockLocal(!state.map.locked,true);
    }

    mapContainer.addEventListener('mousedown',(e)=>{
      if (!isHost) return;
      if (state.map.locked) return;
      const img = mapContainer.querySelector('img');
      if (!img) return;

      if (e.button!==0 || e.altKey) return;
      e.preventDefault();
      e.stopPropagation();

      mapDragging=true;
      mapContainer.classList.add('dragging');
      stopMapInertia();

      mapDragStart={mx:e.clientX,my:e.clientY,x:state.map.x,y:state.map.y};
      mapVel={vx:0,vy:0};
      mapLastMove={t:performance.now(), x:state.map.x, y:state.map.y};

      const onMove=(me)=>{
        if (!mapDragging) return;
        const dx=(me.clientX-mapDragStart.mx)/scale;
        const dy=(me.clientY-mapDragStart.my)/scale;

        const nx=mapDragStart.x+dx;
        const ny=mapDragStart.y+dy;
        setMapOffset(nx,ny);

        const now=performance.now();
        const dt=Math.max(1, now-mapLastMove.t);
        mapVel.vx=(nx-mapLastMove.x)/dt*16;
        mapVel.vy=(ny-mapLastMove.y)/dt*16;
        mapLastMove={t:now,x:nx,y:ny};
      };

      const onUp=()=>{
        mapDragging=false;
        mapContainer.classList.remove('dragging');
        document.removeEventListener('mousemove',onMove);
        document.removeEventListener('mouseup',onUp);

        const a={type:"MAP_MOVE", x:state.map.x, y:state.map.y};
        applyAction(a,false); broadcastACT(a);

        startMapInertia();
      };

      document.addEventListener('mousemove',onMove);
      document.addEventListener('mouseup',onUp);
    });

    function applyMapLocal(src, emit){
      const img=new Image();
      img.onload=()=>{
        mapContainer.innerHTML="";
        mapContainer.appendChild(img);

        scale = Math.min(window.innerWidth / img.width, window.innerHeight / img.height, 1) * 0.8;
        posX = window.innerWidth/2 - (img.width*scale)/2;
        posY = window.innerHeight/2 - (img.height*scale)/2;
        updateTransform();

        setMapOffset(state.map.x||0, state.map.y||0);
      };
      img.src=src;

      if (emit && isHost){
        const a={type:"MAP_UPDATE", src};
        applyAction(a,false); broadcastACT(a);
      }
    }

    // ========= TOKENS =========
    function normalizeTokenProps(id, src, type, props){
      const p=props||{};
      const layer = Number(p.layer ?? 1);
      ensureLayerDefaults(layer);
      return {
        id, src, type,
        kind: p.kind ?? "asset",
        layer,
        x: p.x ?? "0px",
        y: p.y ?? "0px",
        w: p.w ?? 160,
        h: p.h ?? 160,
        rotation: p.rotation ?? 0,
        flipped: p.flipped ?? "false",
        innerZoom: p.innerZoom ?? 1,
        locked: p.locked ?? "false",
        fitMode: p.fitMode ?? "contain",
        visionRadius: p.visionRadius ?? 600
      };
    }

    function nextAutoLayer(){
      // layers din√¢micas: pega maior layer existente e usa 1 se vazio.
      const layers = Object.values(state.tokens).map(t=>Number(t.layer||1));
      const max = layers.length ? Math.max(...layers) : 0;
      return Math.max(1, max); // n√£o cria ‚Äúsempre um novo‚Äù; usa √∫ltima por padr√£o
    }

    function hostCreateToken(src, contentType, kind){
      if (!isHost) return;

      const id = generateUUID();

      let width = (contentType==="web") ? 420 : 180;
      let height= (contentType==="web") ? 240 : 180;

      const layerDefault = nextAutoLayer(); // din√¢mica (aparece conforme existir)
      ensureLayerDefaults(layerDefault);

      const centerX = (window.innerWidth/2 - posX)/scale;
      const centerY = (window.innerHeight/2 - posY)/scale;

      const props = {
        kind,
        layer: layerDefault,
        x: (centerX - width/2) + "px",
        y: (centerY - height/2) + "px",
        w: width,
        h: height,
        rotation: 0,
        flipped: "false",
        innerZoom: 1,
        locked: "false",
        fitMode: "contain",
        visionRadius: 600
      };

      const a = { type:"CREATE_TOKEN", id, src, contentType, props };
      applyAction(a,false); broadcastACT(a);
      rebuildLayersPanel();
      applyLayerVisibilityToDOM();
      requestFogRedraw();
    }

    function addTokenLocal(src, contentType, id, props){
      if (document.getElementById(`token-${id}`)) return;

      const token=document.createElement('div');
      token.id=`token-${id}`;
      token.className="token";
      token.dataset.uuid=id;
      token.dataset.type=contentType;

      const layer = Number(props?.layer ?? 1);
      const kind = props?.kind ?? "asset";
      ensureLayerDefaults(layer);

      token.dataset.layer = String(layer);
      token.dataset.kind = kind;

      const width = props?.w ? parseInt(props.w) : (contentType==="web"?420:180);
      const height= props?.h ? parseInt(props.h) : (contentType==="web"?240:180);
      token.style.width = width+"px";
      token.style.height= height+"px";

      token.style.left = props?.x ?? "0px";
      token.style.top  = props?.y ?? "0px";

      token.dataset.sizeW = width;
      token.dataset.sizeH = height;
      token.dataset.rotation = props?.rotation ?? 0;
      token.dataset.flipped  = props?.flipped ?? "false";
      token.dataset.innerZoom= props?.innerZoom ?? 1;
      token.dataset.locked   = props?.locked ?? "false";
      token.dataset.fitMode  = props?.fitMode ?? "contain";
      token.dataset.visionRadius = props?.visionRadius ?? 600;

      token.style.zIndex = String(computeTokenZIndex(layer));
      token.style.display = layerState.visible[layer] ? "" : "none";

      if (token.dataset.locked==="true"){
        token.classList.add('locked');
        token.style.pointerEvents="none";
      }

      const blocker=document.createElement('div');
      blocker.className="token-blocker";

      const wrapper=document.createElement('div');
      wrapper.className="token-content-wrapper";

      let content;
      if (contentType==="image"){
        content=document.createElement('img');
        content.src=src;
      } else {
        content=document.createElement('iframe');
        content.src=src;
        content.setAttribute('frameborder','0');
        content.setAttribute('sandbox','allow-scripts allow-same-origin');
      }

      const handle=document.createElement('div');
      handle.className="resize-handle";

      const controls=document.createElement('div');
      controls.className="token-controls";
      controls.innerHTML = `
        <span class="token-btn" title="Layer -" onclick="layerToken(event, -1)">üß±‚ûñ</span>
        <span class="token-btn" title="Layer +" onclick="layerToken(event, 1)">üß±‚ûï</span>
        <span class="token-btn" title="Tamanho -" onclick="scaleToken(event, -50)">üìè‚ûñ</span>
        <span class="token-btn" title="Tamanho +" onclick="scaleToken(event, 50)">üìè‚ûï</span>
        <span class="token-btn" title="Zoom -" onclick="zoomInnerToken(event, -0.1)">‚ûñ</span>
        <span class="token-btn" title="Zoom +" onclick="zoomInnerToken(event, 0.1)">‚ûï</span>
        <span class="token-btn" title="Fit" onclick="fitToken(event)">üß©</span>
        <span class="token-btn" title="Reset" onclick="resetToken(event)">‚ôªÔ∏è</span>
        <span class="token-btn" title="Espelhar (F)" onclick="flipToken(this.closest('.token'))">‚ÜîÔ∏è</span>
        <span class="token-btn" title="Girar 45¬∞" onclick="rotateToken(event, 45)">üîÑ</span>
        <span class="token-btn" title="Trancar" onclick="lockToken(event)">üîí</span>
        <span class="token-btn text-red-400" title="Eliminar" onclick="deleteToken(event)">üóëÔ∏è</span>
      `;

      wrapper.appendChild(content);
      token.appendChild(blocker);
      token.appendChild(wrapper);
      token.appendChild(handle);
      token.appendChild(controls);

      canvas.appendChild(token);

      setTimeout(()=>updateImgTransform(token), 0);

      // Ctrl+wheel = resize
      token.addEventListener('wheel',(e)=>{
        if (!e.ctrlKey) return;
        if (token.dataset.locked==="true") return;
        if (layerState.locked[Number(token.dataset.layer||1)]) return;
        e.preventDefault(); e.stopPropagation();

        const delta = e.deltaY>0 ? -25 : 25;
        const w0=parseInt(token.dataset.sizeW), h0=parseInt(token.dataset.sizeH);
        const ratio=h0/w0;
        const w=clamp(w0+delta, 40, 2500);
        const h=clamp(Math.round(w*ratio), 40, 2500);

        const action={type:"UPDATE_PROP", id:token.dataset.uuid, prop:"size", value:{w,h}};
        if (isHost){ applyAction(action,false); broadcastACT(action); }
        else sendREQ(action);
      },{passive:false});

      // Resize handle
      handle.addEventListener('mousedown',(e)=>{
        if (token.dataset.locked==="true") return;
        if (layerState.locked[Number(token.dataset.layer||1)]) return;
        if (e.button!==0) return;
        e.stopPropagation(); e.preventDefault();

        const startX=e.clientX;
        const startW=parseInt(token.dataset.sizeW);
        const startH=parseInt(token.dataset.sizeH);
        const ratio=startH/startW;

        let pendingW=startW, pendingH=startH;

        const onMove=(me)=>{
          const deltaW=((me.clientX-startX)/scale)*1.5;
          let w=clamp(startW+deltaW, 40, 2500);
          let h=clamp(Math.round(w*ratio), 40, 2500);

          pendingW=w; pendingH=h;
          token.dataset.sizeW=pendingW;
          token.dataset.sizeH=pendingH;
          token.style.width=pendingW+"px";
          token.style.height=pendingH+"px";
          if (state.fog.enabled) requestFogRedraw();
        };

        const onUp=()=>{
          document.removeEventListener('mousemove',onMove);
          document.removeEventListener('mouseup',onUp);
          const action={type:"UPDATE_PROP", id:token.dataset.uuid, prop:"size", value:{w:pendingW,h:pendingH}};
          if (isHost){ applyAction(action,false); broadcastACT(action); }
          else sendREQ(action);
        };

        document.addEventListener('mousemove',onMove);
        document.addEventListener('mouseup',onUp);
      });

      // Drag
      token.addEventListener('mousedown',(e)=>{
        if (e.button!==0 || e.altKey) return;
        if (token.dataset.locked==="true") return;
        if (layerState.locked[Number(token.dataset.layer||1)]) return;
        e.stopPropagation();
        selectToken(token);
        startDraggingToken(e, token);
      });
    }

    function updateImgTransform(token){
      const el = token.querySelector('img') || token.querySelector('iframe');
      if (!el) return;

      if (el.tagName==="IMG"){
        el.style.objectFit = token.dataset.fitMode || "contain";
      }
      const rotation = token.dataset.rotation || 0;
      const flipped = token.dataset.flipped === "true";
      const innerZoom= token.dataset.innerZoom || 1;
      el.style.transform = `scale(${innerZoom}) rotate(${rotation}deg) scaleX(${flipped?-1:1})`;
    }

    function selectToken(token){
      if (selectedToken) selectedToken.classList.remove('selected');
      selectedToken = token;
      selectedToken.classList.add('selected');
      syncInspectorFromSelection();
      if (state.fog.enabled) requestFogRedraw();
    }

    function startDraggingToken(e, token){
      const startX=e.clientX, startY=e.clientY;
      const initialLeft=parseFloat(token.style.left);
      const initialTop=parseFloat(token.style.top);
      let moved=false;

      const onMove=(me)=>{
        moved=true;
        let dx=(me.clientX-startX)/scale;
        let dy=(me.clientY-startY)/scale;
        let newX=initialLeft+dx;
        let newY=initialTop+dy;
        if (gridLayer.style.display !== 'none'){
          newX=Math.round(newX/50)*50;
          newY=Math.round(newY/50)*50;
        }
        token.style.left=newX+"px";
        token.style.top=newY+"px";
        if (state.fog.enabled && token.dataset.uuid === state.fog.activeTokenId) requestFogRedraw();
      };

      const onUp=()=>{
        document.removeEventListener('mousemove',onMove);
        document.removeEventListener('mouseup',onUp);
        if (!moved) return;

        const action={type:"MOVE", id:token.dataset.uuid, x:token.style.left, y:token.style.top};
        if (isHost){ applyAction(action,false); broadcastACT(action); }
        else sendREQ(action);
      };

      document.addEventListener('mousemove',onMove);
      document.addEventListener('mouseup',onUp);
    }

    function moveTokenDOM(id,x,y){
      const t=document.getElementById(`token-${id}`);
      if (!t) return;
      t.style.left=x;
      t.style.top=y;
      if (state.fog.enabled && id === state.fog.activeTokenId) requestFogRedraw();
    }

    function updateTokenPropDOM(id, prop, value){
      const token=document.getElementById(`token-${id}`);
      if (!token) return;

      if (prop==="locked"){
        token.dataset.locked = String(value);
        if (String(value)==="true"){
          token.classList.add('locked');
          token.style.pointerEvents="none";
          token.classList.remove('selected');
          if (selectedToken?.dataset.uuid===id) selectedToken=null;
        } else {
          token.classList.remove('locked');
          token.style.pointerEvents="auto";
        }
      } else if (prop==="innerZoom"){
        token.dataset.innerZoom = value;
        updateImgTransform(token);
      } else if (prop==="rotation"){
        token.dataset.rotation = value;
        updateImgTransform(token);
      } else if (prop==="flipped"){
        token.dataset.flipped = value;
        updateImgTransform(token);
      } else if (prop==="fitMode"){
        token.dataset.fitMode = value;
        updateImgTransform(token);
      } else if (prop==="size"){
        token.style.width=value.w+"px";
        token.style.height=value.h+"px";
        token.dataset.sizeW=value.w;
        token.dataset.sizeH=value.h;
      } else if (prop==="layer"){
        const newLayer=Number(value);
        ensureLayerDefaults(newLayer);
        token.dataset.layer=String(newLayer);
        token.style.zIndex=String(computeTokenZIndex(newLayer));
        token.style.display = layerState.visible[newLayer] ? "" : "none";
      } else if (prop==="visionRadius"){
        token.dataset.visionRadius = Number(value);
      }

      if (state.fog.enabled) requestFogRedraw();
      syncInspectorFromSelection();
    }

    function removeTokenLocal(id){
      const t=document.getElementById(`token-${id}`);
      if (t) t.remove();
      if (selectedToken?.dataset.uuid===id) selectedToken=null;
      if (state.fog.activeTokenId===id) state.fog.activeTokenId=null;
      requestFogRedraw();
      syncInspectorFromSelection();
    }

    // ========= INSPECTOR (ACTIONS) =========
    function syncInspectorFromSelection(){
      if (!isHost) return;

      if (!selectedToken){
        inspectorSub.textContent="Selecione um token.";
        vLayer.textContent="-"; vLocked.textContent="-"; vSize.textContent="-";
        vRot.textContent="-"; vZoom.textContent="-"; vFit.textContent="-"; vFog.textContent="-";
        return;
      }

      const id=selectedToken.dataset.uuid;
      inspectorSub.textContent=`Selecionado: ${id.slice(-6)} ‚Ä¢ Layer ${selectedToken.dataset.layer}`;

      const layer = Number(selectedToken.dataset.layer||1);
      const locked= (selectedToken.dataset.locked==="true");
      const w = Number(selectedToken.dataset.sizeW||parseFloat(selectedToken.style.width)||180);
      const rot= Number(selectedToken.dataset.rotation||0);
      const zoom=Number(selectedToken.dataset.innerZoom||1);
      const fit=String(selectedToken.dataset.fitMode||"contain");
      const fog=Number(selectedToken.dataset.visionRadius||600);

      vLayer.textContent=String(layer);
      vLocked.textContent=locked ? "TRAVADO" : "LIVRE";
      vSize.textContent=`${Math.round(w)}px`;
      vRot.textContent=`${Math.round(rot)}¬∞`;
      vZoom.textContent=`${zoom.toFixed(2)}x`;
      vFit.textContent=fit;
      vFog.textContent=`${Math.round(fog)}px`;

      iLayer.value = String(layer);
      iSize.value  = String(clamp(w, 40, 2500));
      iRot.value   = String(clamp(rot, 0, 359));
      iZoom.value  = String(clamp(zoom, 0.2, 5));
      iFit.value   = fit;
      iFog.value   = String(clamp(fog, 50, 2500));
    }

    function inspectorApplyProp(prop, value){
      if (!selectedToken || !isHost) return;
      const id=selectedToken.dataset.uuid;
      const action={type:"UPDATE_PROP", id, prop, value};
      applyAction(action,false); broadcastACT(action);
    }

    iLayer.addEventListener('change',()=>inspectorApplyProp("layer", clamp(Number(iLayer.value||1), 1, 50)));
    iRot.addEventListener('input',()=>inspectorApplyProp("rotation", clamp(Number(iRot.value||0), 0, 359)));
    iZoom.addEventListener('input',()=>inspectorApplyProp("innerZoom", clamp(Number(iZoom.value||1), 0.2, 5)));
    iFit.addEventListener('change',()=>inspectorApplyProp("fitMode", iFit.value));
    iFog.addEventListener('input',()=>{
      inspectorApplyProp("visionRadius", clamp(Number(iFog.value||600), 50, 6000));
      // se ele for o token ativo do fog, redesenha
      if (state.fog.activeTokenId === selectedToken.dataset.uuid) requestFogRedraw();
    });

    iSize.addEventListener('input',()=>{
      if (!selectedToken || !isHost) return;
      const w = clamp(Number(iSize.value||180), 40, 2500);
      const w0 = Number(selectedToken.dataset.sizeW||w);
      const h0 = Number(selectedToken.dataset.sizeH||w);
      const ratio = (w0>0) ? (h0/w0) : 1;
      const h = clamp(Math.round(w*ratio), 40, 2500);
      inspectorApplyProp("size",{w,h});
    });

    function inspectorToggleLock(){
      if (!selectedToken || !isHost) return;
      const id=selectedToken.dataset.uuid;
      const next = selectedToken.dataset.locked==="true" ? "false" : "true";
      const a={type:"UPDATE_PROP", id, prop:"locked", value:next};
      applyAction(a,false); broadcastACT(a);
    }
    function inspectorUnlock(){
      if (!selectedToken || !isHost) return;
      const id=selectedToken.dataset.uuid;
      const a={type:"UPDATE_PROP", id, prop:"locked", value:"false"};
      applyAction(a,false); broadcastACT(a);
    }
    function inspectorSetFogActive(){
      if (!selectedToken || !isHost) return;
      const a={type:"FOG_SET", prop:"activeTokenId", value:selectedToken.dataset.uuid};
      applyAction(a,false); broadcastACT(a);
      showNotification("Vis√£o atribu√≠da ao token!");
    }
    function inspectorBringFront(){
      if (!selectedToken || !isHost) return;
      const l = clamp(Number(selectedToken.dataset.layer||1)+1, 1, 50);
      inspectorApplyProp("layer", l);
      rebuildLayersPanel();
    }
    function inspectorSendBack(){
      if (!selectedToken || !isHost) return;
      const l = clamp(Number(selectedToken.dataset.layer||1)-1, 1, 50);
      inspectorApplyProp("layer", l);
      rebuildLayersPanel();
    }
    function inspectorReset(){
      if (!selectedToken || !isHost) return;
      const id=selectedToken.dataset.uuid;
      const acts=[
        {type:"UPDATE_PROP", id, prop:"innerZoom", value:1},
        {type:"UPDATE_PROP", id, prop:"rotation", value:0},
        {type:"UPDATE_PROP", id, prop:"flipped", value:"false"},
        {type:"UPDATE_PROP", id, prop:"fitMode", value:"contain"},
      ];
      acts.forEach(a=>{ applyAction(a,false); broadcastACT(a); });
    }
    function inspectorDelete(){
      if (!selectedToken || !isHost) return;
      const id=selectedToken.dataset.uuid;
      const a={type:"REMOVE_TOKEN", id};
      applyAction(a,false); broadcastACT(a);
    }

    // ========= Token quick actions (controls) =========
    window.lockToken=(e)=>{
      e.stopPropagation();
      if (!isHost) return;
      const t=e.target.closest('.token'); if(!t) return;
      const a={type:"UPDATE_PROP", id:t.dataset.uuid, prop:"locked", value:"true"};
      applyAction(a,false); broadcastACT(a);
    };
    window.deleteToken=(e)=>{
      e.stopPropagation();
      if (!isHost) return;
      const t=e.target.closest('.token'); if(!t) return;
      const a={type:"REMOVE_TOKEN", id:t.dataset.uuid};
      applyAction(a,false); broadcastACT(a);
    };
    window.zoomInnerToken=(e,delta)=>{
      e.stopPropagation();
      const t=e.target.closest('.token'); if(!t) return;
      if (t.dataset.locked==="true") return;
      if (layerState.locked[Number(t.dataset.layer||1)]) return;
      let z=Number(t.dataset.innerZoom||1);
      z=clamp(z+delta, 0.2, 5);
      const a={type:"UPDATE_PROP", id:t.dataset.uuid, prop:"innerZoom", value:z};
      if (isHost){ applyAction(a,false); broadcastACT(a); } else sendREQ(a);
    };
    window.flipToken=(token)=>{
      if (!token) return;
      if (token.dataset.locked==="true") return;
      if (layerState.locked[Number(token.dataset.layer||1)]) return;
      const nv = (token.dataset.flipped==="false") ? "true" : "false";
      const a={type:"UPDATE_PROP", id:token.dataset.uuid, prop:"flipped", value:nv};
      if (isHost){ applyAction(a,false); broadcastACT(a); } else sendREQ(a);
    };
    window.rotateToken=(e,deg)=>{
      e.stopPropagation();
      const t=e.target.closest('.token'); if(!t) return;
      if (t.dataset.locked==="true") return;
      if (layerState.locked[Number(t.dataset.layer||1)]) return;
      const nv = (Number(t.dataset.rotation||0)+deg)%360;
      const a={type:"UPDATE_PROP", id:t.dataset.uuid, prop:"rotation", value:nv};
      if (isHost){ applyAction(a,false); broadcastACT(a); } else sendREQ(a);
    };
    window.fitToken=(e)=>{
      e.stopPropagation();
      const t=e.target.closest('.token'); if(!t) return;
      if (t.dataset.locked==="true") return;
      if (layerState.locked[Number(t.dataset.layer||1)]) return;
      const id=t.dataset.uuid;
      const acts=[
        {type:"UPDATE_PROP", id, prop:"innerZoom", value:1},
        {type:"UPDATE_PROP", id, prop:"fitMode", value:"contain"},
      ];
      if (isHost) acts.forEach(a=>{applyAction(a,false);broadcastACT(a);});
      else acts.forEach(a=>sendREQ(a));
    };
    window.resetToken=(e)=>{
      e.stopPropagation();
      const t=e.target.closest('.token'); if(!t) return;
      if (t.dataset.locked==="true") return;
      if (layerState.locked[Number(t.dataset.layer||1)]) return;
      const id=t.dataset.uuid;
      const acts=[
        {type:"UPDATE_PROP", id, prop:"innerZoom", value:1},
        {type:"UPDATE_PROP", id, prop:"rotation", value:0},
        {type:"UPDATE_PROP", id, prop:"flipped", value:"false"},
        {type:"UPDATE_PROP", id, prop:"fitMode", value:"contain"},
      ];
      if (isHost) acts.forEach(a=>{applyAction(a,false);broadcastACT(a);});
      else acts.forEach(a=>sendREQ(a));
    };
    window.scaleToken=(e,deltaW)=>{
      e.stopPropagation();
      const t=e.target.closest('.token'); if(!t) return;
      if (t.dataset.locked==="true") return;
      if (layerState.locked[Number(t.dataset.layer||1)]) return;

      const w0=Number(t.dataset.sizeW||parseFloat(t.style.width)||180);
      const h0=Number(t.dataset.sizeH||parseFloat(t.style.height)||180);
      const ratio = (w0>0)?(h0/w0):1;
      const w=clamp(w0+deltaW, 40, 2500);
      const h=clamp(Math.round(w*ratio), 40, 2500);

      const a={type:"UPDATE_PROP", id:t.dataset.uuid, prop:"size", value:{w,h}};
      if (isHost){ applyAction(a,false); broadcastACT(a); } else sendREQ(a);
    };
    window.layerToken=(e,delta)=>{
      e.stopPropagation();
      const t=e.target.closest('.token'); if(!t) return;
      if (t.dataset.locked==="true") return;
      const cur=Number(t.dataset.layer||1);
      const next=clamp(cur+delta, 1, 50);
      ensureLayerDefaults(next);
      const a={type:"UPDATE_PROP", id:t.dataset.uuid, prop:"layer", value:next};
      if (isHost){ applyAction(a,false); broadcastACT(a); rebuildLayersPanel(); }
      else sendREQ(a);
    };

    // ========= Keyboard =========
    window.addEventListener('keydown',(e)=>{
      if (!selectedToken) return;
      if (selectedToken.dataset.locked==="true") return;
      if (layerState.locked[Number(selectedToken.dataset.layer||1)]) return;

      if (e.key.toLowerCase()==='f') flipToken(selectedToken);
      if (e.key==='Delete'){
        if (!isHost) return;
        const id=selectedToken.dataset.uuid;
        const a={type:"REMOVE_TOKEN", id};
        applyAction(a,false); broadcastACT(a);
        selectedToken=null;
      }
    });

    viewport.addEventListener('mousedown',(e)=>{
      if (e.target===viewport || e.target===canvas || e.target===gridLayer || e.target===fogLayer){
        if (selectedToken) selectedToken.classList.remove('selected');
        selectedToken=null;
        syncInspectorFromSelection();
      }
    });

    // ========= DADOS / LOG =========
    function rollDice(faces){
      if (!isHost) return;
      const res=Math.floor(Math.random()*faces)+1;
      const a={type:"DICE", faces, result:res};
      applyAction(a,false); broadcastACT(a);
    }
    function showDiceLog(faces,res){
      const entry=document.createElement('div');
      entry.className="dice-entry mb-2 border-l-2 border-gold pl-3 opacity-0 transform translate-x-4 transition-all duration-300";
      entry.innerHTML=`<span class="opacity-50 text-[10px] font-bold">D${faces}:</span> <b class="text-white text-lg">${res}</b>`;
      diceLogEntries.prepend(entry);
      setTimeout(()=>entry.classList.remove('opacity-0','translate-x-4'),10);
    }

    // ========= IMPORT =========
    function isImageUrl(url){
      return (url.match(/\.(jpeg|jpg|gif|png|webp|avif)$/i)!=null) || url.startsWith('data:image');
    }

    function importFromUrl(inputId, type){
      if (!isHost) return alert("Apenas o Host importa.");
      const url=document.getElementById(inputId).value.trim();
      if (!url) return;

      if (type==="map"){
        if (!isImageUrl(url)) return alert("Mapa precisa ser imagem direta.");
        applyMapLocal(url,true);
        document.getElementById(inputId).value="";
        return;
      }

      if (!isImageUrl(url)) return alert("Tokens precisam ser imagens diretas.");

      if (type==="player") hostCreateToken(url,"image","player");
      else hostCreateToken(url,"image","asset");

      document.getElementById(inputId).value="";
      rebuildLayersPanel();
      requestFogRedraw();
    }

    function importAsset(event, type){
      if (!isHost) return alert("Apenas o Host importa.");
      const file=event.target.files?.[0];
      if (!file) return;
      const reader=new FileReader();
      reader.onload=(e)=>{
        const dataUrl=e.target.result;
        if (type==="map") applyMapLocal(dataUrl,true);
        else if (type==="player") hostCreateToken(dataUrl,"image","player");
        else hostCreateToken(dataUrl,"image","asset");
        rebuildLayersPanel();
        requestFogRedraw();
      };
      reader.readAsDataURL(file);
    }

    // ========= Layers UI (din√¢mico) =========
    function rebuildLayersPanel(){
      if (!isHost) return;

      // Descobre layers existentes a partir dos tokens
      const layers = Array.from(new Set(Object.values(state.tokens).map(t=>Number(t.layer||1)))).sort((a,b)=>a-b);

      // Sempre mostra layer 0 (mapa)
      layersList.innerHTML="";

      // Row do mapa
      {
        const row=document.createElement('div');
        row.className="layer-row";
        row.innerHTML = `
          <div><b>Layer 0</b> <span class="mini">(Mapa)</span></div>
          <div style="display:flex;gap:10px;">
            <div class="pill active" style="pointer-events:none;opacity:.85;">Sempre vis√≠vel</div>
            <div class="pill ${state.map.locked?'active':''}" onclick="toggleMapLock()">Mapa ${state.map.locked?'Trancado':'Livre'}</div>
          </div>
        `;
        layersList.appendChild(row);
      }

      // Se n√£o tem tokens, mostra hint
      if (!layers.length){
        const empty=document.createElement('div');
        empty.className="mini";
        empty.style.padding="10px 2px";
        empty.textContent="Nenhuma layer de tokens ainda. Adicione pe√ßas/players para criar.";
        layersList.appendChild(empty);
        return;
      }

      // Rows layers >= 1
      for (const l of layers){
        ensureLayerDefaults(l);

        const row=document.createElement('div');
        row.className="layer-row";

        const left=document.createElement('div');
        left.innerHTML = `<b>Layer ${l}</b> <span class="mini">(tokens)</span>`;

        const actions=document.createElement('div');
        actions.style.display="flex";
        actions.style.gap="10px";

        const vis=document.createElement('div');
        vis.className = "pill " + (layerState.visible[l] ? "active" : "");
        vis.textContent = layerState.visible[l] ? "Vis√≠vel" : "Oculta";
        vis.onclick=()=>{
          const a={type:"LAYER_SET", layer:l, prop:"visible", value:!layerState.visible[l]};
          applyAction(a,false); broadcastACT(a);
        };

        const lock=document.createElement('div');
        lock.className = "pill " + (layerState.locked[l] ? "active" : "");
        lock.textContent = layerState.locked[l] ? "Trancada" : "Livre";
        lock.onclick=()=>{
          const a={type:"LAYER_SET", layer:l, prop:"locked", value:!layerState.locked[l]};
          applyAction(a,false); broadcastACT(a);
        };

        actions.appendChild(vis);
        actions.appendChild(lock);

        row.appendChild(left);
        row.appendChild(actions);
        layersList.appendChild(row);
      }
    }

    // ========= CLEAR / UNLOCK =========
    function clearTable(){
      if (!isHost) return;
      if (!confirm("Deseja limpar todos os tokens e o mapa?")) return;
      const a={type:"CLEAR"};
      applyAction(a,false); broadcastACT(a);
    }

    function unlockEverything(){
      if (!isHost) return;
      for (const id of Object.keys(state.tokens)){
        const a={type:"UPDATE_PROP", id, prop:"locked", value:"false"};
        applyAction(a,false); broadcastACT(a);
      }
      // destrava layers tamb√©m
      for (const l of Object.keys(layerState.locked)){
        const a={type:"LAYER_SET", layer:Number(l), prop:"locked", value:false};
        applyAction(a,false); broadcastACT(a);
      }
      if (state.map.locked) setMapLockLocal(false,true);
      showNotification("Tudo destrancado!");
    }

    // ========= P2P PROTOCOL =========
    function sendREQ(action){
      if (isHost){
        applyHostAuthorizedAction(action,{sender:myId});
        return;
      }
      if (hostConnection?.open){
        hostConnection.send({kind:"REQ", sender:myId, action});
      }
    }

    function broadcastACT(action, meta={}){
      if (!isHost) return;
      const msg={kind:"ACT", sender:myId, action, meta};
      for (const c of connections){ if (c.open) c.send(msg); }
    }

    function sendSYNC(conn){
      if (!isHost) return;
      conn.send({kind:"SYNC", sender:myId, state, layerState});
    }

    function handleNetworkData(data, connPeerId=null){
      if (!data?.kind) return;

      if (data.kind==="SYNC"){
        applyFullSync(data.state, data.layerState);
        return;
      }
      if (data.kind==="ACT"){
        applyAction(data.action,true);
        return;
      }
      if (data.kind==="REQ"){
        if (!isHost) return;
        const sender=data.sender || connPeerId || "unknown";
        applyHostAuthorizedAction(data.action,{sender});
      }
    }

    // ========= Player validation =========
    function validateClientAction(action){
      if (!action?.type) return {ok:false,reason:"A√ß√£o inv√°lida"};

      // Player pode: MOVE e UPDATE_PROP (sem mexer em layer/fog/map)
      const allowed = new Set(["MOVE","UPDATE_PROP"]);
      if (!allowed.has(action.type)) return {ok:false,reason:"A√ß√£o n√£o permitida"};

      const id=action.id;
      if (!id || !state.tokens[id]) return {ok:false,reason:"Token inexistente"};

      const tok=state.tokens[id];
      const layer=Number(tok.layer||1);
      ensureLayerDefaults(layer);

      if (!layerState.visible[layer]) return {ok:false,reason:"Layer oculta"};
      if (layerState.locked[layer]) return {ok:false,reason:"Layer trancada"};
      if (String(tok.locked)==="true") return {ok:false,reason:"Token travado"};

      if (action.type==="UPDATE_PROP"){
        // Player N√ÉO altera layer / locked / visionRadius por seguran√ßa
        const allowedProps = new Set(["rotation","flipped","innerZoom","size","fitMode"]);
        if (!allowedProps.has(action.prop)) return {ok:false,reason:"Prop n√£o permitida"};

        if (action.prop==="innerZoom"){
          const z=Number(action.value);
          if (!Number.isFinite(z) || z<.2 || z>5) return {ok:false,reason:"Zoom inv√°lido"};
        }
        if (action.prop==="size"){
          const w=Number(action.value?.w), h=Number(action.value?.h);
          if(!Number.isFinite(w)||!Number.isFinite(h)) return {ok:false,reason:"Size inv√°lido"};
          if(w<40||w>2500||h<40||h>2500) return {ok:false,reason:"Size fora limite"};
        }
        if (action.prop==="fitMode"){
          if(!["contain","cover"].includes(String(action.value))) return {ok:false,reason:"fit inv√°lido"};
        }
      }
      return {ok:true};
    }

    function applyHostAuthorizedAction(action,{sender}){
      const fromClient = sender && sender !== myId;
      if (fromClient){
        const v=validateClientAction(action);
        if (!v.ok){ console.warn("REQ negada:", v.reason, action); return; }
      }
      applyAction(action,false);
      broadcastACT(action,{approvedBy:myId, originalSender:sender});
    }

    // ========= APPLY ACTION =========
    function applyAction(action){
      switch(action.type){
        case "CLEAR":{
          // DOM
          document.querySelectorAll('.token').forEach(t=>t.remove());
          mapContainer.innerHTML="";
          document.querySelectorAll('.dice-entry').forEach(l=>l.remove());
          selectedToken=null;
          stopMapInertia();
          mapDragging=false;

          // State
          state.map={src:null,locked:false,x:0,y:0};
          state.tokens={};
          state.fog.activeTokenId=null;

          // LayerState mant√©m visibilidade, mas como layers somem, pain√©is ficam vazios
          setMapLockLocal(false,false);
          setMapOffset(0,0);

          rebuildLayersPanel();
          applyLayerVisibilityToDOM();
          drawFog();
          syncInspectorFromSelection();
          break;
        }

        case "MAP_UPDATE":{
          state.map.src = action.src;
          applyMapLocal(action.src,false);
          break;
        }

        case "MAP_LOCK":{
          setMapLockLocal(!!action.locked,false);
          break;
        }

        case "MAP_MOVE":{
          setMapOffset(Number(action.x||0), Number(action.y||0));
          break;
        }

        case "CREATE_TOKEN":{
          const {id, src, contentType, props} = action;
          addTokenLocal(src, contentType, id, props);
          state.tokens[id]=normalizeTokenProps(id,src,contentType,props);

          // Se n√£o existe layer defaults, cria
          ensureLayerDefaults(Number(props?.layer ?? 1));

          rebuildLayersPanel();
          applyLayerVisibilityToDOM();
          requestFogRedraw();
          break;
        }

        case "REMOVE_TOKEN":{
          removeTokenLocal(action.id);
          delete state.tokens[action.id];
          rebuildLayersPanel();
          applyLayerVisibilityToDOM();
          requestFogRedraw();
          break;
        }

        case "MOVE":{
          moveTokenDOM(action.id, action.x, action.y);
          if (state.tokens[action.id]){
            state.tokens[action.id].x = action.x;
            state.tokens[action.id].y = action.y;
          }
          break;
        }

        case "UPDATE_PROP":{
          updateTokenPropDOM(action.id, action.prop, action.value);
          if (state.tokens[action.id]){
            const t=state.tokens[action.id];
            if (action.prop==="locked") t.locked=String(action.value);
            if (action.prop==="innerZoom") t.innerZoom=action.value;
            if (action.prop==="rotation") t.rotation=action.value;
            if (action.prop==="flipped") t.flipped=action.value;
            if (action.prop==="fitMode") t.fitMode=action.value;
            if (action.prop==="size"){ t.w=action.value.w; t.h=action.value.h; }
            if (action.prop==="layer"){ t.layer=Number(action.value); ensureLayerDefaults(Number(action.value)); }
            if (action.prop==="visionRadius"){ t.visionRadius=Number(action.value); }
          }
          rebuildLayersPanel();
          applyLayerVisibilityToDOM();
          requestFogRedraw();
          break;
        }

        case "DICE":{
          showDiceLog(action.faces, action.result);
          break;
        }

        case "LAYER_SET":{
          const l=Number(action.layer);
          ensureLayerDefaults(l);
          if (action.prop==="visible") layerState.visible[l]=!!action.value;
          if (action.prop==="locked") layerState.locked[l]=!!action.value;
          applyLayerVisibilityToDOM();
          rebuildLayersPanel();
          break;
        }

        case "FOG_SET":{
          if (action.prop==="enabled"){
            state.fog.enabled = !!action.value;
            btnFog.classList.toggle('active', state.fog.enabled);
          }
          if (action.prop==="activeTokenId"){
            state.fog.activeTokenId = action.value || null;
          }
          if (action.prop==="softness"){
            state.fog.softness = Number(action.value);
          }
          if (action.prop==="darkness"){
            state.fog.darkness = Number(action.value);
          }
          requestFogRedraw();
          break;
        }
      }
    }

    function applyFullSync(s, ls){
      // limpa DOM
      document.querySelectorAll('.token').forEach(t=>t.remove());
      mapContainer.innerHTML="";
      document.querySelectorAll('.dice-entry').forEach(l=>l.remove());
      selectedToken=null;
      stopMapInertia();

      // layerState
      layerState.visible = ls?.visible || {};
      layerState.locked  = ls?.locked  || {};

      // state
      state.map = JSON.parse(JSON.stringify(s?.map || {src:null,locked:false,x:0,y:0}));
      state.fog = JSON.parse(JSON.stringify(s?.fog || {enabled:false,activeTokenId:null,softness:0.18,darkness:0.88}));
      state.tokens = {};

      if (state.map.src) applyMapLocal(state.map.src,false);
      setMapLockLocal(!!state.map.locked,false);
      setMapOffset(Number(state.map.x||0), Number(state.map.y||0));

      const tokens = s?.tokens || {};
      for (const id of Object.keys(tokens)){
        const t=tokens[id];
        ensureLayerDefaults(Number(t.layer||1));
        addTokenLocal(t.src, t.type, id, t);
        state.tokens[id]=JSON.parse(JSON.stringify(t));
      }

      btnFog.classList.toggle('active', !!state.fog.enabled);

      applyLayerVisibilityToDOM();
      rebuildLayersPanel();
      syncInspectorFromSelection();
      drawFog();
    }

    // ========= NETWORK SETUP =========
    function initNetwork(){
      const urlParams=new URLSearchParams(window.location.search);
      const roomID=urlParams.get('room');

      peer=new Peer(null,{debug:2, config:PEER_ICE_CONFIG});

      peer.on('open',(id)=>{
        myId=id;

        if (roomID){
          isHost=false;
          setRoleUI();
          statusText.innerText="Conectando ao Host...";
          tinyStatus.textContent="Conectando...";
          tinyRoom.textContent=roomID;
          connectToHost(roomID);
        } else {
          isHost=true;
          setRoleUI();
          statusText.innerText="Online (Host)";
          tinyStatus.textContent="Online (Host)";
          tinyRoom.textContent=id;
          statusDot.classList.add('online');
          toggleNetworkPanel();

          peer.on('connection',(conn)=>{
            connections.push(conn);
            setupConnection(conn);
            conn.on('open',()=>setTimeout(()=>sendSYNC(conn),200));
            conn.on('close',()=>{ connections=connections.filter(c=>c!==conn); });
          });
        }
      });

      peer.on('error',(err)=>{
        console.error(err);
        statusText.innerText="Erro Rede";
        tinyStatus.textContent="Erro Rede";
        statusDot.classList.remove('online');
      });
    }

    function connectToHost(hostId){
      hostConnection=peer.connect(hostId);
      setupConnection(hostConnection);

      hostConnection.on('open',()=>{
        statusText.innerText="Conectado";
        tinyStatus.textContent="Conectado";
        statusDot.classList.add('online');
      });

      hostConnection.on('close',()=>{
        statusText.innerText="Desconectado";
        tinyStatus.textContent="Desconectado";
        statusDot.classList.remove('online');
        alert("O Host desconectou.");
      });
    }

    function setupConnection(conn){
      conn.on('data',(data)=>handleNetworkData(data, conn.peer));
    }

    // ========= CONTEXT MENU OFF =========
    window.addEventListener('contextmenu',(e)=>e.preventDefault());

    // ========= START =========
    initNetwork();

  </script>
</body>
</html>
